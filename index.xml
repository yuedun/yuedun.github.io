<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>月盾的博客</title>
    <link>https://www.yuedun.wang/</link>
    <description>Recent content on 月盾的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Sep 2023 14:18:30 +0800</lastBuildDate><atom:link href="https://www.yuedun.wang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>目录</title>
      <link>https://www.yuedun.wang/catalog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/catalog/</guid>
      <description>2023年 (2023-7-1) 阿里云oss私有桶图片处理 (2023-5-15) next.js项目使用pm2 reload出现502 (2023-5-10) jenkins代替品 (2023-4-22) Centos Appstream Error (2023-2-28) 2010年的笔记本升级硬件，再战10年 (2023-1-31) Thinkpad T450加装固态硬盘记录 (2023-1-3) Ld Warning Object File Was Built for Newer MacOS Version Than Being Linked 2022年 (2022-12-31) Sveltekit1.0后的使用感受 (2022-9-28) Elasticsearch批量insert和批量upsert (2022-5-12) go http响应乱码 (2022-2-16) chrome开发者工具显示接口完整路径 2021年 (2021-11-08) postman header中自动添加cookie (2021-9-18) 最近关于公司的一些事 (2021-7-23) 事件驱动编程、消息驱动编程、数据驱动编程 (2021-7-18) 为什么夜间电费只收半价？ (2021-7-13) Gorm Model Find First Where等查询函数的区别 (2021-7-10) Chrome插件hook Ajax (2021-7-06) 七牛在线管理图片预览chrome插件 (2021-6-18) gitpage Hugo统计每一篇文章浏览量 (2021-6-17) 博客迁移至hugo gitpage (2021-6-14) vscode正则查找替换 (2021-5-31) typescript不检查node_moduls (2021-5-07) 朱雀发布系统支持scp（rsync）发布 (2021-5-02) 一体LED可伸缩变焦手电筒拆解 (2021-4-26) easy-monitor qps监控 (2021-4-07) 使用sveltekit开发一个服务端渲染（SSR）项目 (2021-3-30) 关于svelte框架——sapper和sveltekit的发展 (2021-3-08) /bin/rm: argument list too long (2021-2-02) firefox火狐新标签中打开书签 (2021-1-14) nestjs中使用携程Apollo配置中心 (2021-1-08) svelte history路由刷新后404 (2021-1-05) 基于sapper开发svelte项目配置本地代理 (2021-1-05) svelte项目rollup配置px2rem 2020年 (2020-12-29) svelte函数传参 (2020-12-02) go单元测试初始化 (2020-11-28) Svelte3路由 (2020-11-20) vscode远程开发应用场景 (2020-11-17) 通用的数据库GUI工具 (2020-11-10) puppeteer模拟3G网络 (2020-11-03) postman使用技巧 (2020-9-23) vue nuxt组建注册 (2020-8-23) nodejs专用发布系统 (2020-8-14) MEGAEASE的远程工作文化 (2020-8-01) vue子组件修改父组件的数据 (2020-7-29) 原生js实现图片预览 (2020-7-27) goquery 中文乱码 (2020-7-26) 国产动漫之不幸 (2020-7-19) 关于个人博客（网站）发展的一些思考 (2020-7-17) 让web项目不再502 (2020-6-19) go mongo-driver动态条件 (2020-6-15) puppeteer TypeError: text is not iterable (2020-5-10) 你是拿锤子的前端开发吗？ (2020-4-15) 人人都值得学习的UI自动化 (2020-4-07) 免费的mongodb集群 (2020-4-06) golang操作mongodb (2020-4-04) mongodb创建新数据库和创建用户 (2020-4-02) 使用pm2一键部署多个服务 (2020-3-30) gorm模糊查询和分页查询同时查总条数 (2020-3-17) go-micro线上部署，注册服务到etcd (2020-3-14) go-micro v2弃用了consul作为默认的服务发现 (2020-2-04) windows调整C盘大小 (2020-1-16) beego httplib库使用方法 (2020-1-10) “中台”是架构的捷径吗？ (2020-1-06) win10资源管理器窗口标题栏设置颜色 2019年 (2019-12-27) 胡同里遇鬼 (2019-12-13) 一次商业web网站搭建的取舍过程 (2019-11-18) linux安装nodejs——快捷版 (2019-10-23) 让代码配置化 (2019-9-17) 再坚持一下，你的奶茶店马上破产 (2019-4-30) nestjs框架中使用nunjucks模板引擎 (2019-2-25) Consul 入门教程 (2019-2-25) 服务发现：Zookeeper vs etcd vs Consul (2019-2-23) 热水器维修 (2019-2-23) 部署golang到服务器 (2019-2-20) nodejs-go内存占比 (2019-2-12) go语言开发grpc——安装grpc 2018年 (2018-10-13) gRPC负载均衡 (2018-10-11) linux修改MySQL 5.</description>
    </item>
    
    <item>
      <title>速记</title>
      <link>https://www.yuedun.wang/quicknote/</link>
      <pubDate>Sun, 20 Jun 2021 19:25:42 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/quicknote/</guid>
      <description>input和datalist结合使用不提示！
&amp;lt;input type=&amp;#34;text&amp;#34; class=&amp;#34;form-control&amp;#34; id=&amp;#34;art_category&amp;#34; list=&amp;#34;catelist&amp;#34; value=&amp;#34;{{.article.Category}}&amp;#34; placeholder=&amp;#34;分类&amp;#34;&amp;gt; &amp;lt;datalist name=&amp;#34;catelist&amp;#34;&amp;gt; &amp;lt;option value=&amp;#34;&amp;#34;&amp;gt;选择&amp;lt;/option&amp;gt; {{range $index, $item := .categories}} &amp;lt;option value=&amp;#34;{{$item.Name}}&amp;#34;&amp;gt; {{end}} &amp;lt;/datalist&amp;gt; 原因：list=&amp;quot;catelist&amp;quot;对应的应该是id=&amp;quot;catelist&amp;quot;，上面代码使用的是name=&amp;quot;catelist&amp;quot;，是错误的写法
2021-08-18
Unexpected identifier in D:\workspace\yuedun_ts\build\views\article\index.html while compiling ejs If the above error is not helpful, you may want to try EJS-Lint: https://github.com/RyanZim/EJS-Lint Or, if you meant to create an async function, pass async: true as an option. &amp;lt;% include header.html %&amp;gt;改为&amp;lt;%- include(&amp;lsquo;header.html&amp;rsquo;)%&amp;gt;
2020-05-29 15:39:32
edge chrome下载地址：https://www.microsoftedgeinsider.com/en-us/download
2019-10-12 10:04:22</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://www.yuedun.wang/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/about/</guid>
      <description>网名：月盾
工作地：上海
技能：nodejs，golang，react，vue，jquery，爬虫，mongodb。
其他：本博客由基于gitpage，hugo提供技术服务。
QQ：438473005</description>
    </item>
    
    <item>
      <title>https证书生成</title>
      <link>https://www.yuedun.wang/2023/09/https-ca/</link>
      <pubDate>Tue, 12 Sep 2023 14:18:30 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/09/https-ca/</guid>
      <description>生成crt证书
openssl req -new -x509 -key domain.key -out domain.crt -days 365
将CRT转换为CSR：
openssl req -new -key domain.key -out domain.csr</description>
    </item>
    
    <item>
      <title>阿里云oss私有桶图片处理</title>
      <link>https://www.yuedun.wang/2023/07/ali-oss-process/</link>
      <pubDate>Sat, 01 Jul 2023 18:13:43 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/07/ali-oss-process/</guid>
      <description>针对OSS内存储的图片文件（Object），您可以在GetObject请求中携带图片处理参数对图片文件进行处理。例如添加图片水印、转换格式等。详情见：官方文档
对于允许公共读写的文件可以直接在图片URL后面拼接参数的方式进行图片处理，格式：https://bucketname.endpoint/objectname?x-oss-process=image/action,parame_value
对于不允许匿名访问的私有图片文件，不支持通过文件URL直接添加参数的方式处理图片，您需要通过SDK的方式将图片处理操作加入签名URL中。
重要： 通过文件URL访问图片时，默认是下载行为。如需确保通过文件URL访问图片时是预览行为，您需要绑定自定义域名并添加CNAME记录。具体操作，请参见绑定自定义域名。
所以，私有桶的图片是不能直接添加参数处理，否则会返回错误信息：
SignatureDoesNotMatch
The request signature we calculated does not match the signature you provided. Check your key and signing method.
SDK处理方法，以go版本为例：
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.com/aliyun/aliyun-oss-go-sdk/oss&amp;#34; ) func HandleError(err error) { fmt.Println(&amp;#34;Error:&amp;#34;, err) os.Exit(-1) } func main() { // 创建OSSClient实例。 // yourEndpoint填写Bucket对应的Endpoint，以华东1（杭州）为例，填写为https://oss-cn-hangzhou.aliyuncs.com。其它Region请按实际情况填写。 // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。 client, err := oss.New(&amp;#34;yourEndpoint&amp;#34;, &amp;#34;yourAccessKeyId&amp;#34;, &amp;#34;yourAccessKeySecret&amp;#34;) if err != nil { HandleError(err) } // 指定图片所在Bucket的名称，例如examplebucket。 bucketName := &amp;#34;examplebucket&amp;#34; bucket, err := client.</description>
    </item>
    
    <item>
      <title>next/image组件导致服务器504超时</title>
      <link>https://www.yuedun.wang/2023/05/next-image-timeout/</link>
      <pubDate>Wed, 17 May 2023 19:38:34 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/05/next-image-timeout/</guid>
      <description>谁能想到，一个前端组件也能把服务搞崩溃。这个组件正是next/image，原本是想利用next/image来优化图片，next.js官方也一直推荐这么做。
突然有一天用户反馈网站出现504超时报错，当时优先重启恢复服务。然后把日志打开观察，果不其然，几分钟后就又出现504超时，伴随出现的日志则是：
upstream image response failed for https://example.com/280d59d8-f3b0-11ed-a295-00163e253f9a_00002_VvBbv3zj.jpg?OSSAccessKeyId=LTAI5nodLHeacT1J5SmWh&amp;amp;Expires=317044217325&amp;amp;Signature=Wf5jYWf7vnXOyRoKLVtiTCrt8%3D 404 初步判断是图片404导致服务器超时，深入猜测是使用next.js服务端渲染请求了图片资源，而图片资源不存在导致服务器渲染出错。
但是很不合理，服务端只是把图片资源的地址渲染到html中，并不会在服务端请求图片资源才对，为什么服务器日志会出现上述错误信息呢？于是观察浏览器中图片的请求，发现格式是这样的： http://example.com/_next/image?url=https%3A%2F%2Fexample.com%2Ff6c912da-f0cc0000_0d7GBaLE.jpg%3FOSSAccessKeyId%3DmWh%26Expires%3D317043899846%26Signature%3DYUMro%253D&amp;amp;w=384&amp;amp;q=75
浏览器请求的图片资源并不是图片的真实地址，而是经过了next.js服务处理的，尤其是URL最后两个参数，是图片压缩参数。如果你发现图片变模糊了，也可能是这两个参数捣的鬼。直接拿着这个地址去浏览器请求发现响应很慢，这时再次得出结论：这个图片组件有问题。为了验证把所有使用了next/image组件全部使用原生img标签，发布到线上后就再没出现504超时。
总结：next/image组件包装后的图片资源需要经过node层压缩处理，会消耗CPU资源，对于大量的图片资源会有风险，酌情处理。 本次出现的时候伴随着图片资源404，可能是有bug存在，如果加载不到正确的图片就会触发bug。 另一种解决方案：根据官方文档说明，如果使用next/image,需要添加sharp包来提高性能，但是可能需要注意内存消耗问题。</description>
    </item>
    
    <item>
      <title>next.js项目使用pm2 reload出现502</title>
      <link>https://www.yuedun.wang/2023/05/pm2-reload-nextjs-502/</link>
      <pubDate>Mon, 15 May 2023 19:09:41 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/05/pm2-reload-nextjs-502/</guid>
      <description>为了使next.js项目能够不宕机，使用了pm2守护进程，既能保证node出现异常情况能够自动重启，也能保证服务器整机重启时自动恢复服务。多年使用下来的确能够良好运行，不过最近却出现了与原本期望不符的情况。
在已经启动next.js项目的情况下，如果需要重启，我使用了pm2 reload appname，实际上没有完美的零停机重启，反而是直接出现服务不可用，访问网站就502，并且一直无法恢复。在查阅pm2 issue后发现确实有这样的bug。
无奈，只能使用pm2 restart来重启应用。</description>
    </item>
    
    <item>
      <title>jenkins代替品</title>
      <link>https://www.yuedun.wang/2023/05/ci-cd/</link>
      <pubDate>Wed, 10 May 2023 18:55:23 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/05/ci-cd/</guid>
      <description>如果你打算搭建一套发布系统，你可能会考虑jenkins，或者其他。 我要介绍的则是一些现成的，使用更简单的工具。没用特殊环境要求的情况下则完全可以代替jenkins。
GitHub Actions 阿里云流水线 coding持续部署 上面只是列举了三类，实际上你会发现市面上的云服务商和代码仓库都提供了类似的工具，虽然有些是收费的，但是也有不少免费的，对于个人来说其实大多数都是够用了。</description>
    </item>
    
    <item>
      <title>Centos Appstream Error</title>
      <link>https://www.yuedun.wang/2023/04/centos-appstream-error/</link>
      <pubDate>Sat, 22 Apr 2023 16:36:21 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/04/centos-appstream-error/</guid>
      <description>[root@hecs-221218 network-scripts]# yum install rsync CentOS-8 - AppStream 3.4 kB/s | 394 B 00:00 Errors during downloading metadata for repository &amp;#39;AppStream&amp;#39;: - Status code: 404 for https://repo.huaweicloud.com/centos/8/AppStream/x86_64/os/repodata/repomd.xml (IP: 61.172.228.200) Error: Failed to download metadata for repo &amp;#39;AppStream&amp;#39;: Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried 解决办法：
修改/etc/yum.repos.d/CentOS-AppStream.repo中的baseurl为 baseurl=https://mirrors.aliyun.com/centos/8-stream/AppStream/x86_64/os/</description>
    </item>
    
    <item>
      <title>2010年的笔记本升级硬件，再战10年</title>
      <link>https://www.yuedun.wang/2023/02/acer-4741g-upgrade/</link>
      <pubDate>Tue, 31 Jan 2023 10:58:35 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/02/acer-4741g-upgrade/</guid>
      <description>上个月把thinkpad升级了固态硬盘后，彷佛打开了新世界的大门。想起了我2010年买的宏基4741g还在压箱底，何不也来次大换血？ 问：这都2023年了，高性能的笔记本一抓一大把，14年前的电脑早该化成灰了，还有必要使用吗？ 我想要升级老电脑的原因主要有两点：
就是玩，本人就是一个电子爱好者，平时就是喜欢把家电修修补补。 对于只是日常办公够用就行，不太追求极致的性能体验。 宏基4741g属于2010年的产品，当时买来是用于学习计算机使用的，一直用到2016年，期间也有过多次维修经历。因为散热差，经常因为工作开太多程序导致意外关机，所以购买了Thinkpad T450，从此让我有了最差的电脑使用体验。好在后来大多数时间都是使用公司提供的电脑，Thinkpad就放家里看看电影，写代码根本不想打开它，开机6分钟，命令行提示卡十几秒。我是用了6年的4741g都没让我受过这气。
所以，基本可以确定，10年宏基4741g在性能上比16年Thinkpad T450好不少，如果升级一下硬盘和内存，使用体验肯定不会差。
然后就是35元买了120G固态硬盘，35元的4G内存，10元买了硬盘盒。原来是32位win7系统，现在重装了64位win7，这样一升级性能至少翻倍，再用10年没毛病吧。</description>
    </item>
    
    <item>
      <title>Thinkpad T450加装固态硬盘记录</title>
      <link>https://www.yuedun.wang/2023/01/thinkpadjiagutaiyingpan/</link>
      <pubDate>Tue, 31 Jan 2023 10:58:35 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/01/thinkpadjiagutaiyingpan/</guid>
      <description>2016年初花大价钱买的thinkpad t450准备用来工作，结果发现性能太差，根本满不了需求。于是就放家里日常使用，即使这样还是无法忍受它的慢，慢到什么程度呢？开机到桌面3分钟，再到打开程序3分钟。这还不如我2010年买的2G内存i3电脑性能好。后来把内存从4G加到8G没有明显提升，那就剩下CPU和机械硬盘的问题了，CPU是低压版i5 4300U，和主板焊在一起，没法升级。前几年就想升级硬盘，但是那时候固态硬盘价格不便宜，也没有着急升级。直到最近才忍受不了，下定决心升级一下。
升级过程并不顺利……
首先是确定支持的接口，thinkpad t450已经装了一块16G固态硬盘，接口是M.2（即NGFF，现在已经改名为M.2了）
真实尺寸很小，22*42mm大小，就是2240型号。2280型号意思就是宽22长80，自然就是更大尺寸的。选择的时候要注意不要选错。
安装好以后使用傲梅分区助手进行系统迁移（之后遇到很多问题），然后在bios里修改启动顺序，结果左上角的光标一直闪，无法进入系统，修改为原HDD硬盘后还是可以启动的。网上有说法是磁盘盘符冲突，按照方法在注册表中调换盘符后还是进入不了系统，甚至原来的磁盘系统也进入不了。
无奈，只能重装系统。但是不能在原来的盘里装，需要直接装套SSD固态硬盘上。准备了8G U盘，4G肯定是不够的，win10系统就有4.5G以上了。下载winpe，直接安装到U盘里，然后将下载好的win10系统拷贝到winpe工具箱里。
再修改启动顺序重启系统，这时候也出现问题，识别不到U盘，我是在系统启动后再插上U盘，如果直接插上再启动就会识别不出来。进入到pe系统后首先通过系统安装器安装系统，又出现找不到iso系统文件的情况，重插U盘解决。但是选择目标盘后MBR始终是黄色，无法变成绿色，最后通过CGI工具还原的方式成功安装。
安装成功重启又出现boot menu界面，死活进入不了系统，这个是由于在bios中修改过启动方式引起的。有uefi和legacy两种模式，设置为both兼容模式启动。至此算是安装成功。
由于加了SSD固态硬盘，原来的盘符也有变化，SSD成了C盘，原来的C盘变成了D盘，以此类推。手动把原盘中的快捷方式拷贝过新盘，都用不了，可以通过属性-修改路径的方式修正。个别软件缺少dll动态链接库也可以从原盘找到，有两个目录可以查找windows-System32,windows-Syswow64。
总结：系统启动时间由3分钟提升到了30秒，到桌面也可以直接操作，不需要再等3分钟才能做操作。</description>
    </item>
    
    <item>
      <title>Ld Warning Object File Was Built for Newer MacOS Version Than Being Linked</title>
      <link>https://www.yuedun.wang/2023/01/ld-warning-object-file-was-built-for-newer-macos-version-than-being-linked/</link>
      <pubDate>Tue, 03 Jan 2023 10:46:35 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/01/ld-warning-object-file-was-built-for-newer-macos-version-than-being-linked/</guid>
      <description>go run和go build会报出一连串下面这样的警告信息，虽然不影响程序运行，但是看着难看。
# command-line-arguments ld: warning: object file (/var/folders/9p/2x3ls9kn7qb59hf9l9mtfs8s6rbmfg/T/go-link-3994413096/000000.o) was built for newer macOS version (12.0) than being linked (11.0) 解决方法：CGO_CFLAGS=-mmacosx-version-min=10.12 go run main.go，运行前加CGO_CFLAGS=-mmacosx-version-min=10.12参数可以解决。
vscode中可以通过配置launch.json文件实现：
{ &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;configurations&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Launch Package&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;go&amp;#34;, &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;, &amp;#34;env&amp;#34;: { &amp;#34;CGO_CFLAGS&amp;#34;:&amp;#34;-mmacosx-version-min=10.12&amp;#34; }, &amp;#34;program&amp;#34;: &amp;#34;${fileDirname}&amp;#34;, &amp;#34;args&amp;#34;: [], &amp;#34;cwd&amp;#34;: &amp;#34;${fileDirname}&amp;#34; } ] } 或者从文件中读取环境变量：
{ &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;configurations&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Launch Package&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;go&amp;#34;, &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;, &amp;#34;envFile&amp;#34;: &amp;#34;${workspaceFolder}/.env&amp;#34;, &amp;#34;program&amp;#34;: &amp;#34;${fileDirname}&amp;#34;, &amp;#34;args&amp;#34;: [], &amp;#34;cwd&amp;#34;: &amp;#34;${fileDirname}&amp;#34; } ] } 如果是在vscode中执行测试代码，则需要设置settings.</description>
    </item>
    
    <item>
      <title>Sveltekit1.0后的使用感受</title>
      <link>https://www.yuedun.wang/2022/12/sveltekit/</link>
      <pubDate>Sat, 31 Dec 2022 11:02:40 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2022/12/sveltekit/</guid>
      <description>之前提到过关于svelte框架——sapper和sveltekit的发展，已经是1年前的事了，其中提到过svelte的框架sapper和sveltekit，sapper已经明确不再更新了，官方推荐的是sveltekit。然后经过两年的迭代更新，于2022年12月终于推出了1.0版本。可以看看官方博客对1.0的介绍Announcing SvelteKit 1.0。
然后谈谈个人感受。
优点： sveltekit集成的还不错，开发体验可以，使用官方提供的脚手架创建的项目就可以直接使用，不需要做任何配置。热更新，响应速度快，支持typescript等等，该有的都有了。
缺点： 又是一个全新轮子，这也是整个前端的通病，除了js是通用的，其他的都能给你整出花来，sveltekit在1.0版本之内已经有破坏性的更新，一年前创建的新项目，一年后基本不能用了。
至于要不要使用，那就看个人情况了，如果你厌烦了其他框架，倒是可以尝尝鲜，如果你想以此来做长期项目的话，个人就不推荐了，毕竟太新，而且向下兼容又做的不好，隔三差五一个破坏性更新，这种折腾劲恐怕没几个人受得了。而且对自己的技术也不能积累，长此以往并没有好处。
sveltekit官方文档</description>
    </item>
    
    <item>
      <title>Elasticsearch批量insert和批量upsert</title>
      <link>https://www.yuedun.wang/2022/09/elasticsearch-bulk-upsert/</link>
      <pubDate>Wed, 28 Sep 2022 14:00:43 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2022/09/elasticsearch-bulk-upsert/</guid>
      <description>golang版本的elasticsearch批量插入和批量更新方法如下：
package main import ( &amp;#34;github.com/elastic/go-elasticsearch/v8&amp;#34; &amp;#34;github.com/elastic/go-elasticsearch/v8/esutil&amp;#34; ) func main() { list:=make(User, 0) bulkES(list) } func bulkES(list []User) error { indexer, err := esutil.NewBulkIndexer(esutil.BulkIndexerConfig{ Index: &amp;#34;search-user&amp;#34;, Client: ES, }) if err != nil { return err } for _, v := range list { data, err := json.Marshal(v) if err != nil { return err } err = indexer.Add( context.Background(), esutil.BulkIndexerItem{ Action: &amp;#34;index&amp;#34;, Body: bytes.NewReader(data), }, ) if err != nil { return err } } indexer.</description>
    </item>
    
    <item>
      <title>go http响应乱码</title>
      <link>https://www.yuedun.wang/2022/05/http-response-garbled/</link>
      <pubDate>Thu, 12 May 2022 21:46:13 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2022/05/http-response-garbled/</guid>
      <description>golang请求接口返回的数据乱码，原因之一是请求头设置了&amp;quot;Accept-Encoding&amp;quot;: &amp;quot;gzip, deflate, br&amp;quot;，那么如果服务器支持的话响应的数据就会经过gzip，deflate，br等方式的压缩，解决方式是对数据解压，或者可以不设置接收方式，即&amp;quot;Accept-Encoding&amp;quot;: &amp;quot;&amp;quot;
import &amp;#34;github.com/andybalholm/brotli&amp;#34; import &amp;#34;compress/flate&amp;#34; import &amp;#34;compress/gzip&amp;#34; // 检测返回的body是否经过压缩，并返回解压的内容 func contentDecoding(res *http.Response) (bodyReader io.Reader, err error) { switch res.Header.Get(&amp;#34;Content-Encoding&amp;#34;) { case &amp;#34;gzip&amp;#34;: bodyReader, err = gzip.NewReader(res.Body) case &amp;#34;deflate&amp;#34;: bodyReader = flate.NewReader(res.Body) case &amp;#34;br&amp;#34;: bodyReader = brotli.NewReader(res.Body) default: bodyReader = res.Body } return } </description>
    </item>
    
    <item>
      <title>chrome开发者工具显示接口完整路径</title>
      <link>https://www.yuedun.wang/2022/02/chrome-devtool-show-all-path/</link>
      <pubDate>Fri, 18 Feb 2022 16:23:26 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2022/02/chrome-devtool-show-all-path/</guid>
      <description>chrome浏览器的开发者工具是前端开发必不可少的工具，其中接口查看是最常用的功能之一。默认情况下显示如下： 主要是红框内的接口显示只有很短的名称，并没有完整的显示出整个接口，这对于一些最后名称一样的接口就不能知晓是哪个接口了，只能点击查看详情。我们希望的当然是能够显示完整的接口，实际上也是能做到的。
在名称栏上右击：
可以显示很多选项，其中路径和网址就是我们先要的，点击以后就可以显示完整的接口路径了。</description>
    </item>
    
    <item>
      <title>postman header中自动添加cookie</title>
      <link>https://www.yuedun.wang/2021/11/postman-auto-add-cookie/</link>
      <pubDate>Mon, 08 Nov 2021 14:31:17 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/11/postman-auto-add-cookie/</guid>
      <description>使用postman进行接口测试时，经常需要使用到cookie参数。我们会先调用登陆接口，得到sessionid，然后使用sessionID来调用其他需要登陆的接口。 但是有些情况下，cookie不会自动添加到header中，总是需要手动添加cookie。或许又发现有的接口却能自动添加上cookie，为什么会区别对待呢？ 其实这是postman根据登陆接口返回的cookie来操作的，如果cookie的path指定来某个路径，那么所有在这个路径下的接口都会自动加上cookie。</description>
    </item>
    
    <item>
      <title>最近关于公司的一些事</title>
      <link>https://www.yuedun.wang/2021/09/18/</link>
      <pubDate>Sat, 18 Sep 2021 10:58:40 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/09/18/</guid>
      <description>我所在公司掌门教育于6月9日挂牌上市，此时已经处在在线教育政策风波中。也就在一个多月后的7月24传出了更严厉的“双减”政策，几乎是一棍在打死了在线教育。
于是公司也立即做出了反应，7月28开启裁员动作。不同事业部裁员比例不同，优课，少儿应该算是全线砍掉或合并到1对1事业部。我所在的运营部算是裁员最少的，大概是30%的裁员比例。全技术部大概是70%的比例。
也就是从8月开始来来回回搬了四五次位子，随着人员减少，办公大楼一栋一栋的腾出来，最后整个海伦路办公区全部撤离到中瑞。 写该文也是事情过去两三个月了，心中五味杂陈，不想提更多，对于公司倒是没有什么怨言，更多的是难过，这是我工作五年半的地方，还是有感情的，在国家政策下，个人乃至公司都是束手无策。
后来大多数人都找好了新工作，但是还是有不少熟人决定留下来在新部门奉献自己，真心希望公司能够坚持下去，做的更好。</description>
    </item>
    
    <item>
      <title>事件驱动编程、消息驱动编程、数据驱动编程</title>
      <link>https://www.yuedun.wang/2021/07/event-message-data-driven/</link>
      <pubDate>Fri, 23 Jul 2021 14:31:17 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/07/event-message-data-driven/</guid>
      <description>事件驱动 事件驱动机制就是：
让驴拉磨，它不拉，你用鞭抽一下，它就开始拉了。然后又停了，你再抽一下，它又继续拉了
这叫用“鞭”驱动“驴”拉磨
在程序里，程序停止在那不动，你点击一个按钮，它就有反应了，过一会，又没反应了，你再点一下，它又继续运行。
这叫用“事件”驱动“程序”运行
0. 基本概念 窗口/组件 事件 消息(队列) 事件响应(服务处理程序) 调度算法 进程/线程 非阻塞I/O 程序的执行可以看成对CPU,内存,IO资源一次占用 现代操作系统支持多任务,可以分时复用上述资源. 1. 为什么采用事件驱动模型? 事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：
首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）； 当目标发送改变（发布），观察者（订阅者）就可以接收到改变； 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。 2. 代码执行流程 在传统的或“过程化”的应用程序中，应用程序自身控制了执行哪一部分代码和按何种顺序执行代码。从第一行代码执行程序并按应用程序中预定的路径执行，必要时调用过程。 在事件驱动的应用程序中，代码不是按照预定的路径执行－而是在响应不同的事件时执行不同的代码片段。事件可以由用户操作触发、也可以由来自操作系统或其它应用程序调度算法的消息触发、甚至由应用程序本身的消息触发。这些事件的顺序决定了代码执行的顺序，因此应用程序每次运行时所经过的代码的路径都是不同的。
3. 事件驱动模型 在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？
方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：
CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？ 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘； 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；所以，该方式是非常不好的。 方式二：就是事件驱动模型目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：
有一个事件（消息）队列； 鼠标按下时，往这个队列中增加一个点击事件（消息）； 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等； 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；如图: 4. 事件驱动处理库 select poll epoll libev 消息驱动 事件驱动机制跟消息驱动机制相比
消息驱动和事件驱动很类似，都是先有一个事件，然后产生一个相应的消息，再把消息放入消息队列，由需要的项目获取。他们的区别是消息是谁产生的
消息驱动：鼠标管自己点击不需要和系统有过多的交互，消息由系统（第三方）循环检测，来捕获并放入消息队列。消息对于点击事件来说是被动产生的，高内聚。
事件驱动：鼠标点击产生点击事件后要向系统发送消息“我点击了”的消息，消息是主动产生的。再发送到消息队列中。
事件：按下鼠标，按下键盘，按下游戏手柄，将U盘插入USB接口，都将产生事件。比如说按下鼠标左键，将产生鼠标左键被按下的事件。
消息：当鼠标被按下，产生了鼠标按下事件，windows侦测到这一事件的发生，随即发出鼠标被按下的消息到消息队列中，这消息附带了一系列相关的事件信息，比如鼠标哪个键被按了，在哪个窗口被按的，按下点的坐标是多少？如此等等。
要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu. 再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。 事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。 事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。 事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。 目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。 事件模式耦合高，同模块内好用；消息模式耦合低，跨模块好用。事件模式集成其它语言比较繁琐，消息模式集成其他语言比较轻松。事件是侵入式设计，霸占你的主循环；消息是非侵入式设计，将主循环该怎样设计的自由留给用户。如果你在设计一个东西举棋不定，那么你可以参考win32的GetMessage，本身就是一个藕合度极低的接口，又足够自由，接口任何语言都很方便，具体应用场景再在其基础上封装成事件并不是难事，接口耦合较低，即便哪天事件框架调整，修改外层即可，不会伤经动骨。而如果直接实现成事件，那就完全反过来了。
什么是数据驱动编程 最近在学习《Unix编程艺术》。以前粗略的翻过，以为是介绍unix工具的。现在认真的看了下，原来是介绍设计原则的。它的核心就是第一章介绍的unix的哲学以及17个设计原则，而后面的内容就是围绕它来展开的。以前说过，要学习适合自己的资料，而判断是否适合的一个方法就是看你是否能够读得下去。我对这本书有一种相见恨晚的感觉。推荐有4~6年工作经验的朋友可以读一下。
正题：
作者在介绍Unix设计原则时，其中有一条为“表示原则：把知识叠入数据以求逻辑质朴而健壮”。结合之前自己的一些经验，我对这个原则很有共鸣，所以先学习了数据驱动编程相关的内容，这里和大家分享出来和大家一起讨论。
数据驱动编程的核心
数据驱动编程的核心出发点是相对于程序逻辑，人类更擅长于处理数据。数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据。
真的是这样吗？让我们来看一个示例。
假设有一个程序，需要处理其他程序发送的消息，消息类型是字符串，每个消息都需要一个函数进行处理。第一印象，我们可能会这样处理：
void msg_proc(const char *msg_type, const char *msg_buf) { if (0 == strcmp(msg_type, &amp;#34;inivite&amp;#34;)) { inivite_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;tring_100&amp;#34;)) { tring_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;ring_180&amp;#34;)) { ring_180_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;ring_181&amp;#34;)) { ring_181_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;ring_182&amp;#34;)) { ring_182_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;ring_183&amp;#34;)) { ring_183_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;ok_200&amp;#34;)) { ok_200_fun(msg_buf); } else if (0 == strcmp(msg_type, &amp;#34;fail_486&amp;#34;)) { fail_486_fun(msg_buf); } else { log(&amp;#34;未识别的消息类型%s\n&amp;#34;, msg_type); } } 上面的消息类型取自sip协议（不完全相同，sip协议借鉴了http协议），消息类型可能还会增加。看着常常的流程可能有点累，检测一下中间某个消息有没有处理也比较费劲，而且，没增加一个消息，就要增加一个流程分支。</description>
    </item>
    
    <item>
      <title>为什么夜间电费只收半价？</title>
      <link>https://www.yuedun.wang/2021/07/dianjia/</link>
      <pubDate>Sun, 18 Jul 2021 16:23:26 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/07/dianjia/</guid>
      <description>你知道什么是分时电价吗？它是指在一些城市中，一般从夜里10点到早晨6点，电费只需按白天电费的半价支付。这种将电费分时段计算的方式有什么意义呢？
我们知道，人们的用电量同作息时间密切相关，白天工作时段和傍晚的生活时段用电量大，入夜大多数人休息后用电量就降得非常低，往往还不到白天的30%。可是，这个现象对电力公司来说却是个大麻烦，因为发电厂的发电机可不像家里的电器那样能够做到说开就开，说停就停。发电厂的锅炉炉膛有十几层楼房那么高，里面有几百吨的水和蒸汽，温度为300～600℃，庞大的汽轮机也同样处在这个温度下，要它们冷却下来可不容易。同时汽轮机和发电机的转子有几十吨重，转速达到3000转/分。两者巨大的热惯性和动惯性使发电机很难在短短几小时里停下来。停机如此，开机更需耗费时间。因此，对于发电厂来说，要想在晚上关上机器，到了早上又开始运转，这样的操作是行不通的。即便是要在晚上少发一点电，也要付出降低发电效率的巨大代价。因此，增加夜间用电量是电网节能减排的一个有效措施。
发电机涡轮
分时电表
既然发电量在夜间无法大量减少，而白天大家都用电的时候发电量往往又会不够。那么最好的办法就是鼓励用户尽量把白天需用电做的工作挪到晚上来做。人们形象地把白天用电多比喻成山的“峰”，把夜间用电少比喻成山的“谷”，那么把白天的一部分用电移到夜间用，就可以起到“削峰填谷”的节能作用。这么一来，发电机保持在波动不太大的持续工作状态中，它的能源消耗最少，发电效率最高，生产也更安全。采取夜间电费半价的方式，就是以低价电费来鼓励电力用户积极参与“削峰填谷”的用电方式，共同为电力节能减排做出贡献。</description>
    </item>
    
    <item>
      <title>Gorm Model Find First Where等查询函数的区别</title>
      <link>https://www.yuedun.wang/2021/07/gorm-model-find-first/</link>
      <pubDate>Tue, 13 Jul 2021 20:51:21 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/07/gorm-model-find-first/</guid>
      <description>gorm是一款优秀的国产golang orm关系型数据库框架，在国内外使用比较广泛。它的链式调用还算是一种符合人类思维的风格。
不过在使用过程中也遇到一些困扰，比如：Model, Find, First, Where这些函数该什么时候使用，有时候会有边界不清楚，使用混乱的情况。
以下代码示例使用v2版本，v1和v2大体上相同，有些细微的不同
Where和Find search := User{UserName:&amp;#34;月盾&amp;#34;} db.Find(&amp;amp;user, search) // SELECT * FROM `user` WHERE `user`.`user_name` = &amp;#39;月盾&amp;#39; db.Where(search).Find(&amp;amp;user) // SELECT * FROM `user` WHERE `user`.`user_name` = &amp;#39;月盾&amp;#39; 以上两种查询方式结果一样。
Find(dest interface{}, conds ...interface{})Find函数有两个参数，dest是数据接收者，conds是查询条件。所以Find也是可以代替Where来传入条件的。
Where的参数主要分为两类：String，Struct&amp;amp;Map。还有其他不常用类型。
String参数 当使用string参数时，使用方式类似于fmt.Printf，第一个参数为字符串格式，使用?作为占位符，后面的参数作为值。
Struct&amp;amp;Map参数 使用结构体和映射作为参数时，则推荐一个参数即可，struct和map本身就是键值对格式。否则容易引起混淆。比如这样的：
db.Where(&amp;amp;User{Name: &amp;#34;jinzhu&amp;#34;}, &amp;#34;name&amp;#34;, &amp;#34;Age&amp;#34;).Find(&amp;amp;users) // SELECT * FROM users WHERE name = &amp;#34;jinzhu&amp;#34; AND age = 0; db.Where(&amp;amp;User{Name: &amp;#34;jinzhu&amp;#34;}, &amp;#34;Age&amp;#34;).Find(&amp;amp;users) // SELECT * FROM users WHERE age = 0; 注意 当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 0、&amp;rsquo;&amp;rsquo;、false 或其他 零值，该字段不会被用于构建查询条件，例如：</description>
    </item>
    
    <item>
      <title>Chrome插件hook Ajax</title>
      <link>https://www.yuedun.wang/2021/07/chrome-extensions-hook-ajax/</link>
      <pubDate>Sat, 10 Jul 2021 20:15:08 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/07/chrome-extensions-hook-ajax/</guid>
      <description>如何Hook Ajax请求 现在很多网站都使用Ajax作为数据接口，这样其实也方便爬虫爬取数据，但是，如果站点对IP，访问频率做 了限制，或者网站定位就是搜索类，无法遍历完所有页面，或者是数据实时变化，无法预期的。这样就可能需要 直接在浏览器中模拟人的行为，对于这样的网站(使用Ajax作数据接口，有一定防范措施) ，如果我们可以通过hook得到Ajax请求，就可以搞定它的数据了。
单页面Web应用 对于单页面的Web应用，在console中使用如下代码，就能在浏览器进行Ajax请求时候，得到返回内容， 然后在post给存储接口就好了:
(function() { var origOpen = XMLHttpRequest.prototype.open; XMLHttpRequest.prototype.open = function() { // console.log(&amp;#39;request started!&amp;#39;); this.addEventListener(&amp;#39;load&amp;#39;, function() { console.log(this.responseText); // 得到Ajax的返回内容 }); origOpen.apply(this, arguments); }; })(); 比如百度图片:
我们可以看到请求图片的路径，这段代码 直接使用了一个匿名函数，重写了Ajax请求的open方法，给load事件加上一个事件监听器，从而把内容得到:
对于单页面的Web应用，基本可以满足需求，但是如果翻页的话，每次翻页上一页的代码就失效了， 不可能每页都把这段代码复制进console中，还是需要使用类似Chrome插件的方式才能实现。
翻页Web应用 有了上面的代码，如果我们把它直接丢到Chrome插件的JS文件里面(官方叫Content Scripts)，发现是无法执行的，XMLHttpRequest.prototype.open 还是浏览器自身的代码。
这样看来，就无法实现自动翻页，自动获取ajax请求内容了。
Chrome官方说法如下:
Content scripts execute in a special environment called an isolated world. They have access to the DOM of the page they are injected into, but not to any JavaScript variables or functions created by the page.</description>
    </item>
    
    <item>
      <title>七牛在线管理图片预览chrome插件</title>
      <link>https://www.yuedun.wang/2021/07/qiuniu-image-preivew/</link>
      <pubDate>Tue, 06 Jul 2021 19:32:15 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/07/qiuniu-image-preivew/</guid>
      <description>七牛云图片存储有10G的免费额度，对于个人来说足够使用了。使用七牛图片存储涉及到图片上传，查看，管理的问题。为了能提高使用效率，我们可以利用好一些工具。
vscode插件上传图片到七牛 vsocode扩展市场有很多上传到七牛的插件，大家可以根据需要自己选择。
上传的图片多了以后，有时需要找一些已经上传的图片来使用，目前我所知道的方法还仅限于登录的七牛后台上查看。
可以看到，七牛的管理后台做的不能说很差，可以说是很气人。要预览图片必须点击“详情”，当你关掉预览窗口时却不知道查看的是哪张图片，也没有个高亮聚焦。而且也没有时间排序，只有名称排序，真的是很难用。
为了能够直观的看到图片，决定开发一款chrome插件，将图片直接显示出来，而不用再点击查看。
关于chrome插件开发的细节本文暂不细说，直接上代码。
代码展示 manifest.json
{ &amp;#34;manifest_version&amp;#34;: 2, &amp;#34;name&amp;#34;: &amp;#34;chome-plugin&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.0.1&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;chrome示例插件&amp;#34;, &amp;#34;icons&amp;#34;: { &amp;#34;16&amp;#34;: &amp;#34;images/icon-16x16.png&amp;#34;, &amp;#34;48&amp;#34;: &amp;#34;images/icon-48x48.png&amp;#34;, &amp;#34;128&amp;#34;: &amp;#34;images/icon-128x128.png&amp;#34; }, &amp;#34;page_action&amp;#34;: { &amp;#34;default_icon&amp;#34;: { &amp;#34;48&amp;#34;: &amp;#34;images/icon-48x48.png&amp;#34; }, &amp;#34;default_popup&amp;#34;: &amp;#34;html/popup.html&amp;#34;, &amp;#34;default_title&amp;#34;: &amp;#34;Hello yuedun&amp;#34; }, &amp;#34;author&amp;#34;: &amp;#34;yuedun&amp;#34;, &amp;#34;background&amp;#34;: { &amp;#34;scripts&amp;#34;: [ &amp;#34;scripts/jquery.min.js&amp;#34;, &amp;#34;scripts/background.js&amp;#34; ] }, &amp;#34;devtools_page&amp;#34;: &amp;#34;html/devtools-page.html&amp;#34;, &amp;#34;content_scripts&amp;#34;: [ { &amp;#34;js&amp;#34;: [ &amp;#34;scripts/jquery.min.js&amp;#34;, &amp;#34;scripts/content.js&amp;#34; ], &amp;#34;css&amp;#34;: [ &amp;#34;styles/yuedun-insert.css&amp;#34; ], &amp;#34;matches&amp;#34;: [ &amp;#34;https://portal.qiniu.com/kodo/bucket/resource?bucketName=*&amp;#34; ], &amp;#34;run_at&amp;#34;: &amp;#34;document_start&amp;#34; } ], &amp;#34;permissions&amp;#34;: [ &amp;#34;cookies&amp;#34;, &amp;#34;*://*/*&amp;#34;, &amp;#34;webRequest&amp;#34; ], &amp;#34;homepage_url&amp;#34;: &amp;#34;https://www.</description>
    </item>
    
    <item>
      <title>gitpage Hugo统计每一篇文章浏览量</title>
      <link>https://www.yuedun.wang/2021/06/gitpage-hugo-page-view/</link>
      <pubDate>Fri, 18 Jun 2021 20:03:41 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/06/gitpage-hugo-page-view/</guid>
      <description>接上篇《博客迁移至hugo gitpage》后，因为缺失了每一篇文章的浏览量，而hugo又不具备这样的功能，原因还是gitpage不具备数据存储能力，自然就没办法统计每一篇文章的浏览量了。原本想使用自己服务器提供一个接口来记录，但发现https协议不支持调用http协议的接口，会出现block:mixed-content错误。
错误：https页面去发送http请求报错(浏览器阻止https发送http请求)
问题是明确了，但是我也没办法提供https的接口，免费的证书也用在了www.yuedun.wang上了。
后来想到了leancloud，直接在前端调用api，将数据存储在云端。
&amp;lt;script src=&amp;#34;//cdn.jsdelivr.net/npm/leancloud-storage@4.11.1/dist/av-min.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; // https://leancloud.cn/docs/sdk_setup-js.html#hash14962003 // https://leancloud.cn/docs/leanstorage_guide-js.html#hash813593086 const appId = &amp;#34;xxx&amp;#34;; const appKey = &amp;#34;xxx&amp;#34;; const serverURL = &amp;#34;xxx&amp;#34;; AV.init({ appId, appKey, serverURL }); function updateCollect() { const collect = new AV.Query(&amp;#39;Collect&amp;#39;); const url = location.pathname; collect.select([&amp;#39;url&amp;#39;, &amp;#39;pv&amp;#39;]) collect.equalTo(&amp;#39;url&amp;#39;, url); collect.first().then((col) =&amp;gt; { if (!col) { // 声明 class const Collect = AV.Object.extend(&amp;#39;Collect&amp;#39;); // 构建对象 const collect = new Collect(); // 为属性赋值 collect.set(&amp;#39;url&amp;#39;, url); collect.set(&amp;#39;pv&amp;#39;, 1); collect.</description>
    </item>
    
    <item>
      <title>博客迁移至hugo gitpage</title>
      <link>https://www.yuedun.wang/2021/06/blog-move-to-gitpage/</link>
      <pubDate>Thu, 17 Jun 2021 19:38:31 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2021/06/blog-move-to-gitpage/</guid>
      <description>为什么迁移？ 6月初的时候，3年前买的阿里云服务器到期了，又买了其他服务器，但是只有1年期，于是进行了一番数据，应用迁移，这么一顿操作下来还是挺累的，尤其是在linux上安装mysql，mongodb，安装后又是连接不上，用了好几天时间才搞定，挺烦的。
再想到一年后又是一顿操作，不由得一个激灵。
经过一番的思量后，决定将自建博客迁移至gitpage上。
自建和gitpage优劣对比 首先列出自己博客具备的功能：
首页 包含最近10篇文章的标题和部分内容，最近发表的5篇，分类，标签，友链 目录 所有文章时间线 留言 自维护留言系统 微博 新浪微博，最近出问题不显示了 速记 简单记录 关于 自我介绍 整体比较简单，没什么复杂功能。而很多静态博客也具备这些功能，而且做的更好，所以基本不会有主要功能的缺失。所以迁移到gitpage上也不会有什么问题。
劣势 静态博客在一些细节功能上面确实会有缺失，比如：
评论功能，数据原来是存在自己服务器上的，gitpage不具备数据存储能力，所以需要对接第三方评论或留言功能。 目录缺失，这点主要由博客主题决定，有些主题是没有目录功能的。 PV/UV统计，同样是由于数据存储的缺失，所以gitpage也没有这样的统计功能，但是可以添加谷歌，百度统计之类的。 自定义功能较弱，只能使用主题提供的页面模式，除非不使用静态博客工具，完全自己开发。 不能在线编辑。 优势 免费，没有服务器费用。 可以自定义域名，只需要一丁点儿的域名费用。 seo良好。 规范的书写格式，使文章内容更统一美观。 更强大的编辑器，可以选择自己喜欢的markdown编辑器。 便于本地检索。 数据更保险，不易丢失。 安全，静态博客可以避免一些网络攻击。 整体来说，除了数据存储功能缺失外，其他都是可以实现的。
迁移过程 将mongodb数据中的博客导出为本地markdown文件。
// mongodb数据转markdown function genMd() { return Blog.find({ status: 1 }, null, { sort: { &amp;#39;_id&amp;#39;: -1 } }) .then(data =&amp;gt; { data.forEach((b) =&amp;gt; { debug(b) let tags = b.tags.split(&amp;#34;,&amp;#34;) let blog = `--- title: &amp;#34;${b.</description>
    </item>
    
    <item>
      <title>vscode正则查找替换</title>
      <link>https://www.yuedun.wang/blogdetail/5e5a3fb45bd8165f28d21307/</link>
      <pubDate>Mon, 14 Jun 2021 10:40:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e5a3fb45bd8165f28d21307/</guid>
      <description>查找某一类型字符串： 正则表达式onclick=.*&amp;quot; 会查找到所有： onclick=&amp;quot;_msq.push([&#39;trackEvent&#39;, &#39;210074305d6b0409-09c7759e04e98528&#39;, &#39;&#39;pcpid&#39;, &#39;&#39;]);&amp;quot;
onclick=是固定一样的字符，
.代表除\r和\n之外的任意字符，等价于[^\r\n]
*代表匹配前面的模式 0或多次 {0,}
&amp;quot;这是字符串最后一个字符
在vscode中的效果如下： 至于要替换成什么就看自己需求了，如果要给选中的字符串包裹字符串则需要修改成这样：
查找替换 查找：(onclick=.*&amp;quot;)
替换：aaa($1)
结果：
替换字符串两头，保留中间 两部分文字交换位置 相同模式的文字交换位置。
查找：(\(\d{4}-\d{1,2}-\d{2}\)) (\[.*\))
替换：$2 $1
结果：
vscode中一对括号()代表一个变量。
第一组正则 (\(\d{4}-\d{1,2}-\d{2}\)) 对应 $1，
第二组正则 (\[.*\))对应 $2，以此类推。
所以，可以查找多组数据，在替换部分将两个对应变量交换位置即可。</description>
    </item>
    
    <item>
      <title>typescript不检查node_moduls</title>
      <link>https://www.yuedun.wang/blogdetail/60b48e405caa4b4dc69e3abf/</link>
      <pubDate>Fri, 11 Jun 2021 14:16:17 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60b48e405caa4b4dc69e3abf/</guid>
      <description>tsconfig.json 中 exclude node_modules，但 tsc 还是报错。
node_modules/connect-mongo/src/types.d.ts:113:66 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 113 get: (sid: string, callback: (err: any, session: Express.SessionData | null) =&amp;gt; void) =&amp;gt; void; ~~~~~~~~~~~ node_modules/connect-mongo/src/types.d.ts:114:45 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 114 set: (sid: string, session: Express.SessionData, callback?: (err: any) =&amp;gt; void) =&amp;gt; void; ~~~~~~~~~~~ node_modules/connect-mongo/src/types.d.ts:118:47 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 118 touch: (sid: string, session: Express.</description>
    </item>
    
    <item>
      <title>朱雀发布系统支持scp（rsync）发布</title>
      <link>https://www.yuedun.wang/blogdetail/60950c9ee76f307341586548/</link>
      <pubDate>Fri, 11 Jun 2021 14:16:17 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60950c9ee76f307341586548/</guid>
      <description>去年花了三天时间开发了一个简易版的nodejs发布系统，它是基于pm2自带的deploy机制开发的，主要原理就是在两台装有pm2的机器直接通信，并执行相应的命令。再往简单了说就是在发布机上远程执行命令，而朱雀发布系统提供了一个图形界面而已。
当时把这个系统定位为nodejs专用发布系统，因为它依赖了pm2，而pm2则是nodejs专用的进程管理工具，其他语言用不到。这个系统的上线也算是解决了我司一直以来没有合适的nodejs发布系统的空缺。
经过9个月的使用，也算比较稳定。但是也存在问题，最大的问题是部署应用方面比较繁琐。
基本流程如下：
发布机和应用服务器设置ssh通信配置。 应用服务器安装git（有自带，但是版本太旧）。 配置git用户名，邮箱。 生成ssh公钥。 把应用服务器的公钥配置到git代码服务器上。以便能拉代码。 发布机远程执行git pull来代码操作，各应用服务把代码拉取下来。 执行编译打包操作。 执行重启服务操作。 部署一次系统还是比较麻烦的，如果应用服务器有多台，可能还要重复这样的操作多次，实在比较麻烦。
使用scp同步代码的方式会比较简单一些，但是像nodejs这样的项目，node_module占了很大比重，如果每次都打包的话会拖慢同步速度，而scp又不具备排除文件夹的能力。
最后找到了rsync命令可以满足需求。然后就是基于rsync实现了一版。不用再依赖pm2，应用服务器也不用强制使用git了。
朱雀和Jenkins对比如何？ 要说Jenkins那绝对是持续集成领域的老大哥，自然是功能强大。但是每个团队和产品有其特殊性，Jenkins并不完全适用。而朱雀也有其优势。
朱雀本身部署简单，使用go开发，不依赖运行时，无需安装，开箱即用。 目前支持和测试过的数据库有sqlite3（目前用的，不需要繁琐的安装过程）和mysql。 配置简单。 部署发布一键完成，不需要单独的部署过程。 并行发布。 审批，通知，权限。 开源，可定制开发。 项目地址：朱雀发布系统</description>
    </item>
    
    <item>
      <title>一体LED可伸缩变焦手电筒拆解</title>
      <link>https://www.yuedun.wang/blogdetail/608eb0b254277a10496a5f56/</link>
      <pubDate>Sun, 02 May 2021 14:01:22 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/608eb0b254277a10496a5f56/</guid>
      <description>先看看一体LED可伸缩变焦手电筒长什么样子
这种手电筒刚买回来几个月就不亮了，以为没电了，充电了也不行，想拆开看看却发现无从下手，手电筒是一体的，并没有地方可扭开。
按钮部位看起来是可拆解的，想要转动一下，发现无法转动，最后抱着死马当活马医的心态，大不了拆坏了，随便用工具撬了下尾部凹槽部分，发现有活动迹象，然后就继续撬，果然是大力出奇迹。最后就是下面图展示的样子，有明显损坏痕迹，不过也没办法，实在不好拆。拆开后发现电池线断了，将就着接上后就好了。
最后，虽然不建议买这种手电筒，但是既然您看到本文了，那也就有救了。 祝大家五一快乐！</description>
    </item>
    
    <item>
      <title>easy-monitor qps监控</title>
      <link>https://www.yuedun.wang/blogdetail/60861bef54277a10496a54b6/</link>
      <pubDate>Mon, 26 Apr 2021 01:48:31 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60861bef54277a10496a54b6/</guid>
      <description>Easy-Monitor是一款轻量级的Node性能监控工具，仅仅需要项目入口 require 一次，就可以非常便捷地展示出进程的状态细节。
Easy-Monitor主要提供以下的功能：
找出执行时长耗费最久的5个或者更多的函数 找出那些执行时间超出预期的函数 找出v8引擎无法优化的函数 Easy-Monitor的特点：
轻量级：非传统C/S物理分离模式，require 后即可使用，没有额外的监控server/agent部署成本。 运行时：针对的是运行时的函数性能以及内存细节进行处理展示，可用于线上生产环境项目。 无状态：永远展示的是开发者访问时的业务进程状态 关于监控qps，作者在文档中并没有提到qps这样的关键字，很多人也不知道怎么监控qps。 不过在监控界面中有这样的指标数据： 所以我从源码入手，找到了该数据指标的源头是这样的：
const data = { osCpu: Number((used_cpu * 100).toFixed(2)), osMem: Number((used_memory_percent * 100).toFixed(2)), maxDisk: max_disk_usage, disks: disks_json, load1: Number(load1.toFixed(2)), load5: Number(load5.toFixed(2)), load15: Number(load15.toFixed(2)), nodeCount: node_count, scavengeTotal: total_scavange_duration, scavengeAverage: scavange_duration_last_record, marksweepTotal: total_marksweep_duration, marksweepAverage: marksweep_duration_last_record, qps: Number((http_response_sent / 60).toFixed(2)), rtExpired: http_patch_timeout, rtAverage: http_rt, }; 这是接口返回的数据，包含了qps数据，那么qps实际上就是http_response_sent，所以监控中就可以这样设置qps了： @http_response_sent/60 &amp;gt; 10</description>
    </item>
    
    <item>
      <title>使用sveltekit开发一个服务端渲染（SSR）项目</title>
      <link>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</link>
      <pubDate>Wed, 07 Apr 2021 06:29:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</guid>
      <description>上篇简单介绍了sapper和sveltekit的发展，目前sveltekit还只是Beta版本，有很多不确定因素存在，有可能会有大的变更，所以还不推荐在生产环境中使用，不过在个人项目和小项目中可以大胆尝试。
今天我们就正式使用sveltekit开发一个web项目。
第一步：创建项目 mkdir my-app cd my-app npm init svelte@next npm install npm run dev 这样就可以创建一个简单的项目了，不过和我们真实需求还有些差距，既然是使用sveltekit，那么最重要的原因是其支持服务端渲染了。这就需要从服务端获取数据，接下来就实现这样的需求。
第二步：路由 和sapper一样，sveltekit也是基于文件系统的的路由器，这就需要我们来合理的组织目录结构。路由的核心目录是src/routes，当然，这个也是可配置的，按照自己的需求修改svelte.config.cjs，参考文档：https://kit.svelte.dev/docs#configuration。
我们以一个博客系统为例，在scr/routes下创建blog目录，光有目录还不行，如果想要访问 /blog 路由，还需要创建index.svelte文件，内容如下：
&amp;lt;script context=&amp;#34;module&amp;#34;&amp;gt; /** * @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Load} */ export async function load({ page, fetch, session, context }) { return fetch(`blog.json`)// index.json.js = blog.json或blog/blog.json .then((r) =&amp;gt; r.json()) .then((posts) =&amp;gt; { console.log(posts); return { props: { posts } }; }); } &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; export let posts; &amp;lt;/script&amp;gt; &amp;lt;svelte:head&amp;gt; &amp;lt;title&amp;gt;Blog&amp;lt;/title&amp;gt; &amp;lt;/svelte:head&amp;gt; &amp;lt;h1&amp;gt;Recent posts&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; {#each posts as post} &amp;lt;!</description>
    </item>
    
    <item>
      <title>关于svelte框架——sapper和sveltekit的发展</title>
      <link>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</link>
      <pubDate>Tue, 30 Mar 2021 02:33:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</guid>
      <description>虽然您可能现在还没有听说过svelte，但是其实svelte的发展速度超过了你的想象。
本文主要讲的是关于sapper和sveltekit这两款框架的发展。
svelte作者里奇·哈里斯（Rich Harris）在2020年10月的svelte峰会上表示：sapper永远不会发布1.0版本。
也就是说sapper不会发布正式版，一直处于非稳定版本。也可能放弃更新。
主要原因是sapper多年来代码库变得凌乱，但更主要的原因是最近网络发生了很大变化。
而作者放弃sapper后的另一种选择是开发SvelteKit。
Sapper和SvelteKit都是svelte的开发框架，类似于vue的nuxt框架。
sveltekit包含的功能有：
服务端渲染（SSR）
路由
typescript支持
less, scss支持
serverless
vite打包
可以看到，sveltekit几乎包含了所有我们想要的功能，既能高效开发，又有高性能。
创建sveltekit的方法： mkdir my-app cd my-app npm init svelte@next npm install npm run dev 需要注意，您的nodejs版本需要更新到v12以上，否则可能出现以下错误：
$ npm run dev -- --open &amp;gt; sveltekit-app@0.0.1 dev D:\workspace\sveltekit-app &amp;gt; svelte-kit dev &amp;#34;--open&amp;#34; D:\workspace\sveltekit-app\node_modules\@sveltejs\kit\svelte-kit.js:2 import &amp;#39;./dist/cli.js&amp;#39;; SyntaxError: Unexpected string at Module._compile (internal/modules/cjs/loader.js:723:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Function.Module.runMain (internal/modules/cjs/loader.js:831:12) at startup (internal/bootstrap/node.</description>
    </item>
    
    <item>
      <title>/bin/rm: argument list too long</title>
      <link>https://www.yuedun.wang/blogdetail/60459dcf8e743369d9dd5a8f/</link>
      <pubDate>Mon, 08 Mar 2021 03:45:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60459dcf8e743369d9dd5a8f/</guid>
      <description>有人在服务器上不小心执行了rm -fr /*，而我想在删除某个文件夹下面的文件却遇到/bin/rm: argument list too long。
意思是我删除的文件太多了，这倒有点稀奇。
那怎么才能删除呢？
试着直接删除目录也不行，这问题能难倒我，但难不倒百度。
使用ls | xargs -n 1000 rm -fr ls删除，可是一直在输出错误提示：
rm: invalid option -- &amp;#39;s&amp;#39; Try &amp;#39;rm --help&amp;#39; for more information. 出现这个情况的原因是文件名是这种类型：-abc.txt。就是前面带了-。
删除方式是：
rm -- -foo 或 rm ./-foo 只看见报错，到底有没有在删文件？想要知道，那么把删除命令改成这样
ls | xargs -n 1000 rm -frv ls
rm命令加个参数v，用来显示删除信息。
最终会输出这样的提示信息，
removed ‘zMJ1MgKdzgbjNsWawUcX7OO3WspyxZEU.json’
为了让它在后台执行可以这样：
ls | xargs -n 1000 rm -frv ls &amp;amp;</description>
    </item>
    
    <item>
      <title>firefox火狐新标签中打开书签</title>
      <link>https://www.yuedun.wang/blogdetail/60191322ebffed4856026fc7/</link>
      <pubDate>Tue, 02 Feb 2021 08:53:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60191322ebffed4856026fc7/</guid>
      <description>火狐浏览器新建标签总是在当前打开标签之后，而不是在最后一个标签后新建。 1.about:config 2.browser.tabs.insertAfterCurrent设为false。
新标签中打开书签 browser.tabs.loadBookmarksInTabs设置true。
新标签中打开搜索 browser.search.openintab设置true.</description>
    </item>
    
    <item>
      <title>nestjs中使用携程Apollo配置中心</title>
      <link>https://www.yuedun.wang/blogdetail/5ffffe3d3f518207e7235250/</link>
      <pubDate>Thu, 14 Jan 2021 08:18:05 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ffffe3d3f518207e7235250/</guid>
      <description>nest框架官方文档中使用的是本地文件配置，也就是@nestjs/config包。本地配置文件的好处是使用简单，但是对于一些更新较快的项目，难免会增加配置数据，曾经吃过不少配置文件的亏，在发布的时候很容易因为缺少配置文件直接把服务发挂了，或者需要在服务器上修改配置很容易修改错误导致服务发布失败。
集中的配置中心可以解决上面问题，本文以apollo配置中心为例来说明。 在使用的过程中需要注意以下问题：从配置中心获取数据库连接信息，再去连接会连接失败，因为在连接的时候还没有获取到配置信息。 先看代码再解释。
// main.ts import { NestFactory } from &amp;#39;@nestjs/core&amp;#39;; import { ExpressAdapter, NestExpressApplication } from &amp;#39;@nestjs/platform-express&amp;#39;; import { AppModule } from &amp;#39;./app.module&amp;#39;; import { MyLogger } from &amp;#39;./libs/mylog.service&amp;#39;; import { join } from &amp;#39;path&amp;#39;; const Apollo = require(&amp;#39;node-apollo&amp;#39;); const dotenv = require(&amp;#39;dotenv&amp;#39;); async function bootstrap() { try { const root = join(__dirname, &amp;#39;../&amp;#39;); let envFile = join(root, &amp;#39;.env&amp;#39;) dotenv.config({ &amp;#34;path&amp;#34;: envFile }) const { APOLLO_APPID, APOLLO_ENV, APOLLO_HOST, APOLLO_NAMESPACE, APOLLO_PORT, APOLLO_TOKEN, APOLLO_ClUSTER } = process.</description>
    </item>
    
    <item>
      <title>svelte history路由刷新后404</title>
      <link>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</link>
      <pubDate>Fri, 08 Jan 2021 03:55:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</guid>
      <description>npms.io上搜索到svelte的route包其实也不算少，使用比较广泛的svelte-spa-router路由包却不支持history模式。有些支持history模式的使用上也不是很方便，试用过五六个支持history的路由后最终@spaceavocado/svelte-router算是满足了要求。
使用简单 功能丰富 支持history和hash 我也是够难伺候的。 在试用了多个支持history的路由过程中，都遇到了一个问题：切换路由后刷新404。这也算是单页应用的通病了。不过像vue这种是在部署到服务器上刷新404，而svelte却在开发过程中也出现了，又想放弃了&amp;hellip; 好在我也是试用过五六七八个路由的人了，中间不知道尝试过多少种方法来实现history路由。最后使用@spaceavocado/svelte-router包实现了history路由的时候我还是满心欢喜。
使用方法：
//App.svelte &amp;lt;script&amp;gt; import RouterView from &amp;#39;@spaceavocado/svelte-router/component/view&amp;#39;; import { routes } from &amp;#39;./router.js&amp;#39; &amp;lt;/script&amp;gt; &amp;lt;RouterView /&amp;gt; //router.js import createRouter from &amp;#39;@spaceavocado/svelte-router&amp;#39;; import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;; export const routes = createRouter({ mode: &amp;#34;HISTORY&amp;#34;, routes: [ { path: &amp;#39;/&amp;#39;, name: &amp;#39;HOME&amp;#39;, component: index, }, { path: &amp;#39;/a&amp;#39;, name: &amp;#39;a&amp;#39;, component: a, }, { path: &amp;#39;/b&amp;#39;, name: &amp;#39;b&amp;#39;, component: b, }, { path: &amp;#39;*&amp;#39;, component: index, }, ], }); // index.</description>
    </item>
    
    <item>
      <title>基于sapper开发svelte项目配置本地代理</title>
      <link>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</link>
      <pubDate>Tue, 05 Jan 2021 11:09:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</guid>
      <description>sapper可能被放弃更新，如果您要继续使用svelte，可以考虑使用sveltekit
最近使用svelte开发一个项目，说实在的，开发过程中遇到不少问题。 每次遇到问题的时候都有种想放弃的冲动，这生态也太差了，查个啥啥问题都查不到，找个啥啥插件也没有。 不过，到最后，遇到的问题又都解决了。 这不，今天又遇到了本地代理的设置问题。 在说遇到的问题之前先介绍一些项目架构。该项目是基于sapper框架开发，这是一个使用svelte开发的框架，具备以下特点：
服务端渲染 路由 代码分割 默认支持渐进式web应用（PWA） 预取路由 单独的头标签（meta，link等） 作为静态站点弹出 Cypress测试（免费，简单，端到端的测试） 可以看到，sapper基本是集合了目前前端开发所有需求，双向数据绑定，渐进式开发，SSR，静态化，高性能。
遇到的新问题：对于前端项目，调用接口时容易遇到跨域问题，一般是使用本地代理解决。自然也想这样来做，可是sapper没有vue项目那样的生态，用的打包工具也不是webpack，而是rollup。 那么就使用sapper自带的服务端来做代理好了。sapper的服务端用的是polka，而不是express，不过没关系，其实可以相互替换。 最关键的是增加了http-proxy-middleware中间件，却对中间件位置很敏感，不是想随便在哪添加一下就行。需要添加在第一个中间件位置，否则就会优先使用静态服务中间件，导致接口找不到。 完整代码：
import sirv from &amp;#39;sirv&amp;#39;; import polka from &amp;#39;polka&amp;#39;; import compression from &amp;#39;compression&amp;#39;; import * as sapper from &amp;#39;@sapper/server&amp;#39;; import { createProxyMiddleware } from &amp;#39;http-proxy-middleware&amp;#39;; const { PORT, NODE_ENV } = process.env; const dev = NODE_ENV === &amp;#39;development&amp;#39;; polka() // 需要放在最前面，否则接口404，secure参数解决调用https问题 .use(&amp;#39;/api&amp;#39;, createProxyMiddleware({ target: &amp;#39;https://example.com&amp;#39;, pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39; }, secure: false, changeOrigin: true, })) .</description>
    </item>
    
    <item>
      <title>svelte项目rollup配置px2rem</title>
      <link>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</link>
      <pubDate>Tue, 05 Jan 2021 03:20:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</guid>
      <description>使用svelte开发项目时遇到需要将px转换成rem的需求，有试过postcss-px2rem，postcss-pxtorem，等postcss插件，都没成成功，最后找到了postcss-units插件成功实现。 完整rollup配置文件如下： converts px to rem 该配置是sapper项目配置
import path from &amp;#39;path&amp;#39;; import resolve from &amp;#39;@rollup/plugin-node-resolve&amp;#39;; import replace from &amp;#39;@rollup/plugin-replace&amp;#39;; import commonjs from &amp;#39;@rollup/plugin-commonjs&amp;#39;; import url from &amp;#39;@rollup/plugin-url&amp;#39;; import svelte from &amp;#39;rollup-plugin-svelte&amp;#39;; import babel from &amp;#39;@rollup/plugin-babel&amp;#39;; import { terser } from &amp;#39;rollup-plugin-terser&amp;#39;; import config from &amp;#39;sapper/config/rollup.js&amp;#39;; import pkg from &amp;#39;./package.json&amp;#39;; import sveltePreprocess from &amp;#39;svelte-preprocess&amp;#39;; // import { less } from &amp;#39;svelte-preprocess&amp;#39;; const postcssUnits = require(&amp;#39;postcss-units&amp;#39;); const mode = process.env.NODE_ENV; const dev = mode === &amp;#39;development&amp;#39;; const legacy = !</description>
    </item>
    
    <item>
      <title>svelte函数传参</title>
      <link>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</link>
      <pubDate>Tue, 29 Dec 2020 02:20:33 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</guid>
      <description>svelte给dom对象绑定事件和vue框架类似。 定义函数：
function handler(index){ alert(&amp;#34;hello&amp;#34;, index); } 绑定事件：
&amp;lt;button on:click={handler}&amp;gt;点击&amp;lt;/button&amp;gt;
但是带参函数的使用就略有不同了，函数handler的参数index需要传入的时候，不能直接这样使用&amp;lt;button on:click={handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt;,这样的写法会在页面打开时直接执行，而不是在点击按钮的时候执行。
这是初学svelte的时候比较郁闷的事，官方文档中也没有明显的文档说明如何传参。 正确的传参方式是这样的： &amp;lt;button on:click={() =&amp;gt; handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt; 将on:click的内容改写为匿名函数，在函数中调用。</description>
    </item>
    
    <item>
      <title>go单元测试初始化</title>
      <link>https://www.yuedun.wang/blogdetail/5fc7321dc0ec0c27f57ace6e/</link>
      <pubDate>Wed, 02 Dec 2020 06:20:13 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fc7321dc0ec0c27f57ace6e/</guid>
      <description>go单元测试会遇到这样的场景： 写好了service层函数getUser()。然后测试测试getUser函数。有个问题是，函数中使用了数据库连接，如果直接测试的话会报错误，比如空指针错误。
panic: runtime error: invalid memory address or nil pointer dereference [recovered] panic: runtime error: invalid memory address or nil pointer dereference [signal 0xc0000005 code=0x0 addr=0xb0 pc=0x167680d]
如果遇到这种情况很有可能就是数据库连接未初始化。但是单元测试并不会主动去初始化数据库连接。不用担心，有办法。 go test提供了用于初始化的方法：TestMain函数。只需要在这个函数中进行数据库初始化，后面需要用的的数据库连接可直接使用，不需要重复初始化。
func TestMain(m *testing.M) { fmt.Println(&amp;#34;begin&amp;#34;) dba, err := gorm.Open(&amp;#34;sqlite3&amp;#34;, &amp;#34;../../website.db&amp;#34;) db.SQLLite = dba if err != nil { panic(err) } m.Run() fmt.Println(&amp;#34;end&amp;#34;) } func TestProjectUsers(t *testing.T) { userService := user.NewService(db.SQLLite) users, err := userService.GetProjectUsers(25) if err != nil { t.</description>
    </item>
    
    <item>
      <title>Svelte3路由</title>
      <link>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</link>
      <pubDate>Sat, 28 Nov 2020 07:16:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</guid>
      <description>svelte目前没有提供官网路由组件，不过可以在社区中找到。本文介绍的是svelte-spa-router的使用方法。
npm i svelte-spa-router 参考以下目录结构创建文件（不是必须）
router.js:
import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;; export const routes = { &amp;#39;/&amp;#39;: index, &amp;#39;/a&amp;#39;: a, &amp;#39;/b&amp;#39;: b } 动态导入组件和代码分割：
import { wrap } from &amp;#39;svelte-spa-router/wrap&amp;#39; import index from &amp;#39;./index/index.svelte&amp;#39;; export const routes = { &amp;#39;/&amp;#39;: index, &amp;#39;/a&amp;#39;: wrap({ asyncComponent: () =&amp;gt; import(&amp;#39;./a/a.svelte&amp;#39;) }), // &amp;#39;/b&amp;#39;: b // 动态加载 &amp;#39;/b&amp;#39;: wrap({ asyncComponent: () =&amp;gt; import(&amp;#39;./b/b.svelte&amp;#39;) }), } 动态导入组件的优点是组件不会一起打包，而是单独的组件文件，在打开对应的页面时才会请求，可以有效减少包文件大小。 App.svelte:</description>
    </item>
    
    <item>
      <title>vscode远程开发应用场景</title>
      <link>https://www.yuedun.wang/blogdetail/5fb757025edb9b37630b808b/</link>
      <pubDate>Fri, 20 Nov 2020 05:41:22 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fb757025edb9b37630b808b/</guid>
      <description>vscode远程开发 vscode远程开发功能在2019年5月份发布，到现在已经有一年半的时间了，但是周围的人很少提及此功能，并不是没有人使用vscode，而是对此没有强烈需求。
那么远程开发还有什么用呢？下面我来举些列子。
关于vscode远程环境搭建本文不重复说明，网上有大量教程，大家只需要安装remote development插件基本都可以使用起来。
远程开发，顾名思义就是连接远端服务器进行开发，这样的场景确实不是很常见，但是有时候却是很有用，能够解决燃眉之急。
本地主机性能差 有一些大型项目对电脑的要求也较高，编译耗时，跑起来吃内存，我们的常规解决方案是升级电脑内存，升级硬盘，总之就是换高配电脑，如果是换一台也倒罢了，如果是一个团队都要使用更高配的电脑，那这样的成本还是挺高的。
此时利用远程开发功能，所有人共用一台8核16G服务器就足够了。能够解决编译耗时，吃内存等问题。
开发环境统一 现代大多数应用服务是跑在Linux上的，而开发环境则有Windows，Mac，有些服务在开发环境下无法顺利跑起来，这种情况就可以利用远程开发，不再需要虚拟机或WSL了，在Linux上部署应用，在Windows上开发。
远程调试 远程调试我想很多人都有过这样的需求，但是却从来没有过真正的实践，原因是太难搞了。线上出问题，本地无法复现，真希望能够直接调试线上代码，但是无奈无法实现。现在好了，有了vscode远程开发，调试就变得容易了。
远程编辑文件 在Linux上编辑文件时使用的vim编辑器对大多数人来说有些头大，能在vscode中编辑文本就舒服多了。只需要使用vscode连接远程服务可以很方便打开文件并编辑。
在家临时远程开发 作为开发的我们，每天下班都要背着电脑回家，主要原因就是防止线上有问题，能够打开电脑调试代码。一般来说并不是家里没有电脑，而是没有能够正常运行的开发环境。
而远程开发正好能解决该问题，我们需要的仅仅是一台装有vscode的普通电脑即可，不需要再操心开发环境，各种SDK，C++，Python，Nodejs等等八辈子不用的软件装了一大堆，还需要经常更新才行。
节省成本 大多数开发人员是不需要经常开发大型项目和远程调试代码的，但是不是完全没有，这样就需要为了不时之需而配置笔记本电脑，而笔记本电脑一般相对台式机是又贵性能还低，公司要为了应对偶发情况而给开发人员配备笔记本电脑，会造成资源浪费，成本升高。
如果有了远程开发环境，则能应对临时性工作，大大降低成本。
用iPad写代码 如果你觉得vscode远程开发还不够酷？那在iPad中写代码呢？
vscode远程开发虽好，但还有有局限性，毕竟还是需要一台可以安装vscode的电脑，还是不能随时随地的写代码。现在我要告诉你如何在iPad中写代码！
code-server是一个可以运行在服务器上的web项目，这下我们可以在浏览器中使用vscode了，可以在浏览器中打开vscode的，自然就可以使用iPad来写代码了。 Eclipse Theia https://gitpod.io/#https://github.com/eclipse-theia/theia
额，希望苹果能给我广告费！
再或者使用使用codespaces也可以在线编辑代码，https://mp.weixin.qq.com/s/Eutjgbx_nofmuhU2yBGhxg
最后 贴一篇带图的环境搭建教程真香！使用 VSCode 远程开发调试</description>
    </item>
    
    <item>
      <title>通用的数据库GUI工具</title>
      <link>https://www.yuedun.wang/blogdetail/5fb32fc75edb9b37630b7a6a/</link>
      <pubDate>Tue, 17 Nov 2020 02:04:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fb32fc75edb9b37630b7a6a/</guid>
      <description>MySQL常用的客户端是Navicat，SQLyog等，本文推荐另一款通用的客户端：DBeaver
DBeaver不能创建表？那是因为选错了视图。可以重新编辑链接</description>
    </item>
    
    <item>
      <title>puppeteer模拟3G网络</title>
      <link>https://www.yuedun.wang/blogdetail/5faa34535edb9b37630b6e99/</link>
      <pubDate>Tue, 10 Nov 2020 06:33:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5faa34535edb9b37630b6e99/</guid>
      <description>puppeteer要模拟3G，4G网络需要利用DevTools Protocol。 Chrome DevTools Protocol
page = await browser.newPage(); // 模拟3g网络 let cdp = await page.target().createCDPSession(); await cdp.send(&amp;#39;Network.emulateNetworkConditions&amp;#39;, { &amp;#39;offline&amp;#39;: false, &amp;#39;downloadThroughput&amp;#39;: 600 * 1024,//(bytes/sec) 3G最高600K/s 4G 最高10M/s &amp;#39;uploadThroughput&amp;#39;: 600 * 1024,//(bytes/sec) &amp;#39;latency&amp;#39;: 0 }); await page.setCacheEnabled(false); await page.goto(url); </description>
    </item>
    
    <item>
      <title>postman使用技巧</title>
      <link>https://www.yuedun.wang/blogdetail/5fa0f8e55edb9b37630b65f7/</link>
      <pubDate>Tue, 03 Nov 2020 06:29:57 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fa0f8e55edb9b37630b65f7/</guid>
      <description>postman是开发人员必备的接口测试工具，虽然经常使用，但是并不会使用到所有功能，除了简单的接口测试外，它还有很多实用的功能，如果充分利用起来，能使我们的工作事半功倍。
环境变量的使用 捕获请求和cookie 收藏接口与分享接口 批量测试 编写文档和示例 环境变量的使用 环境变量的作用是使用切换变量的方式代替频繁的环境修改。这样我们只需保存一次测试接口就可以在不同环境下使用。 举例：
环境变量配置
环境变量使用
环境变量切换
捕获请求和cookie 能够直接将浏览器中的请求和cookie同步到postman，省去手动复制请求接口和cookie到postman中。 同时，对于需要登录后使用的接口，postman可以直接使用浏览器的登录状态，而不必复制cookie。 举例： 收藏接口与分享接口 将自己保存的接口分享与他人，直接拿来即可使用。 如果安装了Chrome插件，则可以直接的浏览器中打开链接。使用客户端需要使用import来导入。 批量测试 保存的多个接口批量测试。 编写文档和示例 对于团队协作很有用，接口交流利器。不仅有了请求参数，添加一个example还可以看到接口返回参数。 </description>
    </item>
    
    <item>
      <title>vue nuxt组建注册</title>
      <link>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</link>
      <pubDate>Wed, 23 Sep 2020 05:50:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</guid>
      <description>Nuxt.js 2.13+可以扫描并自动导入您的组件，不再需要在该script部分中手动导入它们！
nuxt.config配置：
export default { components: true } 设置为true或使用对象时，它将包含nuxt / components依赖项，并且~/components在模板中使用它们时会自动导入您的组件。
组件目录：
components/ ComponentFoo.vue ComponentBar.vue 使用
&amp;lt;template&amp;gt; &amp;lt;ComponentFoo /&amp;gt; &amp;lt;component-bar /&amp;gt; &amp;lt;/template&amp;gt; 注意：如果使用nuxt 2.10&amp;hellip;2.13，则还必须手动安装并添加@nuxt/components到buildModulesinside nuxt.config。</description>
    </item>
    
    <item>
      <title>nodejs专用发布系统</title>
      <link>https://www.yuedun.wang/blogdetail/5f41c9d65edb9b37630b0d46/</link>
      <pubDate>Sun, 23 Aug 2020 01:43:50 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f41c9d65edb9b37630b0d46/</guid>
      <description>Nodejs项目部署到服务器以后接下来做的最多的操作就是上线发布了。因为nodejs的语言特性决定了其开发效率高，发布自然就频繁，每个公司或个人都有自己的发布方式。
有的公司会有严格的流程，必须通过CI/CD工具进行发布，有可能使用现成的工具，如：jenkins。有可能是自研发布系统。
有的公司会通过FTP上传代码到服务器发布。
有的公司使用更原始的发布方式，直接登录服务拉代码发布。
不论哪种发布方式都有其优缺点，越高级的工具会有诸多限制，比如有权限控制，有严格的审批流程，自然就不能随时发布，也就越僵化。越原始的方式越简单越灵活，自然风险也越高。
至于采用哪种发布方式，依据需要选择即可。
而关于nodejs的发布方式，本人也是也是多种方式都有使用，公司项目也经历过多次变迁。公司最开始是直接登录服务器拉代码发布，后来有了运维团队，领导说开发自己发布不安全，于是就由运维搭建了Jenkins环境来发布，但是每次发布都需要走流程，后来因为发布太频繁，每1-2天要发布一次，又要灰度发布，运维也会觉得烦。于是开发就搭建了某个发布系统自己来发布，不过这个发布系统有个缺点，就是发布集群的时候是串行的，每次发布要十几分钟。
另外说明一下Jenkins。它应该是使用最多的发布系统了，Jenkins基于Java开发，它已经是成熟的系统了，成熟同时也代表着复杂，复杂代表修改困难，我想大家也不太会基于Jenkins定制开发。 然后是部署困难，相比较nodejs三条命令搞定linux安装nodejs——快捷版，go直接放二进制文件部署，Jenkins部署可能就略显复杂了。
于是下定决心自己开发一个发布系统，朱雀发布系统因此诞生。
基于以往的发布系统使用经历，我想要的是一款使用够灵活，部署够简单的发布系统。市面上现有的系统为了满足各种语言的发布，做的大而全。我自然是不想重蹈覆辙再做一个大而全的系统，我要的是小而美。正好之前了解过PM2本身集成了远程发布功能，可以在此基础上开发。PM2本身的发布过程其实已经很简单了，而且足够灵活，能够满足我的部分要求，但是公司的环境是不能在本地直接连接应用服务器的，所以需要一个中间层代理一下，放一张简单的架构图：
和其他工具架构逻辑一样，都是通过ssh来通信，不同的是朱雀没有直接使用ssh，而是利用了pm2,由pm2来实现通信，它已经为了做了一部分工作，比如拉代码，回滚，执行远程脚本。 由于nodejs的项目特性，它依赖了node_modules包，如果按照打包的方式发布会又大又费时，所以还是选择拉git代码的方式发布比较合适。 所以我只需要给它做一个图形界面，并有一定的管理和审批流程（可根据环境跳过）。 放一张图来看一下：
项目地址：nodejs发布系统
朱雀发布系统支持scp（rsync）发布</description>
    </item>
    
    <item>
      <title>MEGAEASE的远程工作文化</title>
      <link>https://www.yuedun.wang/blogdetail/5f3644b25edb9b37630b026a/</link>
      <pubDate>Fri, 14 Aug 2020 08:00:50 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f3644b25edb9b37630b026a/</guid>
      <description>MegaEase 是我创业的公司，主要是想把云计算（PaaS/SaaS层）的那些高可用高并发的分布式技术普及到那需要对技术自主可控的公司，这样就不需要去使用不能自主可控的闭源系统或是大公司的云平台。我于2016年开始成立MegaEase，从早期8个人，直到今天有20来个人，我们从一开始到今天都是在远程工作的公司文化。因为我很喜欢《Rework》这本书，写这本书的公司叫37signal（现名basecamp），这家公司在发《Rework》这本书的时候，整个公司只有16个人，分布在全世界8个城市，这种Geek的公司的文化很吸引我，所以，在我决定创业的时候，我就止不住地想成立这样能够远程工作的公司，于是，远程工作的团队文化就这样成为了MegaEase的基因。下面我会分享一下，我们公司的远程工作文化和其中的一些问题，最后还有一个工作协议。
我们在早期的时候，8个员工来自5个城市，现在的20来个员工来自8个城市2个国家。虽然我们现在使用“共享办公室”，但是本质上，我们的整个文化是远程工作的文化。在2017-2018年度，我们公司产品商业化以来，公司早期的8个工程师在远程工作的状态下成功支持了得到的老罗的跨年演讲活动，以及其它几个客户，一方面验证了用户愿意付费购买我们的产品和服务之后，另一方面也有一些不错的收入，客单价都在百万左右。还记得当时，有几个投资人并不相信我们连个办公室都没有，而且8个人分布在5个城市，觉得我们是个骗子公司（哈哈）。在过去的一年，我们通过我们的产品和服务帮助银行电信互联网等公司进行了他们的系统架构的改造和升级，让复杂和高门槛的分布式技术和架构可以被更多的企业所掌握所应用。这说明，远程工作是没有什么问题的。实际上远程团队远程工作真的不新鲜，Github上有个Repo维护着一个支持远程工作的公司列表，还有一个跟远程工作相关的Awesome索引。
当然，自从我创业以来，我身边就一直有好些不同的声音质疑远程工作。听过他们的理由后，我能够理解他们的疑虑和困惑，因为管理的确是一个很复杂的事，因为要面对的是极为复杂的人，所以，有这些疑虑也是正常的。下面是我的一些经验和分享。先说宏观管理，再说微观实践。
目录
宏观管理 一、努力找到好的人 二、设定共同的目标和使命 三、倾向使用小团队 微观实践 远程工作协议 小结 宏观管理 我发现很多人比较质疑远程工作的原因，更多的是表现在对宏观的管理上有问题。所以，我还是想先说一下宏观管理，这其实并不分远程办公还是集中式办公，如果能够解决好些这管理上的根本问题，其实，远程不远程都无所谓了。只不过，这些问题在“远程办室”的场景更更突显罢了。
一、努力找到好的人 团队管理的头等大事是找人，没有之一。 很多人都会跟我说，你的这种远程团队需要很好的人。是的，没错，人很关键。远程团队需要的人的一般需要有这些特质：
能独挡一面的人。这样交给他的事能独立完成，没有路能自己找路，这样可以省很多管理成本。 沟通能力很强的人。一方面，他们把模糊的事能变清楚，另一方面，他能有效地说服他人。不然就会非常扯皮和消耗时间。 能自管理和自驱动。不能自管理和自驱的人，会增加大量的管理和教育成本。能自驱动的人，都是对负责的事情有认同的人。 如果你仔细思考一下，你会发现，这样的人是任何一家公司所渴望的人，和远不远程无关。只不过，如果是远程团队的话，你会被逼着要招到这样的人。
招到这样的人，你团队的执行力会非常的强悍。招不到这样的人，你只能为他们不能自管理和自驱而招“经理”，不能写出好的代码而招“测试”，不能很好的沟通而招个“项目经理”，不能独档一面，而要把好的人安排给他们当“教练”，而好的人则会被累死……
这个时候，你就需要计算一下了，是花时间精力在教育不好的人，还是花时间精力找好的人？无论远不远程，聪明的管理者都会选择后者。这也就是为什么Amazon的Bezos会说，“我宁愿面50个人一个人都招不到，我也不愿意降低我的面试标准”。
二、设定共同的目标和使命 对于远程团队来说因为见不到面，所以，缺乏交流和沟通。所以，需要团队里所有人能在同一篇上，能够对要做的事有一个统一标准的认识。也就是共同的目标和使命的认知。知道要要什么，不要什么。知道取舍，知道trade-off。这些东西都是需要团队一起达成的共识。如果没有这样的“Same Picture”的目标和使命，就会出现很多不必要的误解和冲突。另外，因为团队和业务也在迅速发展中，所以，也需要不断地调整和沟通。这都需要领导者花费时间统一目标和使命。
老实说，无论远程不远程，一个团队也是需要有共同的目标和使命的。没有共同的目标，就算是集中在一起办公，也一样没有效率的。
三、倾向使用小团队 因为沟通成本的问题，远程团队更为倾向使用小团队，但并不是说小团队会限制整个公司的规模。《人月神话》说过，只有小团队才能驾驭复杂的系统。Amazon 的 Two Pizza Team的文化（团队的大小只能到两张披萨就能喂饱的大小），就是把整个系统拆成“微服务”架构，这样可以导致整体效率的巨大提升。表现在，可以并行开发，专注于一个功能更利于解决复杂问题，简单可以更容易的运维，可以更容易的规模化……
我工作的这20多年来经历过很多公司，尤其是创业的这几年来，看过的公司更多了（50+以上了），我发现，人数越多的团队，基本上来说，就更偏劳动密集型。劳动密集型的一个特征就是，大家整天在想，得整点什么事给这么多人，好让他们忙起来。而人数少的团队，因为人不够，所以每天都在想，什么样的事更重要，什么样的事可以自动化，怎么做更有效率…… 小团队和大团队的关注点就这么不一样了，所以做出来的事也就不一样了……
当然，并不是说劳动密集型有什么问题，就像《软件团队的两种管理方式》一文所说的一样，远程团队工作更倾向于“电影工作组”式的每个人都是leader的知识密集型的团队。
微观实践 在远程工作中，我们需要有很多的微观操作来让大家能够更好的进行远程工作。因为远程工作也有一些问题（但是方法总比问题多，不是吗？）
文档驱动。首先，远程的问题就是沟通不方便了，集中化的办公一群人可以在白板上进行讨论，然后远程工作这个事就变成很复杂了。所以，当要讨论什么事的时候，需要发起人先写一个文档，然后大家在这个文档上进行讨论（我们通常使用Github的issue，Pull Request或Google Doc）。另外，写文档的好处太多了，除了给后人有一个可以追溯的东西，更重要的是，写作是一种深度思考，当你把你脑子里想的东西写下来的时候，你就会发现你的思考更多了。所以，文档驱动我们团队能力非常重要的事。
自动化和简化。自动化和简化是我平时追得最多的东西了，从软件的Unit Test, Functional Test, Performance Test 一直到用Kubernetes进行自动化部署，我要求的就是从一提交完代码后就自动化的上线。我们玩的是Amazon的“单分支”代码管理的玩法，一旦代码merge上master，就会直接上线（当然需要通过灰度）。因为远程团队如果没有自动化的工具，那么，就会导致整体效率的下降。
Owner文化。这个太重要的了，但是，这并不是在说，如果一个事没有owner，就会像“三个和尚”那样，事情就进了没人管的地步。这是因为很多人在工作中都是比较 nice 的，比较 nice 的人通常来说都不好意思跳出来对别人发号施令。所以，Owner 文化就是要求每件事都要定义一个Owner，而这个Owner是有权对其它人发号施令的，其他人也有义务要配合他。当然，Owner 的权利越大，责任也会越大！
Review文化。Review文档是一种把知识或是想法传递出去的方式。我们在实践过程中，需要大家把好的想法写下来，这需要包括问题背景、目标、可选的方案（这些方案需要有引用和数据，不能是拍脑袋）、还需要有Pros/Cons的比较。然后再发起讨论。这样，事情在一开始就做好，那么就可以让大家的讨论更加地有效率。很多人以为开会讨论有个议题就行了，其实不够，有效率的开会讨论需要的是议案，而且还是高质量的议案！
目标承诺。我们需要每个人承诺自己的工作目标，这个完全由每个个体来发起、完成。一般来说，每个人自己给自己制定的计划最好是在1-2周内。
自我管理。我们的实践是没有审批制度，无论是，休假、报销、出差，完全是自己自由安排，但需要告诉团队（除非在一些关键时期没法休长假，需要整个团队全力以赴），但千万不要撒谎和作弊，一旦发现，直接开除就好了。这个是基于好人更多的原则制定的（没有必要为了少数的坏人一刀切后让所有人痛苦）
闲聊和自行见面。见面和不能见面是一件非常不一样的事，在一起工作时，人和人是会有感情的，因为会有闲聊。远程的时候，则只有工作了。所以，我们鼓励团队人员间的私聊，闲聊，互相对方讲讲自己的经历和过往，同时，也鼓励员工自行出差到对方的城市见见跟你一起工作的人，公司报销差旅费。
知识分享会。我们每周都有知识分享会，一次只讲半个小时，不贪多，就讲一个小的知识点。然后，团队中的一些人还主动使用Google Form来收集分享的反馈信息。
就地奖励文化。我们默认上是没有年终奖，只有就地奖励文化。也就是说，你做的事挣钱了，利润中有70%公司拿走，剩下的30%团队的人就地分掉。这样会让团队里的每个人都会想怎么挣钱，除了可以把精力放到那些能够让用户付费的地方上，更重要的是让团队成员了解一下业务和用户为什么要付费，这个是非常关键的。当然，如果公司没有挣钱，但是员工工作的不错，我们还是会给年终奖的。不挣钱的主要责任是我的，而挣钱的主要功劳是团队的。
外包支持性的工作。一些支持性的工作尽可能地使用外包，比如：HR、行政、发工资财务、员工持股、测试人员、定制化开发……这样可以让你的团队更小，更高内聚。更利于远程。
异步编程。如果一个项目是从零开始的，对于一个团队来说可能会是无从下手的，这需要有个人（owner）把代码的框架和结构给组织好。然后其他的人进入把坑填了，这样的效率会高很多。另外，不见面的结对编程，完全可以使用异步的方式进行，这其实就是多人干同一个pull request的方式。有Github这样的协议工作，远程编码变得很方便。
关于我们的远程工具，我们主要是使用：
开发环境
AWS，我们主要使用AWS，因为我希望团队在使用AWS的时候能够被潜移默化。 协作工具</description>
    </item>
    
    <item>
      <title>vue子组件修改父组件的数据</title>
      <link>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</link>
      <pubDate>Sat, 01 Aug 2020 03:32:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</guid>
      <description>vue在子组件中直接修改父组件传递下来的数据会报错： Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&#39;s value. Prop being mutated: &amp;quot;json&amp;quot;
原因是vue子组件不能直接修改父组件的数据，可以使用this.$emit发送通知，让父组件来修改。 示例代码：
子组件：
this.$emit(&amp;#34;changeData&amp;#34;, &amp;#34;要修改的数据&amp;#34;); 父组件：
&amp;lt;mycomponent :json=&amp;#34;JsonData&amp;#34; @changeData=&amp;#34;changeData&amp;#34;&amp;gt;&amp;lt;/mycomponent&amp;gt; data(){ return { JsonData:{} } } methods:{ changeData(newData){ this.JsonData = newData; } } 子组件发送changeData事件， 父组件绑定changeData事件并接受数据，赋值给父组件的JsonData属性，子组件的值也会改变。从而实现子组件修改父组件的属性值。</description>
    </item>
    
    <item>
      <title>原生js实现图片预览</title>
      <link>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</link>
      <pubDate>Wed, 29 Jul 2020 03:45:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</guid>
      <description>不依赖jquery也可以实现图片预览功能：
&amp;lt;!--图片放大后的div 开始 这块粘贴在你的html中最后body前 --&amp;gt; &amp;lt;div id=&amp;#34;outerdiv&amp;#34; style=&amp;#34;text-align: center;position: fixed;z-index: 9999;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(28,28,28,0.9);&amp;#34;&amp;gt; &amp;lt;img id=&amp;#34;bigimg&amp;#34; style=&amp;#34;max-height: 800px;max-width: 100%;border: 0;margin: auto;position: absolute;top: 0;bottom: 0;left: 0;right: 0;&amp;#34; src=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--图片放大后的div 结束 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;!--js开始 是放大点击的触发事件 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; //图片放大 document.querySelector(&amp;#34;#outerdiv&amp;#34;).style.display = &amp;#34;none&amp;#34;; document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { item.style.cursor = &amp;#34;pointer&amp;#34;; }); document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { item.addEventListener(&amp;#34;click&amp;#34;, function () { imgShow(&amp;#34;#outerdiv&amp;#34;, &amp;#34;#bigimg&amp;#34;, this); }) }) function imgShow(outerdiv, bigimg, _this) { var src = _this.</description>
    </item>
    
    <item>
      <title>goquery 中文乱码</title>
      <link>https://www.yuedun.wang/blogdetail/5f1fb24c4536b06ac3897662/</link>
      <pubDate>Mon, 27 Jul 2020 13:09:20 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f1fb24c4536b06ac3897662/</guid>
      <description>乱码的情况目前有两种可能：
常规乱码，网页非utf-8。 非常规乱码，代码导致的乱码。 关于常规乱码可参考issue获取中文网页有乱码的问题 #185 非常规乱码就像我遇到的一样，最开始以为是网页问题，使用了github.com/djimenez/iconv-go转换还是乱码，使用了golang.org/x/text/encoding/simplifiedchinese还是乱码。 试试英文网页，还是乱码。最终一点点调试发现是由header引起的。 req.Header.Add(&amp;quot;Accept-Encoding&amp;quot;, &amp;quot;gzip, deflate&amp;quot;) 这一行的作用是告诉服务器浏览器要接收的数据编码是gzip,dflate，到达浏览器后会自动解码。但是我们的代码并非浏览器，不会自动解码，所以接收到的就是非常规的压缩数据。</description>
    </item>
    
    <item>
      <title>国产动漫之不幸</title>
      <link>https://www.yuedun.wang/blogdetail/5f1e88b24536b06ac38974d6/</link>
      <pubDate>Sun, 26 Jul 2020 14:56:34 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f1e88b24536b06ac38974d6/</guid>
      <description>最近侄子放暑假来我家玩，顺便带来了暑假作业，写作业的时候他问：“我国四大名著是什么？”
我当时一愣，心想这种问题还需要问吗？但是没有这么问他，而是问：“你们课本上没有教过吗？”
他说：“没有！”
我问：“那老师有没有说过？”
他说：“没有”
我心想：“可能是二年级还没有到应该知道的年龄！”
就问：“那你知道《西游记》吗？”
他说：“不知道。”
我问：“那《三国演义》，《红楼梦》，《水浒传》你更不知道了吧？”
他说：“不知道。”
当时我就有点气了，我气的不是他什么都不知道，而是气他到底看些什么动画。
于是我问：“《西游记》动画片你都没看过，那你平时都看什么动画？”
他说：“奥特曼，小猪佩奇，海绵宝宝，汪汪队，还有……”
四大名著不知道，四个动漫说的很溜，而且好像都是国外动漫，我赶紧打断，说道：“行了，行了，从今天开始，在我家你不能看这些动画片了，我们从今天开始先从《西游记》看起。”
他顿时有点不乐意了，但是也没办法。于是在吃饭时间我找到了《西游记》动画，结果看了两集他就直对我说好看。 此刻，我对国漫的现状感到悲哀，正好和最近多次在公众号上看到关于国漫被举报的话题相对应——“人物头发染成五颜六色，穿得花里胡哨，价值导向有问题”。 当时也只是感觉现在这家长真是闲的慌，自己的价值观是不是有问题，反而去举报动漫。动漫中的人物染五颜六色的头发也能成举报理由，我们从小看的动漫人物不都是这种造型吗？并没觉得有什么不妥，也没听说过有人因动漫人物造型问题而走上违法犯罪的道路。
现在摆在眼前的现实问题是：我们的孩子不只是没有国产动漫可以看，甚至连中国文化都开始丢弃，是因为中国文化不好吗？绝对不是！而是作为家长，作为长辈的我们都在排斥和诋毁中国文化。小时候看的一些优秀动画现在都已经看不到了，其中有不少是禁播了。老的动画禁播，新的动画审核不通过，剩下的只有国外入侵动漫，国外文化入侵。
请问下面哪个是孙悟空？
希望我们的后代还能分得清什么是中国的，什么是外国的。
国产动画不乏有很多优秀作品，未来会有更多，希望能够理性的对待，而是总是在挑毛病。</description>
    </item>
    
    <item>
      <title>关于个人博客（网站）发展的一些思考</title>
      <link>https://www.yuedun.wang/blogdetail/5f1393cf148c8850e52174dc/</link>
      <pubDate>Sun, 19 Jul 2020 00:29:03 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f1393cf148c8850e52174dc/</guid>
      <description>最近在更新网站源码的时候想到一个很现实的问题，当初出于学习和兴趣的目的花了很大的力气建立这个博客，也陆陆续续更新了一百多篇文章，到现在更新博客还是出于兴趣。但是有一个不得不面对的问题，就是维护成本。
回想一下这个博客也是经历过几次迁移，最开始是部署在百度云上，那时是2014年，百度云也算建立初期为了吸引用户和内测，提供了BAE服务，费用很低，每天只需2毛钱，一个月也就6块钱并且免费提供了数据库服务，基本算是白嫖。不过这种便宜的午餐持续到2018年结束了，正好遇到阿里云活动，3年270元，果断下单。然后就是域名备案，数据迁移等。
由此可知，自己维护一个博客（网站）还是很费心神的，很多个人博客都逐渐退出了互联网。就连一些大平台提供的博客都逐步下线，更不要说个人博客了。 在我接触互联网以来经历了很多博客平台的没落，其中不乏大平台，举例一二：网易博客，百度空间，甚至连新浪博客也出现不维护的现象，最近半年都无法发布内容。
虽然博客走向没落，但其实人的需求一直是存在的，人们一直希望有个平台来展示自己，发布信息，只不过一直在迁徙而已。从前的博客，现在的微信公众号，只是平台在变化，不变的是一颗躁动的心。 即使有再多的自媒体，短视频，微博，这些大多属于娱乐信息，提供的有用信息很有限，真正有用的信息还是来自个人博客。现在的知乎，简书算是提供了个人发布信息的平台，而微信公众号虽然也有很高的价值，但是其系统过于封闭，搜索引擎是收集不到的，所以信息的传播能力也有限，只能被动的接收，并不能主动的获取需要的信息。
在未来，更多的人需要个性化的展示平台，也就是不断有新生力量建立博客，虽然“博客”这个词都有可能过时，但是这样的网站会层出不穷。</description>
    </item>
    
    <item>
      <title>让web项目不再502</title>
      <link>https://www.yuedun.wang/blogdetail/5f119031148c8850e521735f/</link>
      <pubDate>Fri, 17 Jul 2020 11:49:05 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f119031148c8850e521735f/</guid>
      <description>前后端分离 近几年比较流行的web项目开发架构是前后端分离，前后端分离架构在系统稳定性方面非常有优势，其中一点优势主要体现在用户感知上，即使服务端发生错误也不会展现在视图层，一般情况下用户是可以继续浏览网页，不会很突兀的显示这样的信息： 502 bad gateway
在接口发生错误时虽然可能会获取不到一些数据，但是在用户体验上比直接显示502错误要好。
部署也相对安全和方便。
前后端分离架构虽好，但不是”银弹”，不是所有网站都能使用前后端分离架构来做。
服务端渲染 至于分不分离都有诸多的优缺点，可根据实际场景选择，本文要说的是不分离情况下文章开始所提到的问题——难看的502，500错误。
本文我将使用“服务端渲染”来代替不分离的架构。
由于服务端渲染的所有数据处理都在服务端进行，发生任何错误都可能引起500错误，这种错误会直接体现在视图层，用户看到这样的信息很不友好。 500 Internal Server Error
遇到这种错误，可以使用适当的措施来弥补，带来的效果却非常良好。开发web最多遇到的错误码有：404，500，502。
404错误很多网站都有默认页面，像这样的：
但是500，502错误却鲜有默认页面，我们何不也搞一个呢？
500错误 首先说一下500错误的应对措施，500发生在服务端，比如空指针，数组溢出，超时等都会引起web服务500错误，一般的500错误在应用层面是可以捕捉到的，在response返回之前捕获异常跳转到一个”合适的页面”，这样就可以避免出现500 Internal Server Error信息。虽然这个“合适的页面”不是本应该跳转的页面，但起码还是个正常页面。
502错误 再说一下502错误，发生502错误一般是应用直接宕机了，任何页面都是访问不到的，这样是无法在应用层面监听和处理的，但也不是没办法，我们可以在NGINX上处理，当NGINX发生502时跳转到”合适的页面”。这个页面需要是一个静态页，可以是友好的提示信息，可以是网站首页，根据需求自己定制即可。
server{ error_page 502 /502.html; location = /502.html { root /usr/share/nginx/html; } } 以上两种错误处理虽然不能应对所有网站，比如一些个性化网站，即使掩饰的再好，用户也知道出问题了，但是在有些网站却能起到良好的作用，比如有些web站点发布时会中断服务出现502，比起光秃秃的500和502错误，上面的处理是不是就好多了。</description>
    </item>
    
    <item>
      <title>go mongo-driver动态条件</title>
      <link>https://www.yuedun.wang/blogdetail/5eec6fd5e8775d3b7f2ee79c/</link>
      <pubDate>Fri, 19 Jun 2020 07:57:09 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5eec6fd5e8775d3b7f2ee79c/</guid>
      <description>在go mongo中查询是使用的是bson.M类型的条件，但是直接使用时无法动态添加条件，只能初始化赋值，bson.M其实就是map类型，只能使用someMap[&amp;ldquo;someKey&amp;rdquo;]=&amp;ldquo;someValue&amp;rdquo; 的形式添加，这样的话只能是用if判断字段的值来决定是否添加map key/value，写起来比较繁琐。还有一种是利用结构体转换为bson.M来实现。
//构造一个查询结构体 search := User{ ID: id, Name: name, Age: age, } //构造一个条件变量 condition := bson.M{} //将结构体转为字节数组，userInfo中的字段根据需要设置值，需要保证没有值时不会有默认值出现 userbyte, err := bson.Marshal(search) if err != nil { return user, err } //将字节码转为bson.M类型 bson.Unmarshal(userbyte, &amp;amp;condition) log.Println(condition) if err = this.mongo.Collection(&amp;#34;user&amp;#34;).FindOne(context.TODO(), condition).Decode(&amp;amp;user); err != nil { return user, err } 以上基本就实现了动态条件查询的效果，其中：
search := User{ ID: id, Name: name, Age: age, } search结构中的字段可能值为空，假设在前端并未传递age字段，那么最终condition=map[id:xxx,name:xxx]，并不会出现age:0这个的字段，有效避免了零值情况。</description>
    </item>
    
    <item>
      <title>puppeteer TypeError: text is not iterable</title>
      <link>https://www.yuedun.wang/blogdetail/5ee6fae2e8775d3b7f2ee0c6/</link>
      <pubDate>Mon, 15 Jun 2020 04:36:50 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ee6fae2e8775d3b7f2ee0c6/</guid>
      <description>(node:9828) UnhandledPromiseRejectionWarning: TypeError: text is not iterable at Keyboard.type (D:\workspace\auto-ui\node_modules\puppeteer-core\lib\Input.js:160:24) at Keyboard.&amp;lt;anonymous&amp;gt; (D:\workspace\auto-ui\node_modules\puppeteer-core\lib\helper.js:112:23) at openBrowser (D:\workspace\auto-ui\test-email\index.js:106:25) at process._tickCallback (internal/process/next_tick.js:68:7) (node:9828) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 3) (node:9828) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.</description>
    </item>
    
    <item>
      <title>你是拿锤子的前端开发吗？</title>
      <link>https://www.yuedun.wang/blogdetail/5eb778a2bd7e796e7100c718/</link>
      <pubDate>Sun, 10 May 2020 03:44:34 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5eb778a2bd7e796e7100c718/</guid>
      <description>前言 接上篇《说道说道前后端分离》今天再次对前端现状作一次分析（吐槽）。
再次引用一句《穷查理宝典》中的理论：
在手里拿着锤子的人看来，所有的东西都会是钉子。
因为有锤子的关系，遇到任何问题，都会先想如何用锤子解决。久而久之，陷入了一种思维定式。任何工具带来便利的同时，也带来了局限性。而这往往是用锤子的人很难看到的。
事出有因 这种现状在开发圈内决不少见，不仅限于前端。本文只说说前端的现状，原因是笔者最近在工作中遇到一个棘手的问题：性能优化。
最近接手了多个现有的前端项目，是公司比较核心的移动端官网，作为门户网站访问量和用户量都比较大，但是随着项目的迭代出现了性能问题，页面加载速度在WiFi网络下达到3s,3G网络15s以上，更差的网络40s+。加载的资源小则3M，大则6M。如果一切往好处想，假设所有用户使用最好的网络，用户和公司都不在乎流量费，两三秒的加载速度也还挺快的，每次打开页面费个3M流量也不是个事。但如果考虑这些问题的话就会发现这不是小问题。
对以上问题分析得出结论之一：资源过大，有兴趣的可以打开淘宝网看下首屏资源做下对比，可以看到资源不超过3M，时间不超过2s。
而我们一个移动端网站的资源居然能超过3M，究其原因：
图片大 js大 css大 图片大是因为图片基本没任何大小控制，都是使用了最高标准原图。js和css大基本是属于架构问题，一个项目中包含的上百的页面每个页面600多k的js是绕不过去的（vendor.js,app.js等打包资源，不包含其他引入资源）。
看到vendor.js,app.js这两个名称很多人应该想到了，这是vue（react）框架开发的网站。 是的，就是用vue开发的移动端网站，使用vue开发网站本身也不是什么大问题，毕竟有实力的公司不需要SEO，直接竞价排名就行。而我要说的问题是，不是什么网站都可以用vue来开发，不信请继续往下看。
问题分析 我司的移动端网站作用并不仅仅是用来展示公司形象的，更重要的是用户转化的，就是让用户注册的。而且是要和很多第三方机构合作投放引流，经常需要分析页面UI的不同对转化率的影响，所以需要的页面不是几个，而是几十上百个，还在不停增加，每周都有三五个页面增加。 由于vue主要是以开发单页SPA应用为主的，在开发人员不考虑真实需求的情况下自然会使用流行的技术，最终把网站开发成一个单页应用。单页应用的特点就是单页，就是把不同的页面做成一个页面一次加载，加载完成后页面之间的切换就会很快，一般无需再加载资源，用户体验也会好很多，可以套用一句话：“一次等待，处处快速”。
这个特点在管理后台项目中很合适，但是在只需要展示一次的项目中也合适吗？不合适。
我们的网站项目是用来做很多落地页的，各个落地页之间没有关联性，不会A页面跳到B页面，从B页面跳到C页面，A页面中不需要B页面的资源，B页面也不需要C页面的资源。然而vue项目打包的时候会把每个页面独有的一些资源都融合在一起，形成公共资源。结果就显而易见了，一个页面总要加载一堆无关资源，不仅资源大，还有很长的白屏时间，用户体验下降。
还有一点不该使用单页应用的原因是我们的页面是纯展示的页面，不需要很多数据交互，vue能起到什么作用？操作数据？驱动UI？模块化？通通不需要。现代html可以不借助第三方库和框架的情况下完全能实现。
结论 JavaScript 的最大优势之一是它不需要编译，所以可以在浏览器中直接运行。这样你就可以立刻获得编码的反馈。入门门槛很低；你只需一个文本编辑器和一个浏览器就能编写软件了。 不幸的是，这种简单性和可访问性已被称为过度工具链的风气破坏了。这种风气已经将 JavaScript 的开发工作变成了一场噩梦。我甚至看过一整套关于配置 Webpack 的课程。这种乱象需要有个尽头——生命苦短啊。
VUE，React这类框架用于构建应用方面很合适，但不太适合构建网站。应用是需要有较多的UI和数据方面的交互，而网站则更多的是信息展示，你可能根本不需要JavaScript（框架）。
追求新技术可以让我们获得新奇感，成就感，解决老问题，而不是带来新问题。复杂性才是造成软件问题的根本原因。——试问：离开框架的你还会开发网站吗？</description>
    </item>
    
    <item>
      <title>人人都值得学习的UI自动化</title>
      <link>https://www.yuedun.wang/blogdetail/5e96f1d8bd7e796e7100a71a/</link>
      <pubDate>Wed, 15 Apr 2020 11:36:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e96f1d8bd7e796e7100a71a/</guid>
      <description>为什么需要UI自动化？ 说起自动化，听着很厉害，可是也没见识过到底多厉害，基本是属于传说，没见过实战。但不能否认其价值，作者本人作为一个开发者也是偶然的机会接触到UI自动化，感受到了自动化的魅力，才不惜花时间来学习并使用在实际工作中。下面就来说一下为什么要做自动化。 自动化有很多种，单元测试，接口测试，UI测试。所有测试过程可以形成这样一个金字塔：
（图片来自网络）
（图片来自网络）
从图中看出底层测试简单快速，每个单元相对独立，测试成本也较低。而最顶层的UI层聚合了底层的很多接口服务，一个测试流程相对更长更复杂，也就导致了速度慢，成本高的问题。如果由人工来完成，一个完整的测试流程往往需要几分钟，而且是不停的重复这样一个流程。所以很多开发都不愿意完整的测试自己所开发的一套业务，只能由测试人员不厌其烦的循环往复。此时如果有自动化的话就非常nice了。口说无凭，一图胜千言：
是不是还没看清？没错，平时人工测试一个报名表单需要15秒左右，而自动化后几乎一瞬间即可完成，速度提升不言而喻。如果您对UI自动化已产生兴趣，请继续往下看。
哪些场景可以UI自动化？ UI自动化的目的不是为了自动化而自动化，也并不能覆盖所有测试。还是以测试金字塔来说明：
UI自动化虽然只能覆盖到约10%，但其价值却不可忽略，因为越往顶层消耗的人力成本越高，如果底层测试不够充分就只能靠顶层测试来保证。自动化虽好，但需要满足特定的场景才行，那么什么样的场景可以做UI自动化？
流程变化少。侧重UI的修改，而不是流程的修改。 频繁的回归测试。比如一个报名表单样式修改比较频繁，需要测试其报名是否可用。 界面稳定。样式可以频繁修改，但表单顺序和个数变化较少不能频繁变更。 维护周期长。如果只是使用一次那也不必自动化了，毕竟自动化是解决重复劳动。 开发与测试可相互配合。自动化需要程序有一定规范便于测试人员写测试程序。 测试人员具备编程能力。 如果满足了上述的场景，那么UI自动化在人力消耗和效率上就有很大的提升。正确性上更有保证，手工录入会有输错重输的情况，而自动化则不会出现。 再看一个流程比较长的页面： 上面动图并没与快进，一气呵成完成了一次下单流程，基本不需要停留即可进入下一步，相比起手动操作省时省力。
为什么UI自动化普及率低？ 既然UI自动化能提高效率，但为什么却很少有人去使用？
开发自动化程序对测试人员的编程水平有一定要求，很少有人愿意花时间去写这个程序。 对于互联网公司，大多数业务需要快速迭代，一个页面的生存周期很短，也可能只是一次性的，自动化测试没有存在的必要性。 测试人员没有切实的感受到效率提升。 其实说白了，就是大家觉得投入和产出不值得。如果是迫于领导压力要写自动化程序，就会不停的对程序修修补补，自己用的话有问题大不了不用自动化，手动测试一下通过就行，如果是给别人用就会不停收到反馈和吐槽，自然也就没有写下去的动力了。 所以个人觉得，自动化程序不应该成为一种流程和形式，而是应该由开发和测试人员自发的去将自身经常重复的工作做成自动化。因为自动化本身就不能覆盖所有场景，只有实际参与的人才能知道哪些是可以自动化的。
有哪些工具可以选择？ 目前市场上不仅提供了多种工具可以选择，还支持不同语言。 web端：selenium、webdriver、robotframework、puppeteer等。 APP端：Appium、Instrumentation、Robotium 、UIAutomator、Espresso、Calabash、Selendroid、Robolectric、RoboSpock、Cafe、Athrun等。
移动APP自动化测试框架
本文不对所有工具一一详解，可自行根据平台选择合适的工具和语言进行学习使用。只针对个别WEB端工具做简单说明。 拿selenium来说，selenium是一款很多人比较熟悉的工具，支持的语言有Python，Java，JavaScript等，推荐使用Python。而且其支持的浏览器也很全面： Google Chrome Internet Explorer 7, 8, 9, 10, 11 Firefox Safari Opera HtmlUnit phantomjs Android iOS
一些常见问题 在自动化过程中最多的就是对元素进行定位，自动化工具常见的定位符有：
id name class name tag link text partial link text xpath css selector 以上这些元素定位对于以前的网页来说还足以应对，因为以前开发的网页大多数元素会有id，class这些属性，定位起来也比较方便。但是对于react，vue，angular这类数据驱动的框架就不那么友好了。 比如有这么一个元素：&amp;lt;div&amp;gt;{{element}}&amp;lt;/div&amp;gt;结果为：
这个元素既没有id，也没有class，而且是使用最多的div元素，想要定位就很困难了。 而且这些元素定位支持也比较简单，不支持一些兄弟元素，父子元素的定位，我们以往使用的jquery选择器是不支持的。 所以这时候就体现出开发和测试配合的重要性了，开发测试不分家，开发需要根据测试需要的来对重要元素加明确的标识便于测试定位。 其次就是让自动化工具支持jquery，使用一些jquery的选择器来操作元素，使用方式是自动添加一个&amp;lt;script src=&amp;quot;jquery&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;标签。然后执行js脚本来实现jquery选择器。</description>
    </item>
    
    <item>
      <title>免费的mongodb集群</title>
      <link>https://www.yuedun.wang/blogdetail/5e8bf346bd7e796e7100a03c/</link>
      <pubDate>Tue, 07 Apr 2020 03:28:06 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e8bf346bd7e796e7100a03c/</guid>
      <description>mongodb提供了免费的mongodb集群可用于学习使用 https://www.mongodb.com/cloud 并且有3个节点 mongodb Atlas免费集群存储空间为512M，这对于个人项目来说足够使用（本博客运行6年使用空间8M）。
本地客户端连接mongo Atlas 复制了连接字符串后直接粘贴到客户端中，替换,点击From SRV,会自动拉取集群配置，点击Test测试连接是否成功。</description>
    </item>
    
    <item>
      <title>golang操作mongodb</title>
      <link>https://www.yuedun.wang/blogdetail/5e8b4742bd7e796e71009fcc/</link>
      <pubDate>Mon, 06 Apr 2020 15:14:10 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e8b4742bd7e796e71009fcc/</guid>
      <description>在之前mgo是一个使用广泛的mongodb驱动器，不过从2018年开始已不再维护，虽然觉得怪可惜的，但也不推荐使用了，毕竟mongodb本身一直在迭代，如果驱动器不更新后续也没法使用。 详细说明见仓库:https://github.com/go-mgo/mgo
而mongodb提供了官方驱动，目前能找到的中文文档大多比较旧了，推荐直接看官方文档，有完整的操作手册:https://www.mongodb.com/blog/search/golang 本文也不想做一次搬运工，毕竟也不能随时保持更新，还是直接看官方文档比较好。下面列出一些主要的文章链接:
Stack Overflow Research of 100,000 Developers Finds MongoDB is the Most Wanted Database (2019-2-2)
Official MongoDB Go Driver Now Available for Beta Testing (2019-2-2) mongodb将为go提供官方驱动支持
MongoDB Go Driver Tutorial (2019-5-30) MongoDB Go驱动程序教程
Go Migration Guide (2019-2-2) 从社区驱动（mgo）迁移到官方驱动
MongoDB Stitch Functions – The AWS re:Invent Stitch Rover Demo(2019-10-15)
Calling the MongoDB Atlas API - How to do it from Go(2019-3-18)
MongoDB Go Driver Tutorial Part 1: Connecting, Using BSON, and CRUD Operations(2019-4-23)</description>
    </item>
    
    <item>
      <title>mongodb创建新数据库和创建用户</title>
      <link>https://www.yuedun.wang/blogdetail/5e87e9ac75da9268a3e5993c/</link>
      <pubDate>Sat, 04 Apr 2020 01:58:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e87e9ac75da9268a3e5993c/</guid>
      <description>使用mongodb数据库时有这样的场景，使用可视化工具登陆了某个数据库blogs,然后又创建了数据库website,给website数据库添加用户hp_website
db.createUser( {user: &amp;#34;hp_website&amp;#34;,pwd: &amp;#34;xxxxxx&amp;#34;,roles: [ { role: &amp;#34;userAdmin&amp;#34;, db: &amp;#34;website&amp;#34; },{ role: &amp;#34;dbAdmin&amp;#34;, db: &amp;#34;website&amp;#34; },{ role: &amp;#34;dbOwner&amp;#34;, db: &amp;#34;website&amp;#34; } ]}) 退出后使用bbb-user登陆数据库bbb却发现登陆不上去。登陆aaa数据查看用户db.getUsers()显示
虽然创建了很多用户，但db值都是blogs,显然是不对的。即时使用use website后创建用户也是不对。 正确的做法是关闭数据库认证，使用不带--auth启动数据库，使用命令行来创建
use website db.createUser( {user: &amp;#34;username&amp;#34;,pwd: &amp;#34;xxxxxx&amp;#34;,roles: [ { role: &amp;#34;userAdmin&amp;#34;, db: &amp;#34;website&amp;#34; },{ role: &amp;#34;dbAdmin&amp;#34;, db: &amp;#34;website&amp;#34; },{ role: &amp;#34;dbOwner&amp;#34;, db: &amp;#34;website&amp;#34; } ]}) 这样就可以登录了。由于数据库和用户名是绑定的，只有确保用户是创建在对应数据库上才行。</description>
    </item>
    
    <item>
      <title>使用pm2一键部署多个服务</title>
      <link>https://www.yuedun.wang/blogdetail/5e85a563c9109f0f909b52bf/</link>
      <pubDate>Thu, 02 Apr 2020 08:42:11 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e85a563c9109f0f909b52bf/</guid>
      <description>pm2支持远程部署服务，创建文件ecosystem.json,内容形式如： { // Applications part &amp;#34;apps&amp;#34; : [{ &amp;#34;name&amp;#34; : &amp;#34;API&amp;#34;, &amp;#34;script&amp;#34; : &amp;#34;app.js&amp;#34;, &amp;#34;env&amp;#34;: { &amp;#34;COMMON_VARIABLE&amp;#34;: &amp;#34;true&amp;#34; }, // Environment variables injected when starting with --env production // http://pm2.keymetrics.io/docs/usage/application-declaration/#switching-to-different-environments &amp;#34;env_production&amp;#34; : { &amp;#34;NODE_ENV&amp;#34;: &amp;#34;production&amp;#34; } },{ &amp;#34;name&amp;#34; : &amp;#34;WEB&amp;#34;, &amp;#34;script&amp;#34; : &amp;#34;web.js&amp;#34; }], // 部署部分 // Here you describe each environment &amp;#34;deploy&amp;#34; : { &amp;#34;production&amp;#34; : { &amp;#34;user&amp;#34; : &amp;#34;node&amp;#34;, // 多主机配置 &amp;#34;host&amp;#34; : [&amp;#34;212.83.163.1&amp;#34;, &amp;#34;212.83.163.2&amp;#34;, &amp;#34;212.83.163.3&amp;#34;], // 服务使用的分支 &amp;#34;ref&amp;#34; : &amp;#34;origin/master&amp;#34;, // Git 仓库地址 &amp;#34;repo&amp;#34; : &amp;#34;git@github.</description>
    </item>
    
    <item>
      <title>gorm模糊查询和分页查询同时查总条数</title>
      <link>https://www.yuedun.wang/blogdetail/5e815979c9109f0f909b4cdd/</link>
      <pubDate>Mon, 30 Mar 2020 02:29:13 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e815979c9109f0f909b4cdd/</guid>
      <description>gorm概述 全功能ORM（几乎） 关联（包含一个，包含多个，属于，多对多，多种包含） Callbacks（创建/保存/更新/删除/查找之前/之后） 预加载（急加载） 事务 复合主键 SQL Builder 自动迁移 日志 可扩展，编写基于GORM回调的插件 每个功能都有测试 开发人员友好 已上支持基本满足了日常开发需要，一些基本的查询需求可以查看文档得到解决，不过文档并没有覆盖所有日常开发案例，尤其是一些组合需求，本文挑了一段常见的场景。
func (u *userService) GetuserList(offset, limit int, search User) (users []User, count int, err error) { if search.Name != &amp;#34;&amp;#34; { u.mysql = u.mysql.Where(&amp;#34;name LIKE ?&amp;#34;, search.Name+&amp;#34;%&amp;#34;) } if search.Category != &amp;#34;&amp;#34; { u.mysql = u.mysql.Where(&amp;#34;age =?&amp;#34;, search.Age) } err = u.mysql.Offset(offset).Limit(limit).Find(&amp;amp;users).Offset(-1).Limit(-1).Count(&amp;amp;count).Error return users, count, err } 这简单的一小段已经包含了gorm的模糊查询，动态条件，分页查询，数据条数。 这就是一个最常见的列表查询，列表需要支持条件查询，模糊查询，分页，从代码可以直接看到。
1.if代码是动态组装条件。
2.err = u.mysql.Offset(offset).Limit(limit).Find(&amp;amp;users).Offset(-1).Limit(-1).Count(&amp;amp;count).Error
这行代码包含了数据列表查询和数据条数。
3.有些需要注意的地方是u.mysql.Offset(offset).Limit(limit).Find(&amp;amp;users) 用于查询数据列表，</description>
    </item>
    
    <item>
      <title>go-micro线上部署，注册服务到etcd</title>
      <link>https://www.yuedun.wang/blogdetail/5e709b485bd8165f28d22394/</link>
      <pubDate>Tue, 17 Mar 2020 09:41:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e709b485bd8165f28d22394/</guid>
      <description>线上部署 在线上部署就不能使用go run main.go命令了，需要打包编译成可执行文件。 linux系统需要这样编译：GOOS=linux go build -o service main.go，就是在windows系统上进行交叉编译，可根据自己服务器情况修改参数。
go build -o service main.go go build -o api api/api.go 线上的restful api也不能使用micro api了。需要选择适合自己的web服务框架，在web服务中调用api服务。
etcd启动 线上etcd和本地启动有区别，如果etcd是单独的服务器，那么在不加任何参数的情况下直接启动，那基本是调不通的。
$ ./service --registry=etcd --registry_address=xx.xx.xx.xx:2379 2020-03-17 17:04:42 Starting [service] go.micro.srv.user 2020-03-17 17:04:42 Server [grpc] Listening on [::]:48493 2020-03-17 17:04:42 Registry [etcd] Registering node: go.micro.srv.user-f32a2950-8e59-44d4-ac86-f4e1ec103395 {&amp;#34;level&amp;#34;:&amp;#34;warn&amp;#34;,&amp;#34;ts&amp;#34;:&amp;#34;2020-03-17T17:04:47.849+0800&amp;#34;,&amp;#34;caller&amp;#34;:&amp;#34;clientv3/retry_interceptor.go:61&amp;#34;,&amp;#34;msg&amp;#34;:&amp;#34;retrying of unary invoker failed&amp;#34;,&amp;#34;target&amp;#34;:&amp;#34;endpoint://client-e45decee-12bf-4a9b-a7ab-f92eece39420/xx.xx.xx.xx:2379&amp;#34;,&amp;#34;attempt&amp;#34;:0,&amp;#34;error&amp;#34;:&amp;#34;rpc error: code = DeadlineExceeded desc = latest connection error: connection error: desc = \&amp;#34;transport: Error while dialing dial tcp xx.</description>
    </item>
    
    <item>
      <title>go-micro v2弃用了consul作为默认的服务发现</title>
      <link>https://www.yuedun.wang/blogdetail/5e6c860e5bd8165f28d2210b/</link>
      <pubDate>Sat, 14 Mar 2020 07:21:50 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e6c860e5bd8165f28d2210b/</guid>
      <description>很遗憾，go-micro v2版本不再使用consul作为服务发现中间件，官方文档也没有consul相关的文档，而是默认改用了mdns，生产推荐etcd。
问题：I can&amp;rsquo;t set registry with consul
解答：《Deprecating Consul in favour of Etcd》
超过4年的时间，Consul一直是Micro的默认服务发现系统之一，为我们提供了良好的服务。实际上，从一开始，它就是用于注册表的默认机制以及入门所需的唯一基础依赖项。
从那时起，世界在不断发展，原生云技术也在不断发展。我们发现了许多与使用Consul的方式有关的问题。这不是对Consul的打击，而是对我们的用例的反思，以及对继续前进的需求。
例如，我们将元数据和服务端点信息进行二进制编码，压缩和base64编码，然后再将它们存储为Consul标签，因为没有其他方法可以这样做。我们还非常严重地滥用Consul的分布式属性，这导致了许多关于raft共识的问题。
不幸的是，我们发现现在该继续前进了。
自2014年以来，Kubernetes真正成为了容器编排和基础服务平台中的一支计算力。因此，etcd成为了他们选择的键值存储的一种，它是基于raft共识构建的分布式键值存储。它已经发展到可以满足kubernetes的规模需求，并且已经以其他开源项目所没有的方式经过了实战测试。
Etcd还是用于二进制数据的非常标准的Get / Put / Delete存储，这意味着我们可以轻松地编码和存储服务元数据，而不会出现零问题。它对所存储数据的格式没有意见。
过去一周中，我们已将etcd迁移为Micro中的默认服务发现机制之一，并将在未来几周内弃用Consul。这是什么意思？好吧，我们将领事移交给我们社区维护的go-plugins存储库，并专注于支持etcd。
我们知道许多用户正在使用Consul，这可能会导致中断。对我们来说，这是通往v2的重大突破，因此我们的下一个发行版将被标记为v2。您可以放心，您的v1发行版将继续按原样运行，但希望我们发布的下一个发行版是micro v2.0.0。
参考项目：micro-service</description>
    </item>
    
    <item>
      <title>windows调整C盘大小</title>
      <link>https://www.yuedun.wang/blogdetail/5e38ea905bd8165f28d1fc55/</link>
      <pubDate>Tue, 04 Feb 2020 03:52:48 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e38ea905bd8165f28d1fc55/</guid>
      <description>新买的windows笔记本一般会对磁盘进行分区，虽然有说法是现代电脑没必要分区，不过目前很多人还是有这样的习惯。 然而我们往往低估了软件的吃磁盘能力，会把C盘设置50G左右的大小，觉得C盘只是装个系统而已，会自觉把软件装到其他盘下，结果就是没用几个月C盘就满了。其实，虽然我们把软件装到了其他盘，但是软件本身会下载很多内容，比如数据保存，缓存，默认下载等等都会占用C盘。所以建议C盘设置100G比较合理。 关于已经分配好大小的磁盘也可以进行调整，需要借助一些软件来操作，本文作者使用的是Diskgenius。
很简单的三个步骤：
选择需要扩容的磁盘右击“扩容分区” 选择缩容的磁盘，用于将缩容的磁盘分配给C盘。 选择需要缩容的大小。 确认开始大约需要十几分钟就可以了。</description>
    </item>
    
    <item>
      <title>beego httplib库使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/5e216204567cde49c49187f1/</link>
      <pubDate>Thu, 16 Jan 2020 14:28:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e216204567cde49c49187f1/</guid>
      <description>beego是一个优秀的api，web框架，不只是其丰富的功能特性，更是因为其功能的独立性，可以根据自身需要单独添加使用。 常用的模块有以下这些：
session 模块 cache 模块 logs 模块 httplib 模块 context 模块 toolbox 模块 config 模块 i18n 模块 本文要讲解的是httplib客户端请求的使用。
日常开发中不只是要接收请求，还会发起http请求，go本身提供了http库可以实现http请求，不过使用起来略微复杂一些。如果使用的框架是beego的话，那推荐使用httplib。
基本使用方法 import ( &amp;#34;github.com/astaxie/beego/httplib&amp;#34; ) 然后初始化请求方法，返回对象
req := httplib.Get(&amp;#34;http://beego.me/&amp;#34;) 然后我们就可以获取数据了
str, err := req.String() if err != nil { t.Fatal(err) } fmt.Println(str) 以上是最基本的使用方法，更多文档可以查看httplib文档，本文不再做一次搬运工。 下面提供一些使用实例以供参考：
获取body信息 func RequestByAjax3(region, language string) { req := httplib.Get(fmt.Sprintf(&amp;#34;https://m.lagou.com/search.json?city=%s&amp;amp;positionName=%s&amp;amp;pageNo=1&amp;amp;pageSize=1&amp;#34;, url.QueryEscape(region), language)) req.Header(&amp;#34;Referer&amp;#34;, &amp;#34;https://m.lagou.com/search.html&amp;#34;) req.Header(&amp;#34;Cookie&amp;#34;, &amp;#34;JSESSIONID=ABAAAECAAHHAAFD8DC17DEB3DE2DF3C5FCAE8C3D4423759; user_trace_token=20200117101405-234d1d57-b8c1-4d66-956e-c49f35f28f75; LGSID=20200117101406-09c6fa83-38cf-11ea-b2e7-525400f775ce; PRE_LAND=https%3A%2F%2Fm.lagou.com%2Fsearch.html; LGUID=20200117101406-09c6fc06-38cf-11ea-b2e7-525400f775ce; X_HTTP_TOKEN=8e6e6bd15763030e425822975149ec77fc62d73ec7;&amp;#34;) req.Header(&amp;#34;Host&amp;#34;, &amp;#34;m.lagou.com&amp;#34;) req.Header(&amp;#34;User-Agent&amp;#34;, &amp;#34;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.</description>
    </item>
    
    <item>
      <title>“中台”是架构的捷径吗？</title>
      <link>https://www.yuedun.wang/blogdetail/5e183a7a54cf7f406dcb28f5/</link>
      <pubDate>Fri, 10 Jan 2020 08:48:58 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e183a7a54cf7f406dcb28f5/</guid>
      <description>由于“中台”概念的推动，关心业务架构的读者越来越多，很多企业也对实施“中台”、“中台”方法论趋之若鹜。历史总是相似的，之前无论 SOA、微服务、DDD，还是敏捷开发、双模开发等热门技术概念出现时，都曾经给大家燃起“捷径”的希望。 然而，最终还是证明了软件领域没有“银弹”，很多时候，反倒是应了北欧的一句民谚：捷径是迷路的最快方法。 架构没有捷径，无论从架构的设计、架构的落地还是架构的学习方面来讲，都是如此。
1.架构设计没有捷径 架构设计如同求医问诊，必须对症下药。盲目相信任何已有架构设计成果都是很危险且极不负责任的。每个人的身体都各有特点，企业也是如此，而企业级转型、企业级工程是对企业现有能力的最大调整，需要企业在认清自己的基础上进行，任何忽略“向内看”过程的架构设计，都是为今后的混乱，甚至失败埋下伏笔。 对于复杂手术，不经过详细的诊断，不经过对术式反复揣摩，医生不会轻易为患者开刀，否则，不啻于用生命做试验。软件工程虽然少有“人命关天”的事情，但是，浪费时间也等同于浪费生命。
没有为企业做过深入“体检”而轻易相信“领先实践”，很容易把在架构设计上节省的时间和精力，加倍“奉还”到实施过程中去。
企业级架构设计往往给人以过于漫长、难以响应变化的印象，但是，人们恰恰忽略了由此带来的架构认知的积累，以及由量变到质变的过程。 当人们感慨一次“传统”的企业级业务架构设计方式可能耗时一到两年，而互联网时代非常追逐“快”时，其实并没有充分意识到，互联网企业的架构，比如阿里的“中台”也经历了十余年的积淀，而且十余年的积淀也还只是理清了一个方向，不然也不会有今日对“中台”概念的众说纷纭。 互联网架构并不代表架构设计上有“捷径”，反而证明了，任何“快”都来自于自身的积累，是充分“向内看”才有了外在的“快”。“快”源自对业务的深刻理解，“中台”对公共能力的沉淀正是来自于对业务能力的归纳和提炼，所以阿里才十分重视业务架构师的培养，而对“中台”的探索绝不仅限于对公共能力的沉淀，最终会上升到对企业整体、对何为业务经营的认识，这是一个自然的过程。 笔者在最近与原阿里中台核心架构师毗卢老师的交流中了解到，他们在进行中台设计时也在反复思考技术要努力支持业务经营的快速变化。
那业务经营到底是什么？其实，大家关注的问题从领域级逐步上升到企业级之后，是一定会思考到底企业是什么、企业如何运转这些问题的。
互联网架构并非简单地快速试错，这种试错是对业务选择能力的支持，而从技术视角看，则是对架构能力的不断提炼，是架构的强大才有了快速设计的可能。 所以，架构设计没有捷径，唯有积累，通过积累提高了对企业自身的了解、对架构设计的驾驭能力，才有了可以快的“资本”。
此处，还得再说一次前边提到的北欧民谚：捷径是迷路的最快方法，无论是企业还是个人，切换架构设计方法前，都要对学习曲线有深刻的认识，否则，当别人在原来的方向上越走越远时，你可能还是在原地打转，只不过为别人提供了案例。
笔者 2019 年在公司负责搭建风险管理体系，而该项工作再次让我认识到，架构不是可以“抄”的。
风险管理是个很成熟的领域了，三道防线的体系设计方式，无论是金融企业还是科技企业、无论是国内企业还是国外企业都在使用，但是，你却无法直接把其他企业的防线设计简单套用过来，必须一个工作事项一个工作事项地分析自己企业的流程，确认风险点，确认工作事项的负责团队，落实具体的风控职责，之后，再考虑风控措施是否可以实现“机控”，而这一切又取决于该工作事项是否已经线上化。 这样才能形成一个与实际工作环境相符，并融合数字化风控方向的全面风险管理体系。这种深入细节的体系建设无法通过照搬任何现成经验来获得，否则会出现“削足适履”的情况。没有“捷径”，只有“路径”。
2.架构落地没有捷径 经常有读者好奇企业级业务架构设计如何落地，笔者在书中、在 2019 年 12 月南京的中台大会上都直言，企业级业务架构设计的落地过程没有任何神秘和特殊，也不该有，今天笔者认为企业级业务架构日益重要，并不是因为它有什么落地的捷径，任何架构设计的落地过程都是靠一个逻辑一个逻辑、一个模块一个模块地实现的。 企业级业务架构设计只是让业务端的整理更加的结构化、整体化了，不同于需求分析对局部细节的关注，也不同于产品分析的领域性特点，企业级业务架构关注的是企业能力的整体规划和结构化表达，但它并不意味着在实现层面有何特殊性，它只是提供了软件过程中的一个“指挥棒”，通过业务架构设计形成对软件功能划分的指导。 而更重要的是，通过业务和技术都能理解的业务架构模型，使企业内部形成可以交流、甚至可以跨领域交流的“共同语言”。
这个“指挥棒”对于提升企业的整体性而言是必不可少的，管理学上一直在研究如何让企业内部形成管理合力。
业务架构诞生初期，在上个世纪 80-90 年代，企业的信息化程度还不如今日这么高，业务和技术的深度融合还没有受到应用的重视，但是今天，淘宝、滴滴、美团、头条等跨界竞争者给传统行业的原有企业造成了极大的竞争压力，乃至很多人都认同未来企业大部分都将转型为科技企业，工行的领导者最近也发表了此类言论。 由此可见，加强业务与技术的深度融合已经十分必要了，而业务架构正是符合这种时代要求的工具，赋予企业清晰的能力视图，清晰的结构加上架构的演进，就可能会不断提升架构的弹性。 企业管理经常追求韧性，常说希望企业能够像拧毛巾一样，越拧越紧却不会拧断，而未来，鉴于企业都具有科技属性，这样的“韧性”可能就要来自于架构的“弹性”了。 提升企业的整体性犹如进行马拉松训练，业务架构虽然提供了一个有力的工具，但是马拉松还是得依靠训练者一步一步地跑完，成绩的提升完全取决于训练者自身的能力和毅力。
回到软件工程上，架构落地即便是采用敏捷过程，也不意味着靠的是什么“捷径”，而只是对工程组织方式的改进和对效率的追求。
笔者近日阅读了《敏捷革命》一书，与广为流传的“敏捷价值观”相比，敏捷方法的原创者其实更在意的是如何通过信息的充分获取与共享、良好的思维模型，以短周期的方式迅速提供核心价值，从而降低项目周期过长导致的项目失败风险，通过多轮短周期的可控“冲刺”替代长周期的不可控过程。
原创者非常推崇 OODA 原则，也就是飞行员训练中采用的**“观察 - 导向 - 决定 - 行动”模式**，其实每一次敏捷的 Scrum 中都体现了这一思想。 “观察”代表了对全面信息的迅速获取；“导向”是依靠思维模型进行快速分析，也就是快速的设计过程；“决定”就是确定结论，不再犹豫，“行动”就是将决定付诸实现。 原创者在书中也强调一个 Scrum 内，需求确定后就尽可能不动，这与飞行员的“决定”、“行动”的模式一样，因为空战时间太短了，几乎没有后悔重来的机会。 敏捷方法原创者十分推崇丰田的生产方式，笔者恰好最近也读了《新乡重夫谈丰田生产方式》一书。丰田的生产方式，又称“精益生产”、“Just-in-time”，是对拒绝“浪费”的极致追求，这个浪费指的不是原材料的浪费，而对是时间、效率的浪费。 比如，丰田在思考原材料在不同生产场地间搬运造成的浪费时，首先的解决思路是如何做到不搬运，通过这种思考去调整生产环境；再比如，在反思如何提高打磨零件毛刺工作的效率时，采用了引入欧洲真空加工技术，让零件根本不产生毛刺的方法。
诸如此类的例子还有很多，正是通过这种对点滴效率提升的持续近 20 年的不断追求，才最终打造出丰田生产方式。
任何方法的形成都是一个长期积累和反思的过程，而应用这些方法也需要使用者付出合理的努力加以掌握，架构设计的落地说到底是软件工程问题，没有捷径，只有持之以恒的效率提升。无论是给予敏捷方法原创者灵感的丰田生产方式，还是敏捷方法原创者自己的实践历程，都是一个对方法持续改进、日益精熟的过程。 没有真正理解方法之前，根本谈不上效率，与其总是在方法之间换来换去地求“快”，不如真把自己已有的功夫练到极致，只要解决问题的效率高，你自己就是“一派”。“四万八千法门”都能成佛，能够在修炼过程中“博采众长”就更好了，其实敏捷方法的原创者也正是这样创立敏捷方法的。
3架构学习没有捷径 没有成为架构师的捷径，只有勤学苦练。架构的学习需要很多基础性工作，需要很广泛的涉猎，这方面笔者在《六方面学习，帮你走上业务架构师之路》一文中有所介绍，在架构能力、流程优化、建模技术、软件过程、编程语言、整体思维方面，都有很多知识需要学习，也列出了一些参考书目，此处不再赘述。 无论是哪一种架构师，都需要深厚的积累，架构师都是项目堆出来的。 不可否认的是，互联网企业架构师成长确实很快，这也许是企业机制提供了更多的考验机会给适任者，使其能够快速进步。如果说培养架构师有什么勉强可以称之为“捷径”的方法，对企业而言，就是认真思考下自己是否建立了快速发现人才、培养人才的机制吧，否则，阿里说过了，业务架构师只能自己培养，没有合适的人才是什么也干不成的。 最近在一部《Doctor X》的连续剧中，医术高超的女主角在一场难度极高的手术中，说了这样一段话：“就像河水流淌一样，反复的基本技巧，就能创造出美丽的最终术野，那就是理想的手术……最重要的是，不管手术再艰难，也不能抛弃患者”，笔者想，这也同样适用于架构领域吧。 架构没有捷径，有的只是前人的肩膀，努力学习，积极实践，消化理解，真正站在前人的肩膀上，才可能看到前进的方向，而前人的肩膀也不仅限于你所从事的行业。</description>
    </item>
    
    <item>
      <title>win10资源管理器窗口标题栏设置颜色</title>
      <link>https://www.yuedun.wang/blogdetail/5e12c9fd54cf7f406dcb2896/</link>
      <pubDate>Mon, 06 Jan 2020 05:47:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e12c9fd54cf7f406dcb2896/</guid>
      <description>用过win10应该遇到过下图这个问题：
当你想拖动窗口的时候都不知道鼠标该放在哪里，窗口标题栏和网页颜色融为一体了。
设置颜色方法：桌面-右击-个性化</description>
    </item>
    
    <item>
      <title>胡同里遇鬼</title>
      <link>https://www.yuedun.wang/blogdetail/5e05e7dc54cf7f406dcb2800/</link>
      <pubDate>Fri, 27 Dec 2019 11:15:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5e05e7dc54cf7f406dcb2800/</guid>
      <description>传说回秧后的第二天，就会在地面上出现脚印，有梅花样的，那是猫爪神押回来的，有鸡爪鸭爪的，通通叫鸟脚神。大家说着，李道爷没有说话，而是领着大伙，顺着脚印往前走，走着走着脚印朝黄花观而去，李道爷一看，嘴里说道：“坏了坏了，我吃饭的水缸，看样子是不能再用了。”
说完就拄着拐杖，顺着脚印，朝自己的道观疾走，我跟在李道爷的身后，到了道观，此时的道观，已经经历了几百年，好几个朝代，没有了当年的辉煌，东西配殿早就塌了，只剩下大殿。我们到了道观的院子，看见脚印一直通向李道爷门口的大水缸。开始的时候说过，我们那时候，没有自来水，甚至没有压水井，都是在井里担水吃，李道爷吃的水是周围善男信女帮着挑的，所以水缸特别的大，大家看着水缸，没有谁敢过去，李道爷跑到水缸前，用拐杖敲着水缸说：“你们这些人，赶紧的把这尸体捞出来，哎呀，这下子可恶心死老道我了，我这还咋吃水？”
大伙没有谁敢过去，这时二怪拉着我说：“哥，哥，我们过去看看尸煞。”
说完拉着我就往前走，我们到了大缸前，那大缸和我差不多高，我们看不到里面，幸好在旁边有石台子，我们站在石台子上，朝着缸里看，由于是黑天，只看见缸里飘着一个死尸非常的粗大，但是看不清楚面目，我看见那水里的尸体，不由的打了一个寒颤，想赶紧的跑，可是大伙看我们没有什么危险，直接都围过来，我再想走，已经走不出去了。
大家手里有手电，有火把，一下子把水缸照的亮如白昼，这时我才算看清楚，缸里正是那个尸煞，此时的尸煞在水里一动不动，像是死了一般，其实本来就是死了，不动很正常，我们正在看的时候，忽然缸的前面响起了凄厉的哭声，我一看是巧儿姐的娘，只见她掐着脚脖子哇哇大哭，这时庄上几个上了年纪的老人走过来，让大伙都离远一点，特别是年轻人，更不准靠前，他们准备把尸体弄出来。
有人抱来一床新芦席，用铁锹铲破四角，铺在地上，然后他们就把尸体从水缸里捞出来，放在席子上，头南脚北，尸煞由于被水泡了，比一般的尸体都大，再看看那双脚，当时差点吓的我魂飞魄散，只见那双脚已经被石灰烧烂了，上面的腐肉脱落，露出森森的白骨，撑开的脚掌，和那脚印一般的模样。我感觉自己的脊背发凉，头上冒冷汗，二怪也吓的不行，在那里身子直抖，我拉着二怪就跑。
我和二怪跑到古槐树底下，那颗古槐里面已经空心了，只剩下外边的一层树干，从树下可以直接钻到顶上去。我们过了老槐树，就往家里走。那时候的农村不像现在，除了庄上几条长走的路宽些，其他的都是幽深的小巷，两米多宽就算是宽的了，小巷的两边都是房子，树木参天，大白天都阴森森的，晚上更是漆黑。
我和二怪走在小巷里，快要到巧儿家的时候，忽然二怪说：“哥，哥先别走，前面有一个人在哭。”
我一听赶紧的往前看，巧儿家的门口点着一堆火，在火光的照耀下隐隐约约的有人影，那个人影，面朝着墙，哭声悲悲切切的好不凄凉。我看着那人影说：“这哭声没准是咱大娘的。”
二怪说：“不像，你听哭的那么凄惨，会不会是鬼？”
我说：“你都能看见的，肯定不是鬼，要是鬼的话，只有我这样的阴阳眼才能看到。”
二怪说：“哥，你说的对，要是人哭的话，咱们过去看看。”
说着我们往前走，走到那个人影的跟前，人影看到我们来了，赶紧往黑窟里站了站，然后在那里继续抽泣，声音有点怪异，这时二怪小声的说：“哥，这好像是故意吓唬咱们的，咱们问问是谁。”
说完之后，就大声的朝着人影说：“谁，你是谁？”
可是那个人影好像没有听见一样，又朝黑窟里站了站，让我们看不清楚到底是谁，我一看到这里，当时从地上摸起一块石头，大声的说：“你到底是谁？再不说话，我揍你了。”
我说完举起手里的石头，佯装要砸过去，这时那个人影开始慢慢的转头，在转头的时候，刮起一阵阴风，火光一下子变成了惨绿色，好像没有了一点热量，当那个人转过来的时候，我一下子愣住了，这不是巧儿姐吗？我正在愣神的时候，二怪大叫一声，“鬼呀。”
我一下子惊醒，拉着二怪就跑，我们朝着来时的方向跑，想跑回黄花观，那里的人多，鬼肯定不会到那里去。我和二怪两个人，此时顾不得脚下的石头，一个劲的跑，眼看就要跑到胡同的尽头了，忽然前面传来凄惨的哭泣声，我们往前一看，连死的心都有了，只见在不远处，不知什么时候，多了一个人影，那个人影对着墙，在那里慢慢的抽泣，不用说那人影是巧儿的鬼魂，看样子她不知什么时候到了我们的前面了。
我和二怪当时刹住，幸亏那时候腿短，没有直接摔到，我们两个人一转身再往后跑，一边跑我们一边喊着救命。此时整个胡同里的人，都跑到黄花观那里看热闹了，根本没有人救我们，当我们跑到胡同的尽头，发现巧儿又不知什么时候出现在另一头的胡同口，还是那样对着墙抽泣着。
就这样我们不知跑了几趟，都快累的不行了，一边跑一边伸着舌头，至于为什么伸舌头，这是比我们大的小孩，教给我们的方法，说伸着舌头跑不累，我们当时不信，他就指着狗说，狗舌头就伸着，所以狗比人能跑，不信你们撵狗试试，我们试了试后来还就真信了。
当我们伸着舌头，精疲力尽的跑到胡同口的时候，那哭泣的巧儿又出现在胡同口，这回我们真的跑不动了，两个人靠着另一面墙喘成了狗。
我喘了一会拉着二怪说：“弟弟咱们赶紧再跑。”
二怪伸着舌头说：“哥，我们不能再跑了，再跑，非、非累死不可。”
我说：“那怎么办？”
二怪弯着腰，捂着胸口喘着说：“哥，我喘匀了气，自有办法对付她。”
说完之后二怪继续大口大口的喘气，我也在那里喘着，一时顾不得害怕了。巧儿的鬼魂还在那里哭泣，等我们喘的差不多了，二怪对我说：“哥你在这里等着，我过去对付她。”
真想不到二怪还有对付鬼的本事，我拉着二怪说：“兄弟你要小心点。”
二怪说：“哥你就放心吧，我过去了。”
说完之后二怪慢慢的朝着巧儿走去，这时巧儿转过头来，用那双闪着绿光的眼睛，死死的盯着二怪。
这时的二怪在我的眼里，忽然高大了许多，只见二怪走到离巧儿鬼魂的不远处，做出了一个令我意想不到的动作，只见他膝盖一弯，直接给巧儿的鬼魂跪下了，二怪一边磕头一边说：“巧儿姐，巧儿姐，你饶了我吧，你要带走的是我哥，和我一点关系都没有，我这么小，干瘦干瘦的，带回去也没有什么用。”
我一听鼻子都气歪了，没有骨气的家伙，这么就当了叛徒，我心里义愤填膺，顾不得那么多了，做人就得以牙还牙，大丈夫膝下有黄金，这个时候不跪什么时候跪？于是我也走了过去，一下子跪在巧儿鬼魂的面前，对巧儿说：“巧儿姐，你带谁走都一样，干脆就把二怪带走吧，等你上来以后，我一定让我大爷给你扎金山银山，金童玉女。摇钱树，纸牛纸马。”
二怪听了之后赶紧说：“我也让大爷给你扎那些东西。”
我生气的说：“那个是我大爷，不是你大爷，不给你扎。”
二怪说：“我爹有钱，给你大爷钱你大爷就给扎。”
我们那时候小，经常为鸡毛蒜皮的事情争论，他在我家吃了什么，我在他家拿了什么，两个人能算一上午的糊涂账，最后算到谁也不欠谁的，我们因为是谁大爷，一句不合争论起来，直接把巧儿的鬼魂，晒到了一边，不知道这算不算藐视？我们两个正在争论，巧儿的鬼魂受不了了，大叫一声，“你们两个小黄黄给我住嘴，我还要说正事。”
那声音非常的凄厉，把我们两个一下子吓的不敢吱声了，这时巧儿指着我们说：“你们两个，我谁也不带走，你们现在赶紧的去找李道爷，让李道爷给我叫魂，把我叫回我的身体，快，一旦五更鸡叫，我就得重新回水塘。”
我们两个都听愣了，不知道该怎么办，巧儿一看我们两个傻愣的跪着不走，就大声的说：“快去，跪着干什么，再不去就来不及了。”
我们都被凄厉的声音吓傻了，哪还知道跑，这时巧儿忽然尖声说道：“你们再不走，我就把你们吃了。”
说完一抹脸，那张脸当时变成了一张巨脸，两只大眼睛闪着绿光，如同铜铃一样，张着大嘴，嘴巴一直裂到两个耳朵根，张开双手朝我们抓来，那双手指如同刀子一样锋利，闪着瘆人的寒光，我看到这些，知道再不走就晚了，身子一下子蹦起来，拉着二怪，转身就跑，我们一口气跑回了黄花观，两个人疯一般的扒开人群，钻了进去，顾不得对尸煞的害怕，跑到李道爷的跟前，弯着腰在那里大口大口的喘着粗气，我一边喘气，一边捂着肚子说：“道、道爷，那，那巧儿，巧儿姐的鬼魂……”
我说的有点急，呛的我一阵咳嗽，李道爷赶紧的过来，给我捶背，让我慢慢的说，我使劲喘了几口气，然后就断断续续的把事情的经过说了一遍，李道爷一听，在那里拍拍脑袋说：“忘了，忘了，这尸煞只是没有灵魂的躯体，我们就是葬了，也替不出巧儿的灵魂，赶紧，赶紧的设法坛，我要给巧儿叫魂，让巧儿的魂魄，回到自己的躯体里来。”
说完之后，让人安桌子摆法坛，然后进屋穿上那身要饭的衣服，拿来了七星宝剑，临时用白纸做了两个招魂幡，在巧儿的头前放了一碗白米饭，一双筷子插在上面，这个是给死人吃的倒头饭，我们这里吃米饭最忌讳的就是把筷子插在米饭上，如果来山东鲁南做客的话，这个禁忌一定不能犯，要是来走亲戚的新女婿，犯一次这样的错误，亲事就得玩完。
弄好了这一切之后，李道爷又跳了一段舞动宝剑的舞蹈，然后用宝剑粘起一张黄纸符，放在蜡烛上点着，烧完之后，拿起三清铃，一边摇晃一边念念有词的如同唱歌一样，三清铃为道士作法事中的重要法器。又名帝钟、法钟、法铃、铃书。一般高约二十厘米，口径约九厘米，用黄铜制造，有柄、铃内有舌。僵尸最怕三清铃，凡是僵尸听到三清铃，都会害怕，不敢近前，有些道士想除掉僵尸，就手持三清铃，趁着僵尸出巢穴，守在僵尸的巢穴入口，使劲的摇动三清铃，僵尸不敢近前，一旦五更天亮，僵尸见日光，就会直接完蛋，到时候烈火焚烧就可以了。
李道爷摇着三清铃，高唱道：“荡荡游魂，何处留存三魂早降，七魄来临，河边野处庙宇村庄，宫廷牢狱，坟墓山林，虚惊怪异，走散阴魂，今请山神，五道游路将军，当方土地，家宅灶君，吾进差役，着意收寻，收魂附体，葬在阴宅，魂魄来兮，魂魄来兮……”
念了一会之后，对着大伙说：“魂魄归来，活人让道，阴阳不同路，切勿挡阴人。”
李道爷这么一说，堵在门口看热闹的这些人都吓坏了，赶紧的让路，一个劲的往两边挤，顿时人仰马翻的，小孩哭大人叫，李道爷看到这里说：“切勿大声喧哗，惊动阴人。”
大伙一听赶紧的闭嘴，一个个紧张的看着，就在这时起来阴风，招魂幡随风飘动，十分的诡异，一对白蜡烛，当时变的有豆粒大小，放出惨白的光芒，我听见风声中夹杂着哭号的声音，慢慢的由远而近，朝我们这里而来，那声音正是巧儿的声音，我赶紧朝门外看，只见飘来一个人影，飘飘渺渺的朝尸体这里而来。
这些只有我和二怪能看到，其他的人看不到，不过他们虽然看不到，但能感受到阵阵阴风，一个个的使劲的后缩，二怪紧紧的靠着我，身子不住的抖，要不是看在我和他好的份上，我真想揍他一顿，这个小子没有骨气，关键时刻把我卖了。
这时巧儿的阴魂越来越近，我和巧儿的阴魂数次相遇，还差点丢了小命，早就吓破了胆，顾不得倚在我身边发抖的二怪，赶紧朝李道爷跟前靠，李道爷没有理我，只是在那里念念有词，嘴里说着什么，这时巧儿已经到了自己的尸首前，朝我一笑，这一笑虽然没有什么恶意，还是把我吓了一跳，我这次胆子大了些，没有吓尿裤子，巧儿笑完了，好像说了句谢谢弟弟，回来真好的话，然后就一下子附在地上的尸体上，消失的无影无踪了。
这时李道爷停止摇动三清铃，擦了擦额头上的汗，嘴里说道：“回来了，回来了。”
李道爷正说着，巧儿的娘过来了，对李道爷说：“道爷你是说巧儿的魂魄回来了吗？”
李道爷点点头，说：“是呀，历尽艰辛，总算是回来了，这回不用再受水淹冰寒之苦，也不用再找替身了。”
巧儿的娘听完之后，当时哭着就要扑过去，李道爷拉住巧儿的娘说：“如今阴魂新入身体，身上带着煞气，你这贸然扑过去，身体上带的阳气太重，和鬼气相冲，要是反扑着你，可就麻烦了。”
桥二娘一听，止住哭声说：“道爷您说怎么办？我苦命的巧儿呀，实在是太可怜了。”
李道爷也叹了口气说：“这都是她的命，你就别太伤心了，我这就给她除秧。”
说着话，拿起朱砂笔，在一张黄纸上，写了一长串字，然后走到尸体旁，大声的说道：“天圆地方律令九章，吾今下镇殃煞消亡。万鬼潜藏家宅永昌，吉星高照人口安康。太上老君急急如律令。”</description>
    </item>
    
    <item>
      <title> 一次商业web网站搭建的取舍过程</title>
      <link>https://www.yuedun.wang/blogdetail/5df30ce58803fb4044fa0651/</link>
      <pubDate>Fri, 13 Dec 2019 04:00:37 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5df30ce58803fb4044fa0651/</guid>
      <description>最近为公司官网重构搭建项目，把遇到的问题总结一下。此处的“商业”并没有多神秘，说的有点夸张而已，不过是为了区分公司项目与个人项目罢了。在这之前，我自己搭建过的网站也不下于10个，其中有个人网站也有公司网站，那时候搭建的网站也能上线运行，也没有过多的条件限制，所以不会有什么纠结的地方。
所以搭建一个网站并不复杂，复杂的是让其满足很多要求。有业务需求，有领导喜好，有同事对技术的接受度。业务说网站要支持SEO，支持IE浏览器，领导说我们要前后端分离，同事说我想使用主流新技术。最后经过几轮商讨下来自然是业务第一，领导第二，同事第三的优先级进行选择了。
要支持SEO和IE浏览器，只能是服务端渲染，可选的技术就只有SSR和模板引擎。SSR能选择的也就同事熟悉的Vue技术栈nuxtjs，但是其只能首屏渲染，并不能完全满足整站的SEO需求，而且开发体验并不怎么好，编译时间长，调试难，占用内存高等缺点。最后只能选择一把刷技术jQuery和node模板引擎。
选择了jQuery和模板引擎还不够，前端的模块化怎么做？目前前端模块化方案还是少的可怜，但并不是没有好的方案，只是在技术潮流下显得有点暗淡失色。比如requirejs，seajs，fis等都可以做模块化，~~最后在内心斗争一番后选择了layui自带的模块化（主要是使用了这一套UI）。layui本身是一套UI框架，为了尽量减少引入第三方js就直接使用其提供的模块化。~~原网站使用的是fis3也很好，但是如果继续使用的话等于又回去了，而且fis3也不再维护了。好在改造难度不大，只需要重新包装一下即可，其实fis3最后生成的代码也是类似于AMD/CMD规范。
技术方案确定后就剩开发环境工程问题了，由于一些老项目的缘故，前端同事都习惯了使用less开发css，也需要引入。然后是公司项目不同于个人项目具有服务器完全管理权限，通常使用NGINX代理，这样会对前端文件进行缓存，而网站发布频率较大，前端文件变化了还有缓存，所以又需要对前端文件进行哈希处理，这样就有了编译过程，同时还有node服务需要同时运行，所以使用了gulp工作流。后续补充：layui在开发过程中没啥问题，但是要上线时对静态文件哈希处理不好，最终也放弃了,回归了最原始的开发方式。
这样一顿操作下来也耗时一周才完成，远比搭建个人项目一天内费事多了。</description>
    </item>
    
    <item>
      <title>linux安装nodejs——快捷版</title>
      <link>https://www.yuedun.wang/blogdetail/5dd2378b00f24e1fd556d0c4/</link>
      <pubDate>Mon, 18 Nov 2019 06:17:47 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5dd2378b00f24e1fd556d0c4/</guid>
      <description>前面写过一篇linux下安装nodejs，不过这种方式安装有弊端，首先就是安装过程复杂漫长，容易出错，且不易升级。这次展示的是简单易操作的方式。
wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh nvm install 10 nvm use 10 好了，只需3行命令即可，其原理是先安装nodejs版本管理工具nvm，通过nvm来安装和管理nodejs，这样就一举两得，既安装了nodejs，还可以方便升级，至于nvm的使用方法大家使用nvm -h即可查看，不再细说。
另外，如果对nodejs有深度使用的话，建议直接安装alinode,方便以后做性能监控，安装方法和上面一样简单。
wget -O- https://raw.githubusercontent.com/aliyun-node/tnvm/master/install.sh | bash source ~/.bashrc # tnvm ls-remote alinode 查看需要的版本 tnvm install alinode-v3.11.4 # 安装需要的版本 tnvm use alinode-v3.11.4 # 使用需要的版本 如果后面有性能监控需要，可以查看官网帮助文件进行下一步操作。 alinode</description>
    </item>
    
    <item>
      <title>让代码配置化</title>
      <link>https://www.yuedun.wang/blogdetail/5db03db400f24e1fd556cec4/</link>
      <pubDate>Wed, 23 Oct 2019 11:47:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5db03db400f24e1fd556cec4/</guid>
      <description>背景 面对运营频繁的页面修改，每次都是换个图，改个字，要么就是在现有的页面基础上新做一个，再稍微的改点东西，虽然这种需求做起来也不是很费事，但也架不住一天一次修改（有点夸张，但的确很多）。日积月累，就开发出很多相似页面，大多数都用作abtest，在众多页面中选出个别页面，其他页面只能被打入冷宫，永远没有访问的机会。显然这些页面留在项目中额外增加了打包编译负担，甚至拖累其他页面速度。
原来 日常开发流程是这样的：
开发 -&amp;gt; 合代码 -&amp;gt; 上测试环境 -&amp;gt; 测试 -&amp;gt; 合代码 -&amp;gt; 上uat环境 -&amp;gt; 测试 -&amp;gt; 合代码 -&amp;gt; 提发布申请 -&amp;gt; 发布 -&amp;gt; 验收
就算是一个3分钟搞定的需求，流程也需要1天，因为中间有太多的环境切换和人员流转。
这样的经历所有做过运营活动的童鞋或多或少都有体验，所以很多人也想过做一个编辑器，比如拖拉组件的方式实现一个页面。
我们曾经有种设想是直接给运营做一个活动编辑器，让他们自己去修改，自己去做页面，自己发布。说实话这个也做过，但是没用起来，原因呢大概就是人性的贪婪与懒惰，当初做出第一版的时候觉得太简单，不能满足使用需求，第二版的时候功能倒是挺丰富，但是运营又不会用。想想那么多css样式，你以为图形化了他们就会用？太天真！干脆教他们写代码好了！
现在 所以这个项目就夭折了。本文演示的是一个将代码配置化的平台。期望解决的是代码冗余，但同时也有效率的提升。 这个平台最终流程变成了这样：
开发 -&amp;gt; 测试 -&amp;gt; 发布 -&amp;gt; 验收
是的，由原来的11步直接变成了4步，其中开发和发布也比原来更简单了，你可以选择自己喜欢的编辑方式和开发框架，或vscode，或devtool,或工具提供的文本框，或jquery，或vue。可单独对css，js，html修改，将修改的内容直接提交即可看到效果。 为什么会减少这么多？因为没有了测试环境和uat环境的流转，直接在生产环境操作的。
是不是会有疑问——直接在生产环境开发会不会有风险？ 答案是：不会！项目本身是分为两个环境，一个是开发环境，另一个是访问环境。开发环境是用于内部开发和测试使用，不对外开放，只有发布后才将开发数据同步到公开环境。
上图展示的是一个示例程序，提供一种思路，可根据自己需求开发相应功能。比如支持多环境发布，回滚，都可以做到点个按钮就行，不需要等待编译和重启等耗时。因为开发完成后的一切操作都是数据的操作，并不会涉及到编译，所以无论是发布还是回滚都是毫秒完成。 这种做法适合频繁修改的页面，万年不变的页面就不需要这样做了。
核心思想 这个项目的核心思想是将代码做成配置，我们都喜欢做配置平台，让业务来操作数据省去了修改代码，为什么不可以将代码也做成配置？</description>
    </item>
    
    <item>
      <title>再坚持一下，你的奶茶店马上破产</title>
      <link>https://www.yuedun.wang/blogdetail/5d81a71a00f24e1fd556cc25/</link>
      <pubDate>Tue, 17 Sep 2019 15:40:10 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5d81a71a00f24e1fd556cc25/</guid>
      <description>1 这两天我看后台后台的时候，发现有几个朋友再问我能不能加盟瑞幸咖啡，能不能赚到钱。
当时我是很迷惑的，因为据我所知瑞幸咖啡从来就没有开放加盟，网上所有挂着瑞幸咖啡加盟旗号的人都是各种沙雕骗子，可能是端幸咖啡。后来我一问，说的不是瑞幸咖啡，是财报上增长亮眼的小鹿茶进行了品牌独立，正在招募各地的合伙人，问我能不能加盟，有没有钱赚。
看得我很伤心，真的。
亏我多次称赞瑞幸是最牛逼的民族品牌，因为从来不割国内的韭菜，都是从国外搞钱烧来补贴大家喝咖啡，走的是公益路线。
没想到浓眉大眼的瑞幸居然搞了小鹿茶现在开始在国内招募合伙人了。
我觉得自己被扇了一耳光。
不谈瑞幸和小鹿茶，单看奶茶加盟这个行业，我觉得我觉得但凡稍微有点眼力或者判断力的人，都不会在2019年投身到奶茶加盟这个无底巨坑了。
作为一个参与了多家奶茶企业及供应链公司融资尽调的人，我想说目前几乎所有的奶茶加盟，对于绝大多数普通人而言，是坑。
加盟奶茶的这些人，90%都是赔钱的，剩下的10%也基本是勉强维持赚不到什么钱，除了奶茶商家外，只有极少数自有店面的人还多少能捞一点点。
如果现在是2014年，那么奶茶还算一个值得玩玩儿的领域。
但现在是2019年，说这个行业是血海都感觉过于保守了。
这个行业的现状简直可以称之为地中海。
不仅深不见底，而且每一个加盟奶茶的人，最终都会愁成地中海。
2 先不说行业，我想先问问各位想要加盟奶茶店的人3个灵魂问题，如果你的答案是否的话，建议直接拉黑所有让你加盟的销售就可以了。
不然你脑子里绝对进奶茶了，还是加浓的那种。
问题1，你在奶茶店打过工吗？ 这个问题其实是多个问题的综合，就是你对于奶茶行业了解多少。 你知道客流潮汐吗？你知道近3年店铺人流的变化吗？ 你知道原材料的真实成本以及营销成本和售价的ROI关系吗？ 你知道如何流程化管理员工让他们不要瞎JB搞甚至偷钱吗？ 你知道奶茶标准SOP有多少页，如何抓大放小吗？ 你知道如果外送的话，运费和外卖平台促销成本是怎样的吗？ 如果你听的很茫然，那么还是别来送人头了，奶茶这个行业，外行杀进来会死的很惨的。
问题2，你在开店当地有资源吗？ 这个问题本质上是问你的奶茶店选址成本是否可控，奶茶，是一个高度吃地理位置的行业，这个年代别想什么酒香不怕巷子深，奶茶店地理位置不是人流中心地带的话，直接就不用开了。
各个犄角旮旯里死去的奶茶店数都数不清。
如果是中心地带的话，那么你能保证拿下这块地吗？
注意，拿下的前提是以合理的成本，如果成本失控，那么拿这块地也没意义。
如果不能，你还是别来了，这个门槛对你高到能卡蛋的地步。
问题3，你有多少本钱可以烧掉不心疼？
这个问题本质上是问你的抗风险能力。
我相信每个人做生意都不是为了赔钱的，但正因如此，才要给自己留足余地，因为生意这件事情，真的是说不好的。
别总想着孤注一掷破釜沉舟，人类历史上成功的也就那么几个，绝大多数都是死的不要不要的没人知道，这叫做幸存者偏差。
奶茶店属于非常吃资金流的行业，很多原材料的保质期都不长，而且SOP要求新鲜度，如果没有足够的准备，那么很快你就发现自己手里的钢镚根本吃不住烧。
这时候后悔，就真的晚了。
如果你没有足够的运营资金等着烧，并且烧光了也不影响生活，那么还是别来玩儿奶茶店了，这行业成功率太低。
我给供应链做贷款尽调的时候，见识过的普通家庭创业开奶茶店烧个妻离子散一屁股债的太多了。 多到你想象不到。
3 经历灵魂3问，如果你还是觉得自己想要在奶茶行业一展拳脚，成为一代奶茶大师的话，那么我来和你好好讲讲奶茶加盟里的坑。
其实上述的灵魂3问，各种奶茶加盟都有各种话术应对，无非是跟你讲自己是大品牌，实力雄厚，并且有足够的知名度，毛利率高，并且会帮你选址，帮你安排装修，帮你培训员工，教你如何管理，给你提供标准化的原材料，你只需要一颗创业的心和吃苦的勇气，以及一大堆加盟费就够了， 干奶茶，他们各个都是专业的，你只要躺下数钱就行。
听起来真的很诱人，而且餐饮还是出名的强流水行业，还是实业，干干干，冲冲冲。
各家的话术本质都差不多，但是这些话术中隐藏着一个非常实际的问题。
既然厂家什么东西都能做到位包你上手就赚钱，有你没你差不多，那他们要你干嘛？
一个必然赚钱的店，煞笔才开加盟，你见过星巴克开加盟吗？
实力雄厚，知名度高，且毛利高的厂家差你一个外行的十几万钢镚吗？
他们不是赚钱么？不是管理能力强吗？不是7天培训上岗吗？干嘛不自己做？
除非，他们说的都是假的，就靠你交加盟费来养活。
吃的就是外行不懂。
绝大多数奶茶加盟，本质上就是厂家在割加盟者的韭菜，这个流程已经非常熟练了。
其实也不局限于奶茶，各种品牌加盟的玩法，越来越像资金盘做局了。
先搞几家样板店，然后雇人来买，造成特别火爆的假象，然后择机开放加盟，疯狂打广告，吸引人加盟。
加入前他是儿子般的态度，交钱后他就是爹。
加盟费割一笔，培训费割一笔，然后就是原材料高价割一笔，流水抽成赚一笔，时不时巡店罚款割一笔，最后保证金再割一笔。
你赚不赚不重要，重要的是他们赚了，不仅赚了钱，而且韭菜们开了这么多店，无形中给他们打了很多广告，甚至有的品牌的考核还有拉多少人开店才能返还保证金，彻彻底底的资金盘玩法。
之前在抖音爆火的某茶，一口气搞了6000多家加盟，最火爆的时候，一条街能有3家某案茶，结果3个月不到，倒闭了80%，但这不重要，因为厂家早就赚嗨了，可以换一个新品牌接着割了。
可怜了那些负债加盟的人，以及他们的家庭。
4 再说具体点，当你选择加盟一家奶茶后，会发生什么事情。
记清楚，加盟商的目的不是帮你赚钱，而是从你手上赚钱，这一点非常重要。
首先你得交加盟费，有的品牌收几万块，有的收几千块，随着韭菜不好割了，已经开始有品牌开始0加盟费了，靠后面的运营来赚你钱。
然后你得交保证金，这个不同品牌不一样，但是说法都差不多，这个保证金是约束，防止你做对品牌不利的事情，只要XXX时间没问题或者退出时，保证金会还给你，当然最终还不还给你就不知道了。 培训费和培训之类的洗脑就不说了，我管这套叫做韭菜三板斧。
当你经历了三板斧之后，你需要有一个店铺地址。
这里就考验你拿店的能力了，每个城市，哪怕是县城，那些人流量大的好位置也都是有限的，不要想着找便宜的地方。
奶茶店最重要的三要素，地理位置，地理位置，还是地理位置，就算你打算做外卖，也要选附近有学校或者是CBD。
这些地理位置的统一特征就是贵。</description>
    </item>
    
    <item>
      <title>nestjs框架中使用nunjucks模板引擎</title>
      <link>https://www.yuedun.wang/blogdetail/5cc807d6effb223a816d9114/</link>
      <pubDate>Tue, 30 Apr 2019 08:31:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5cc807d6effb223a816d9114/</guid>
      <description>main.ts
import { NestFactory } from &amp;#39;@nestjs/core&amp;#39;; import { ExpressAdapter, NestExpressApplication, } from &amp;#39;@nestjs/platform-express&amp;#39;; import { AppModule } from &amp;#39;./app.module&amp;#39;; import nunjucks = require(&amp;#39;nunjucks&amp;#39;); import { join } from &amp;#39;path&amp;#39;; async function bootstrap() { const app = await NestFactory.create&amp;lt;NestExpressApplication&amp;gt;( AppModule, new ExpressAdapter(), ); app.useStaticAssets(join(__dirname, &amp;#39;..&amp;#39;, &amp;#39;public&amp;#39;)); // NestFactory.create需要加泛型参数&amp;lt;NestExpressApplication&amp;gt; app.setBaseViewsDir(join(__dirname, &amp;#39;..&amp;#39;, &amp;#39;views&amp;#39;)); // 修改模板文件后立马生效，否则需要重启服务，nunjucks watch参数也有相同作用 nunjucks.configure(&amp;#39;views&amp;#39;, { ext:&amp;#39;njk&amp;#39;, autoescape: true, express: app, watch: true, }); await app.listen(3000, () =&amp;gt; { }); } bootstrap(); app.</description>
    </item>
    
    <item>
      <title>Consul 入门教程</title>
      <link>https://www.yuedun.wang/blogdetail/5c739d01e4d2f35bdd267d2d/</link>
      <pubDate>Mon, 25 Feb 2019 07:45:05 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c739d01e4d2f35bdd267d2d/</guid>
      <description>一、什么是服务发现
二、consul 简介
三、consul的几个概念
四、安装 Consul
五、运行 Consul Agent
六、集群成员
七、停止 Agent
八、注册服务
九、Consul 集群
十、健康检查
十一、KV Data
十二、Consul Web UI
十三、Docker下安装consul 作者：菲宇
来源：CSDN
原文：https://blog.csdn.net/bbwangj/article/details/81116505 </description>
    </item>
    
    <item>
      <title>服务发现：Zookeeper vs etcd vs Consul </title>
      <link>https://www.yuedun.wang/blogdetail/5c735c58e4d2f35bdd267d22/</link>
      <pubDate>Mon, 25 Feb 2019 03:09:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c735c58e4d2f35bdd267d22/</guid>
      <description>【编者的话】本文对比了Zookeeper、etcd和Consul三种服务发现工具，探讨了最佳的服务发现解决方案，仅供参考。
如果使用预定义的端口，服务越多，发生冲突的可能性越大，毕竟，不可能有两个服务监听同一个端口。管理一个拥挤的比方说被几百个服务所使用的所有端口的列表，本身就是一个挑战，添加到该列表后，这些服务需要的数据库和数量会日益增多。因此我们应该部署无需指定端口的服务，并且让Docker为我们分配一个随机的端口。唯一的问题是我们需要发现端口号，并且让别人知道。
当我们开始在一个分布式系统上部署服务到其中一台服务器上时，事情会变得更加复杂，我们可以选择预先定义哪台服务器运行哪个服务的方式，但这会导致很多问题。我们应该尽我们所能尽量利用服务器资源，但是如果预先定义每个服务的部署位置，那么要实现尽量利用服务器资源是几乎不可能的。另一个问题是服务的自动伸缩将会非常困难，更不用说自动恢复了，比方说服务器故障。另一方面，如果我们将服务部署到某台只有最少数量的容器在运行的服务器上，我们需要添加IP地址到数据列表中，这些数据需要可以被发现并存储在某处。
当我们需要存储和发现一些与正在工作的服务相关的信息时，还有很多其他的例子。
为了能够定位服务，我们需要至少接下来的两个有用的步骤。 服务注册——该步骤存储的信息至少包括正在运行的服务的主机和端口信息 服务发现——该步骤允许其他用户可以发现在服务注册阶段存储的信息。
除了上述的步骤，我们还需要考虑其他方面。如果一个服务停止工作并部署/注册了一个新的服务实例，那么该服务是否应该注销呢？当有相同服务的多个副本时咋办？我们该如何做负载均衡呢？如果一个服务器宕机了咋办？所有这些问题都与注册和发现阶段紧密关联。现在，我们限定只在服务发现的范围里（常见的名字，围绕上述步骤）以及用于服务发现任务的工具，它们中的大多数采用了高可用的分布式键/值存储。
服务发现工具 服务发现工具的主要目标是用来服务查找和相互对话，为此该工具需要知道每个服务，这不是一个新概念，在Docker之前就已经存在很多类似的工具了，然而，容器带给了这些工具一个全新水平的需求。
服务发现背后的基本思想是对于服务的每一个新实例（或应用程序），能够识别当前环境和存储相关信息。存储的注册表信息本身通常采用键/值对的格式，由于服务发现经常用于分布式系统，所以要求这些信息可伸缩、支持容错和分布式集群中的所有节点。这种存储的主要用途是给所有感兴趣的各方提供最起码诸如服务IP地址和端口这样的信息，用于它们之间的相互通讯，这些数据还经常扩展到其它类型的信息服务发现工具倾向于提供某种形式的API，用于服务自身的注册以及服务信息的查找。
比方说我们有两个服务，一个是提供方，另一个是第一个服务的消费者，一旦部署了服务提供方，就需要在服务发现注册表中存储其信息。接着，当消费者试图访问服务提供者时，它首先查询服务注册表，使用获取到的IP地址和端口来调用服务提供者。为了与注册表中的服务提供方的具体实现解耦，我们常常采用某种代理服务。这样消费者总是向固定IP地址的代理请求信息，代理再依次使用服务发现来查找服务提供方信息并重定向请求，在本文中我们稍后通过反向代理来实现。现在重要的是要理解基于三种角色（服务消费者、提供者和代理）的服务发现流程。
服务发现工具要查找的是数据，至少我们应该能够找出服务在哪里？服务是否健康和可用？配置是什么样的？既然我们正在多台服务器上构建一个分布式系统，那么该工具需要足够健壮，保证其中一个节点的宕机不会危及数据，同时，每个节点应该有完全相同的数据副本，进一步地，我们希望能够以任何顺序启动服务、杀死服务或者替换服务的新版本，我们还应该能够重新配置服务并且查看到数据相应的变化。
让我们看一下一些常用的选项来完成我们上面设定的目标。
手动配置 大多数服务仍然是需要手动管理的，我们预先决定在何处部署服务、如何配置和希望不管什么原因，服务都将继续正常工作，直到天荒地老。这样的目标不是可以轻易达到的。部署第二个服务实例意味着我们需要启动全程的手动处理，我们需要引入一台新的服务器，或者找出哪一台服务器资源利用率较低，然后创建一个新的配置集并启动服务。情况或许会变得越来越复杂，比方说，硬件故障导致的手动管理下的反应时间变得很慢。可见性是另外一个痛点，我们知道什么是静态配置，毕竟是我们预先准备好的，然而，大多数的服务有很多动态生成的信息，这些信息不是轻易可见的，也没有一个单独的地方供我们在需要时参考这些数据。
反应时间会不可避免的变慢，鉴于存在许多需要手动处理的移动组件，故障恢复和监控也会变得非常难以管理。
尽管在过去或者当服务/服务器数量很少的时候有借口不做这项工作，随着服务发现工具的出现，这个借口已经不存在了。
Zookeeper Zookeeper是这种类型的项目中历史最悠久的之一，它起源于Hadoop，帮助在Hadoop集群中维护各种组件。它非常成熟、可靠，被许多大公司（YouTube、eBay、雅虎等）使用。其数据存储的格式类似于文件系统，如果运行在一个服务器集群中，Zookeper将跨所有节点共享配置状态，每个集群选举一个领袖，客户端可以连接到任何一台服务器获取数据。
Zookeeper的主要优势是其成熟、健壮以及丰富的特性，然而，它也有自己的缺点，其中采用Java开发以及复杂性是罪魁祸首。尽管Java在许多方面非常伟大，然后对于这种类型的工作还是太沉重了，Zookeeper使用Java以及相当数量的依赖使其对于资源竞争非常饥渴。因为上述的这些问题，Zookeeper变得非常复杂，维护它需要比我们期望从这种类型的应用程序中获得的收益更多的知识。这部分地是由于丰富的特性反而将其从优势转变为累赘。应用程序的特性功能越多，就会有越大的可能性不需要这些特性，因此，我们最终将会为这些不需要的特性付出复杂度方面的代价。
Zookeeper为其他项目相当大的改进铺平了道路，“大数据玩家“在使用它，因为没有更好的选择。今天，Zookeeper已经老态龙钟了，我们有了更好的选择。
etcd etcd是一个采用HTTP协议的健/值对存储系统，它是一个分布式和功能层次配置系统，可用于构建服务发现系统。其很容易部署、安装和使用，提供了可靠的数据持久化特性。它是安全的并且文档也十分齐全。
etcd比Zookeeper是比更好的选择，因为它很简单，然而，它需要搭配一些第三方工具才可以提供服务发现功能。
现在，我们有一个地方来存储服务相关信息，我们还需要一个工具可以自动发送信息给etcd。但在这之后，为什么我们还需要手动把数据发送给etcd呢？即使我们希望手动将信息发送给etcd，我们通常情况下也不会知道是什么信息。记住这一点，服务可能会被部署到一台运行最少数量容器的服务器上，并且随机分配一个端口。理想情况下，这个工具应该监视所有节点上的Docker容器，并且每当有新容器运行或者现有的一个容器停止的时候更新etcd，其中的一个可以帮助我们达成目标的工具就是Registrator。
Registrator Registrator通过检查容器在线或者停止运行状态自动注册和去注册服务，它目前支持etcd、Consul和SkyDNS 2。
Registrator与etcd是一个简单但是功能强大的组合，可以运行很多先进的技术。每当我们打开一个容器，所有数据将被存储在etcd并传播到集群中的所有节点。我们将决定什么信息是我们的。
上述的拼图游戏还缺少一块，我们需要一种方法来创建配置文件，与数据都存储在etcd，通过运行一些命令来创建这些配置文件。
Confd Confd是一个轻量级的配置管理工具，常见的用法是通过使用存储在etcd、consul和其他一些数据登记处的数据保持配置文件的最新状态，它也可以用来在配置文件改变时重新加载应用程序。换句话说，我们可以用存储在etcd（或者其他注册中心）的信息来重新配置所有服务。
对于etcd、Registrator和Confd组合的最后的思考 当etcd、Registrator和Confd结合时，可以获得一个简单而强大的方法来自动化操作我们所有的服务发现和需要的配置。这个组合还展示了“小”工具正确组合的有效性，这三个小东西可以如我们所愿正好完成我们需要达到的目标，若范围稍微小一些，我们将无法完成我们面前的目标，而另一方面如果他们设计时考虑到更大的范围，我们将引入不必要的复杂性和服务器资源开销。
在我们做出最后的判决之前，让我们看看另一个有相同目标的工具组合，毕竟，我们不应该满足于一些没有可替代方案的选择。
Consul Consul是强一致性的数据存储，使用gossip形成动态集群。它提供分级键/值存储方式，不仅可以存储数据，而且可以用于注册器件事各种任务，从发送数据改变通知到运行健康检查和自定义命令，具体如何取决于它们的输出。
与Zookeeper和etcd不一样，Consul内嵌实现了服务发现系统，所以这样就不需要构建自己的系统或使用第三方系统。这一发现系统除了上述提到的特性之外，还包括节点健康检查和运行在其上的服务。
Zookeeper和etcd只提供原始的键/值队存储，要求应用程序开发人员构建他们自己的系统提供服务发现功能。而Consul提供了一个内置的服务发现的框架。客户只需要注册服务并通过DNS或HTTP接口执行服务发现。其他两个工具需要一个亲手制作的解决方案或借助于第三方工具。
Consul为多种数据中心提供了开箱即用的原生支持，其中的gossip系统不仅可以工作在同一集群内部的各个节点，而且还可以跨数据中心工作。
Consul还有另一个不错的区别于其他工具的功能，它不仅可以用来发现已部署的服务以及其驻留的节点信息，还通过HTTP请求、TTLs（time-to-live）和自定义命令提供了易于扩展的健康检查特性。
Registrator Registrator有两个Consul协议，其中consulkv协议产生类似于etcd协议的结果。
除了通常的IP和端口存储在etcd或consulkv协议中之外，Registrator consul协议存储了更多的信息，我们可以得到服务运行节点的信息，以及服务ID和名称。我们也可以借助于一些额外的环境变量按照一定的标记存储额外的信息。
Consul-template confd可以像和etce搭配一样用于Consul，不过Consul有自己的模板服务，其更适配Consul。
通过从Consul获得的信息，Consul-template是一个非常方便的创建文件的途径，还有一个额外的好处就是在文件更新后可以运行任意命令，正如confd，Consul-template也可以使用 Go模板格式。
Consul健康检查、Web界面和数据中心 监控集群节点和服务的健康状态与测试和部署它们一样的重要。虽然我们应该向着拥有从来没有故障的稳定的环境努力，但我们也应该承认，随时会有意想不到的故障发生，时刻准备着采取相应的措施。例如我们可以监控内存使用情况，如果达到一定的阈值，那么迁移一些服务到集群中的另外一个节点，这将是在发生“灾难”前执行的一个预防措施。另一方面，并不是所有潜在的故障都可以被及时检测到并采取措施。单个服务可能会齿白，一个完整的节点也可能由于硬件故障而停止工作。在这种情况下我们应该准备尽快行动，例如一个节点替换为一个新的并迁移失败的服务。Consul有一个简单的、优雅的但功能强大的方式进行健康检查，当健康阀值达到一定数目时，帮助用户定义应该执行的操作。
如果用户Google搜索“etcd ui”或者“etec dashboard”时，用户可能看到只有几个可用的解决方案，可能会问为什么我们还没有介绍给用户，这个原因很简单，etcd只是键/值对存储，仅此而已。通过一个UI呈现数据没有太多的用处，因为我们可以很容易地通过etcdctl获得这些数据。这并不意味着etcd UI是无用的，但鉴于其有限的使用范围，它不会产生多大影响。
Consu不仅仅是一个简单的键/值对存储，正如我们已经看到的，除了存储简单的键/值对，它还有一个服务的概念以及所属的数据。它还可以执行健康检查，因此成为一个好的候选dashboard，在上面可以看到我们的节点的状态和运行的服务。最后，它支持了多数据中心的概念。所有这些特性的结合让我们从不同的角度看到引入dashboard的必要性。
通过Consul Web界面，用户可以查看所有的服务和节点、监控健康检查状态以及通过切换数据中心读取设置键/值对数据。
对于Consul、Registrator、Template、健康检查和Web UI的最终思考 Consul以及上述我们一起探讨的工具在很多情况下提供了比etcd更好的解决方案。这是从内心深处为了服务架构和发现而设计的方案，简单而强大。它提供了一个完整的同时不失简洁的解决方案，在许多情况下，这是最佳的服务发现以及满足健康检查需求的工具。 结论 所有这些工具都是基于相似的原则和架构，它们在节点上运行，需要仲裁来运行，并且都是强一致性的，都提供某种形式的键/值对存储。
Zookeeper是其中最老态龙钟的一个，使用年限显示出了其复杂性、资源利用和尽力达成的目标，它是为了与我们评估的其他工具所处的不同时代而设计的（即使它不是老得太多）。
etcd、Registrator和Confd是一个非常简单但非常强大的组合，可以解决大部分问题，如果不是全部满足服务发现需要的话。它还展示了我们可以通过组合非常简单和特定的工具来获得强大的服务发现能力，它们中的每一个都执行一个非常具体的任务，通过精心设计的API进行通讯，具备相对自治工作的能力，从架构和功能途径方面都是微服务方式。
Consul的不同之处在于无需第三方工具就可以原生支持多数据中心和健康检查，这并不意味着使用第三方工具不好。实际上，在这篇博客里我们通过选择那些表现更佳同时不会引入不必要的功能的的工具，尽力组合不同的工具。使用正确的工具可以获得最好的结果。如果工具引入了工作不需要的特性，那么工作效率反而会下降，另一方面，如果工具没有提供工作所需要的特性也是没有用的。Consul很好地权衡了权重，用尽量少的东西很好的达成了目标。
Consul使用gossip来传播集群信息的方式，使其比etcd更易于搭建，特别是对于大的数据中心。将存储数据作为服务的能力使其比etcd仅仅只有健/值对存储的特性更加完整、更有用（即使Consul也有该选项）。虽然我们可以在etcd中通过插入多个键来达成相同的目标，Consul的服务实现了一个更紧凑的结果，通常只需要一次查询就可以获得与服务相关的所有数据。除此之外，Registrator很好地实现了Consul的两个协议，使其合二为一，特别是添加Consul-template到了拼图中。Consul的Web UI更是锦上添花般地提供了服务和健康检查的可视化途径。
我不能说Consul是一个明确的赢家，而是与etcd相比其有一个轻微的优势。服务发现作为一个概念，以及作为工具都很新，我们可以期待在这一领域会有许多的变化。秉承开放的心态，大家可以对本文的建议持保留态度，尝试不同的工具然后做出自己的结论。</description>
    </item>
    
    <item>
      <title>热水器维修</title>
      <link>https://www.yuedun.wang/blogdetail/5c710eb8e4d2f35bdd267d09/</link>
      <pubDate>Sat, 23 Feb 2019 09:13:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c710eb8e4d2f35bdd267d09/</guid>
      <description>天然气热水器莫名其妙就不打火了，然后到58上找了维修公司，在电话里问维修多少钱就是死活不说，连区间都不说。然后就是维修员上门检修20元。 就换了这么个零件，看着也不是特别精密的零件，问师傅换这个多少钱，说是300元。到最后收费的时候说是380，这两个数字听起来很像吗？我能听错！！还要加50元人工费，合计450元。 或许这就是维修公司的套路吧，开始不说多少钱，总是催着你什么时候可以上门维修，维修的时候又说这坏那坏了，换个零件又很贵。网上一看二手的都不过300块，还不及一个零件贵。还有就是问价格的时候一定要多次确认多少钱后再决定是否需要更换。最后要保留维修票据，以免日后保修。</description>
    </item>
    
    <item>
      <title>部署golang到服务器</title>
      <link>https://www.yuedun.wang/blogdetail/5c70f2074a7b7e6cd8086a1f/</link>
      <pubDate>Sat, 23 Feb 2019 07:11:03 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c70f2074a7b7e6cd8086a1f/</guid>
      <description>说起将开发好的程序部署到服务上，常用的有两种方式：
本地编译打包，上传到服务器 git push到远程仓库，在服务器上拉取（编译-打包） 无论以怎样的方式发布，都只有熟悉流程才能得心应手。今天我要说的是golang的部署流程。
如果是在公司内，自然有专人负责发布事宜，也有公司暂无运维人员，这时还是由开发人员负责服务器发布工作，当然，CI/CD这类工具一般也没有搭建起来。但这并不影响我们快速发布。 得益于go的编译速度，整个发布过程可能也就2分钟，接下来说明一下我个人的发布流程:
在项目目录下执行go打包命令 GOOS=linux GOARCH=amd64 go build 由于是要部署到Linux服务器上，所以加上GOOS=linux GOARCH=amd64就可以打包出对应系统的二进制可执行文件。可以将该命令写成脚本文件。
推送代码到git仓库，这一步并不是必须，之所以需要这一步，是因为go只打包*.go文件，并不会打包静态文件，所以还需要把相关静态文件推送的git仓库以便拉取。
上传打包好的二进制可执行文件到服务器的项目目录下。为什么是项目目录？因为还有静态文件需要使用，所以服务器上也要有同样的项目结构。可借助一些工具来上传，我使用了rz命令来上传。
git pull代码，主要是拉取静态文件。
重启应用。
整个过程比较耗时的操作是上传文件和推拉代码，打包和重启应用反而很快，基本是两三秒完成。 golang相对于其他语言，在服务，器上不需要安装运行时，不像Java和nodejs都需要安装正确的运行时版本，go只需要把打包好的二进制可执行文件扔上去就可以执行。</description>
    </item>
    
    <item>
      <title>nodejs-go内存占比</title>
      <link>https://www.yuedun.wang/blogdetail/5c6cbe294a7b7e6cd80869e5/</link>
      <pubDate>Wed, 20 Feb 2019 02:40:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c6cbe294a7b7e6cd80869e5/</guid>
      <description>同一台服务器上部署了两个功能差不多的服务，但是内存占比差距有点大。 go占14.7M nodejs占122.2M</description>
    </item>
    
    <item>
      <title>go语言开发grpc之安装grpc</title>
      <link>https://www.yuedun.wang/blogdetail/5c63b5334a7b7e6cd808697a/</link>
      <pubDate>Tue, 12 Feb 2019 14:12:03 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5c63b5334a7b7e6cd808697a/</guid>
      <description>一、安装gRPC $ go get -u google.golang.org/grpc package google.golang.org/grpc: unrecognized import path &amp;#34;google.golang.org/grpc&amp;#34; (https fetch: Get https://google.golang.org/grpc?go-get=1: dial tcp 216.239.37.1:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.) grpc的源码库迁移到了github上，所以需要手动下载了。grpc-go 正常情况下按照以下方式就可安装完成
git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text go get -u github.com/golang/protobuf/{proto,protoc-gen-go} git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto cd $GOPATH/src/ go install google.</description>
    </item>
    
    <item>
      <title>gRPC负载均衡</title>
      <link>https://www.yuedun.wang/blogdetail/5bc1bd1bf846d21847dc3014/</link>
      <pubDate>Sat, 13 Oct 2018 09:38:35 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5bc1bd1bf846d21847dc3014/</guid>
      <description>gRPC是谷歌开发的跨语言（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）RPC框架，跨语言是指可以使用gRPC进行个语言之间的通信，例如：PHP可以对java进行远程调用。
在系统架构中，我们会把多个系统公共的模块拆分出来做成单独的服务，可以提供RESTful接口，也可以为了低延迟快速响应而提供RPC接口。如果选择的是gRPC，上线后发现多个系统都请求这个RPC服务提供者，而且流量很大的时候负载过高导致崩溃。为了降低负载和提高可用性，理所当然的要做集群，用nginx作为代理服务器，幸运的是nginx版本为1.13及以上支持了gRPC的负载均衡。那么请看以下配置：
upstream grpcservice { server localhost:50051; server localhost:50052; } server { listen 8080 http2;#需要加http2 server_name localhost; location / { grpc_pass grpc://grpcservice;#以grpc为前缀 } grpc_connect_timeout 10; } 配置好nginx以后，客户端需要连接到localhost:8080来调用远程服务。 效果图： 可以看到，一次任务的多个请求两个RPC服务器都有输出，证明请求被分配到了两台服务器上。
虽然我们使用了两台服务器来保证性能和可用性，但是当其中一台服务器挂掉以后发现部分请求响应非常慢。
原因是服务器虽然宕机，但是请求还会发送到挂掉的服务器上，然后等待超时（默认1分钟），超时后再请求另外的服务器，重新请求以后可能还会再次分配到这台宕机的服务器。为了能加快响应，配置了grpc_connect_timeout选项，把时间设为5秒，再次测试，大概5秒后就能返回。如果设置更小的时间响应时间会更短。</description>
    </item>
    
    <item>
      <title>linux修改MySQL 5.7.22字符集为utf8</title>
      <link>https://www.yuedun.wang/blogdetail/5bbf2531f846d21847dc2fcc/</link>
      <pubDate>Thu, 11 Oct 2018 10:25:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5bbf2531f846d21847dc2fcc/</guid>
      <description>网上也找了很多方案结果就是奇葩的不成功，最后直接修改/etc/mysql/mysql.conf.d/mysqld.cnf成功了。 在该文件最后添加
default-storage-engine=INNODB character-set-server=utf8 collation-server=utf8_general_ci 重启成功。
这是本地虚拟机里的mysql
mysql&amp;gt; show variables like &amp;#34;character%&amp;#34;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 完全正确，但是修改阿里云服务器以后还是有点小问题
character_set_database这一项还是latin1,不过似乎并不影响。 友情提示：纠正了mysql字符集发现新建的表还是latin1字符集，那有可能是该数据库本身的字符集就不对，可以试着看看。</description>
    </item>
    
    <item>
      <title>mongodb forEach替换文本</title>
      <link>https://www.yuedun.wang/blogdetail/5bb08746f846d21847dc2aef/</link>
      <pubDate>Sun, 30 Sep 2018 08:20:22 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5bb08746f846d21847dc2aef/</guid>
      <description>最近七牛云存储要收回测试域名，但是我的博客中图片使用了这些测试域名，所以要替换掉，避免图片不可访问。在文档中没有找到可以直接替换的方法，所以就使用了mongodb的forEach循环替换。 首先用正则查询法查出使用了测试域名的文档，然后forEach循环，在每个循环中使用js的正则替换函数将域名替换掉，最后再保存该文档即可。
db.getCollection(&amp;#39;blogs&amp;#39;).find({content:{$regex:/hopefully.qiniudn.com/}}).forEach(function(item){ item.content = item.content.replace(/hopefully.qiniudn.com/g, &amp;#39;hopefully-img.yuedun.wang&amp;#39;) db.getCollection(&amp;#39;blogs&amp;#39;).save(item) print(&amp;#34;&amp;gt;&amp;gt;&amp;#34;, item.content); }) </description>
    </item>
    
    <item>
      <title>mongoose查询没有响应</title>
      <link>https://www.yuedun.wang/blogdetail/5b90f19bb1f3aa6dab14313d/</link>
      <pubDate>Thu, 06 Sep 2018 09:21:31 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b90f19bb1f3aa6dab14313d/</guid>
      <description>使用mongoose建立了连接以后，通过model查询数据，如：testModel.find(),既不报错又不返回数据。
const mongoose = require(&amp;#39;mongoose&amp;#39;); mongoose.connect(&amp;#39;mongodb://localhost/my_database&amp;#39;); 使用mongoose.connect连接产生在mongoose.connection上，使用mongoose.createConnection是反回一个连接对象，建立model的时候需要使用这个连接才有效，此时使用mongoose.model是无效的。
const conn = mongoose.createConnection(&amp;#39;your connection string&amp;#39;); const MyModel = conn.model(&amp;#39;ModelName&amp;#39;, schema); const m = new MyModel; m.save(); // 可以工作 vs
const conn = mongoose.createConnection(&amp;#39;your connection string&amp;#39;); const MyModel = mongoose.model(&amp;#39;ModelName&amp;#39;, schema); const m = new MyModel; m.save(); // 不能工作 </description>
    </item>
    
    <item>
      <title>typescript中导入koa-error后报错</title>
      <link>https://www.yuedun.wang/blogdetail/5b8e2ce2b1f3aa6dab143109/</link>
      <pubDate>Tue, 04 Sep 2018 06:57:38 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b8e2ce2b1f3aa6dab143109/</guid>
      <description>无法重新声明块范围变量“onerror”
解决办法：打开tsconfig.json中的&amp;quot;lib&amp;quot;: [&amp;quot;es2015&amp;quot;, &amp;quot;es2016&amp;quot;, &amp;quot;es2017&amp;quot;]</description>
    </item>
    
    <item>
      <title>win10家庭版组策略</title>
      <link>https://www.yuedun.wang/blogdetail/5b8b9d63b1f3aa6dab1430d2/</link>
      <pubDate>Sun, 02 Sep 2018 08:20:51 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b8b9d63b1f3aa6dab1430d2/</guid>
      <description>win10家庭版本身不支持组策略，但还是有办法让其支持。 复制下面内容到文本文件：
@echo off pushd &amp;#34;%~dp0&amp;#34; dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &amp;gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &amp;gt;&amp;gt;List.txt for /f %%i in (&amp;#39;findstr /i . List.txt 2^&amp;gt;nul&amp;#39;) do dism /online /norestart /add-package:&amp;#34;C:\Windows\servicing\Packages\%%i&amp;#34; pause 后缀名保存为cmd,以管理员身份执行：
然后WIN+R中执行gpedit.msc即可打开组策略。
如此可以关闭占用CPU过高的Windows Defender。</description>
    </item>
    
    <item>
      <title>说道说道前后端分离</title>
      <link>https://www.yuedun.wang/blogdetail/5b66733ae7e37a672f015c10/</link>
      <pubDate>Sun, 05 Aug 2018 03:47:06 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b66733ae7e37a672f015c10/</guid>
      <description>要说前端界的发展速度，那真是快！
2012年那时候接触过extjs，用于企业级后台开发还真不错，有好看的UI界面，组件丰富，基本能满足各类需求。但此时，HTML5正在蓬勃发展，尤其是乔布斯宣布苹果设备不支持flash后HTML5发展更是迅猛。并且angularjs这类MVVM框架被大多数所知，reactjs,vuejs如雨后春笋般生长。
2014年使用了一段时间angularjs，感觉学习难度有点大，并且据官方说2.0下向下兼容于是放弃继续学习。2015年使用vue1.0做了一个项目后我逢人便说angular，vue有多好用，推荐他们放弃jquery使用vue。不到2年时间再看看前端界，vue，react等框架已经是前端开发标配，如果你说公司项目还在使用jquery会被人笑话，对于前端新人MVVM框架是必学，jquery反而不会被重视。
这就导致一个结果：**“手里拿着锤子，看什么都是钉子”，因为有锤子的关系，遇到任何问题，都会先想如何用锤子解决。久而久之，陷入了一种思维定式。任何工具带来便利的同时，也带来了局限性。而这往往是用锤子的人很难看到的。**就拿一个需要SEO的网站来说，该选择哪种技术好？如果只会vue，那么肯定是选择vue，就算vue不太适合做这类网站，也会拿出ssr来强行做事。殊不知需要SEO的网站使用静态文件是最合适的。大多数人认为前后端分离是使用vue，react，angular，使用jquery的不叫前后端分离，这完全是搞混了概念，实际上后端的controller层也属于视图层，也可以归属于前端。
现在去网上一搜，问一下身边的人怎么看待前后端分离的，大多数人秉持着支持的态度，认为前后端分离好处多多，列举几条：
专业的人做专业的事 前后并行开发，效率高 前端工程化，组件化 解耦 降低了开发学习难度 等等…… 大家说的都说到点上了，这也是前后端分离能发展起来的驱动力。但是道理说的都挺好，如果不结合实际情况的话就是大炮打蚊子，不但达不到理想的效果还浪费资源。而且前后端分离带来的负面情况也不可忽视：
增加了沟通成本，一些前后端都可以做又都不想做的事或许只能由权利大的来决定。 一般前端开发速度会比后端快，在接口没开发好时前端只能闲等着。也有反过来的情况。前后端分离也意味着任务关联性减弱，可能不是同时开发，需要一方催着一方来完成。 跨域问题导致联调困难，前端只能等待接口开发上了服务器才能调试。 职责分离后确认职责也困难，一个问题出现到底是谁的问题？谁解决？ 一个需求需要前后端开发同时参与理解需求，有理解偏差问题。 小公司多一个人多一份支出。 那么到底该不该进行前后端分离，如何进行技术选型？这需要根据一些实际情况来决定，大体判断准则有以下几点：
后台系统采用前后端分离比较合适。 需要SEO引流的就不要强行前后端分离了，react，vue的服务端渲染也很勉强，徒增开发难度而已。 数据交互比较多的使用前后端分离，操作数据比jquery方便。 页面本身特别简单，只负责简单数据展示，要求打开速度，直接服务端渲染即可。这种页面本身就是单页面，如果还要使用框架就是多此一举，增加页面负担，增加开发调试难度。 开发资源充足最好前后端分离，开发资源不足时不分离，一人包揽前后台端反而更快。 最后，前后端分离是一个趋势，但不是必须。更准确的说法应该叫做“前后端分工”，毕竟在5年前这些活都是一个开发来做的，因为技术复杂性提升，前端不想只是切图，后端不想学变化太快的前端就出现了分离。你可以想象测试的工作，现在的测试大多还是测业务，但是也出现了一个自动化测试的职位，因为测试不想天天鼠标点呀点的测，想搞点高深的东西，而开发又特别烦写单元测试代码，这就又出现分离。再者，数据库也是一样，所以出现了DBA这个角色。谁知哪一天又会合起来呢！</description>
    </item>
    
    <item>
      <title>go实现文件下载</title>
      <link>https://www.yuedun.wang/blogdetail/5b3604876b5bf65ca5031db7/</link>
      <pubDate>Fri, 29 Jun 2018 13:05:59 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b3604876b5bf65ca5031db7/</guid>
      <description>go可以很容易实现一个文件服务器，只需要使用函数 func ServeFile(w ResponseWriter, r *Request, name string)即可。
package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;fmt&amp;#34; ) func helloHandler(res http.ResponseWriter, req *http.Request) { http.ServeFile(res, req, &amp;#34;E:/go-work/src/go-learning/foo.xlsx&amp;#34;) } func main() { fmt.Println(&amp;#34;web服务启动成功，可在浏览器中访问：localhost:8081&amp;#34;) http.HandleFunc(&amp;#34;/file&amp;#34;, helloHandler) http.Handle(&amp;#34;/&amp;#34;, http.FileServer(http.Dir(&amp;#34;E:/go-work/src/go-learning/&amp;#34;))) err := http.ListenAndServe(&amp;#34;:8081&amp;#34;, nil) if err != nil { log.Fatal(&amp;#34;ListenAndServe:&amp;#34;, err.Error()) } } 查看go文档除了翻墙访问https://golang.org
还可以访问国内镜像：https://golang.google.cn/
最简单快速的访问，直接在本地起服务：
godoc -http=:8082</description>
    </item>
    
    <item>
      <title>js转图片为base64上传</title>
      <link>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</link>
      <pubDate>Mon, 25 Jun 2018 07:10:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</guid>
      <description>//上传图片 var imagesBase64 = []; $(&amp;#34;input[type=file]&amp;#34;).on(&amp;#34;change&amp;#34;, function (e) { var image = e.target.files[0]; var imgFile = new FileReader(); var imgShow = new Image(); imgFile.readAsDataURL(image); imgFile.onload = function () { var imgData = this.result; //base64数据 imagesBase64.push({ teaId: teacherInfo.id, fileType: &amp;#34;award&amp;#34;,//图片 fileName: image.name, file: imgData, }); imgShow.src = imgData; imgShow.style.width = &amp;#34;100px&amp;#34;; imgShow.style.height = &amp;#34;100px&amp;#34;; imgShow.title = &amp;#34;双击删除&amp;#34;; $(&amp;#34;#imageShow&amp;#34;).append(imgShow); } }); $(&amp;#34;#imageShow&amp;#34;).on(&amp;#34;dblclick &amp;#34;, &amp;#34;img&amp;#34;, function () { var index = $(&amp;#34;#imageShow &amp;gt; img&amp;#34;).</description>
    </item>
    
    <item>
      <title>新阿里云服务器一些基本设置</title>
      <link>https://www.yuedun.wang/blogdetail/5b21fc996699964267f5e168/</link>
      <pubDate>Thu, 14 Jun 2018 05:26:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b21fc996699964267f5e168/</guid>
      <description>修改terminal apt-get update更新软件源，安装zsh，设置默认terminal为zsh，chsh -s /usr/bin/zsh。非root用户需要在root权限下修改/etc/passwd文件才能实现。
安装git
apt-get install git
nginx设置：
sudo /etc/init.d/nginx restart # or start, stop
或
sudo service nginx restart # or start, stop
有时候我们改了配置文件只是要让配置生效，这个时候不必重启，只要重新加载配置文件即可。sudo nginx -s reload
目录/etc/nginx/sites-available/下增加文件配置反向代理，并软链接到/etc/nginx/sites-enabled/下
mongodb导入数据 启动：
/usr/local/mongodb/bin/mongod &amp;ndash;dbpath=/usr/local/mongodb/data &amp;ndash;logpath=/usr/local/mongodb/logs &amp;ndash;logappend &amp;ndash;auth &amp;ndash;fork
如需外网客户端连接加参数--bind_ip_all
导入单个collection
./mongorestore -v -h ip -u xxxx -p xxxx &amp;ndash;db=blogs -c blogs /home/yuedun/download/xxxx.bson/xxxx/blogs.bson
或导入整个目录
./mongorestore -v -h ip -u xxxx -p xxxx &amp;ndash;db=blogs &amp;ndash;drop /home/yuedun/download/xxxx.bson/xxxx
没有指定-h参数会报错：Failed: error connecting to db server: no reachable servers 阿里云上-h参数需要内网ip，localhost不行。</description>
    </item>
    
    <item>
      <title>过早的优化是万恶之源</title>
      <link>https://www.yuedun.wang/blogdetail/5b1fcbf7e205c79ceab7a529/</link>
      <pubDate>Tue, 12 Jun 2018 13:34:47 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b1fcbf7e205c79ceab7a529/</guid>
      <description>“过早的优化是万恶之源”，这句话或多或少在哪听过，不过为什么优化也会带来问题，恐怕只有经历过的人才能理解其中的意义。
关于程序优化，产品优化这些词在开发工作中一定有经历过。某位程序员做事一丝不苟，对程序开发特别注重性能问题，花大量时间来优化某段代码。某位产品在提出需求的时候总是有一些目前用不到的功能，说是为了方便将来扩展。
那么实际工作中这种优化到底起到了什么作用？个人认为弊多于利。
问题一：过早引入新技术 甲同学在做一个员工日常工作内容列表的接口时，认为该接口会产生性能问题，将来数据增多的时候会有性能瓶颈，于是利用了某项缓存技术，觉得缓存一定比直接查数据库速度快，于是就引入了缓存数据库。把数据拉到缓存中，先从缓存中读取数据，没有数据的时候从数据库中读取放到缓存中。这个思路看似挺好，不过为了更新数据就设置过期时间为1天。上线后发现很多员工的日常工作内容一天内会有变化，就设置过期时间为半天，结果半天过期时间还是会有部分员工工作内容更新频繁。这时候就有些纠结了，到底是再降低过期时间还是单独更新某个员工的数据？如果选择降低过期时间会导致所有数据都要从数据库重新拉取，选择单独更新又要对各个更新几口进行修改来更新缓存。这期间不免要折腾几回来适应业务需求，而且容易造成各个业务过度依赖缓存，为了保持缓存数据一致性需要做很多工作，然而很多的工作目的并没有提高系统可用性。
问题二：过早优化数据库 有些同学在设计数据库的时候总喜欢多加些字段，为了方便未来使用，知道索引能加速查询，就使劲加索引，这基本属于不够成熟的思想，试问：等真正需要字段的时候加会晚吗？现在提前加了后面还能知道这个字段当初是准备怎么用来的吗？别的同学要加的时候发现已经有了一个类似的，这个字段到底有没有在用，不敢删又不敢用。索引加了一大堆本以为有积极作用，可不知道索引会占用空间，插入修改却慢了下来。
问题三：过早进行防范准备 在没有真实QPS数据和准确预估的情况，开发同学生生怕线上出现故障，要求多部署几台服务器做负载均衡，反正服务器多了也不会有问题。但是过多的服务器会带来其他方面的问题： 1、运维难度增加 2、企业成本增加 3、线上故障排查难度增加
针对性优化 在避免过度设计的情况下才进行针对性优化。性能问题的出现并不是经常性的，而是在某个访问高峰期出现，这时候影响范围还不是很大，但是该考虑进行优化了，如果是经常性突发并发数增加可以考虑缓存数据库。如果是日常单机承载能力高可以进行一定压力测试，评估并发压力增加合适的服务器。随着企业发展，数据量不断累积，此时数据库成为主要压力，此时对数据库索引，SQL进行优化，往往能有立竿见影的效果。
总结：没有针对性的性能优化，只是按照假象场景来设计，最后不但不能起到优化作用反而为后期优化带来累赘。</description>
    </item>
    
    <item>
      <title>消息队列中参数的传递和存储</title>
      <link>https://www.yuedun.wang/blogdetail/5b1d2d8f2c36bd008e01f5a3/</link>
      <pubDate>Sun, 10 Jun 2018 13:54:23 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b1d2d8f2c36bd008e01f5a3/</guid>
      <description>消息队列（MQ）在系统架构中发挥了重要作用，其主要作用有系统解耦，流量削峰，异步消息存储，分布式系统最终一致性等。 本文介绍的是消息系统中消息发布者和订阅者间参数如何约定和传递？实际应用场景中，一种消息的发布者和订阅者都有可能是多个，也就是多对多的关系，这样就形成了消息参数传递的复杂性，就算一开始参数有约定，大家都按照最初约定来开发，但不免开发过程中各端需求变化带来的修改。例如最开始为了实现系统解耦而引进了消息队列，此时消息参与者较少，只有一个发布者和一个订阅者，这种情况最简单（其实最简单还是直接调接口），双方简单约定了需要传递的参数。
{ userId:123, userName:&amp;#34;阿离&amp;#34;, age:23 } 后来订阅方又需要性别，地址，工作等信息，要求发布方加参数，这种要求也不过分，那就加好了。
{ userId:123, userName:&amp;#34;阿离&amp;#34;, age:23, gender:&amp;#34;女&amp;#34;, address:&amp;#34;上海&amp;#34;, job:&amp;#34;测试&amp;#34; } 再后来又有一个订阅者参与进了消息系统，要求在上述参数中再加“工作年限”参数，那么先不说什么了，加呗。
{ userId:123, userName:&amp;#34;阿离&amp;#34;, age:23, gender:&amp;#34;女&amp;#34;, address:&amp;#34;上海&amp;#34;, job:&amp;#34;测试&amp;#34;, workingLife:4 } 再后来又有不同的订阅者参与进消息系统，每个订阅者都可能有自己的参数要求，参数类型不同，随着系统的发展，连发布者也有多个。这时最初的文档或约定已经不奏效了，总会有人不能及时更新文档导致约定不能成为约束，各自为政，比如“学历”参数有的人要求叫“硕士”，有人要叫“研究生”，总之是很难统一。如果要继续修改发布参数就会有很多冗余出现，参数类型不统一出现系统故障。
这时消息系统已经不是当初简单的两个发布者订阅者了，而是一群人在参数，所谓的众口难调。此时弊端已现，无论哪一方有变化都势必牵连所有人。所以看出的出这种消息参数传递有其不合理的地方，那么怎么传递更合理？此处的MQ最开始已经说了，是为了解耦而引进，说明该MQ是多个系统的衔接者，而多个系统终究还是系统，不是简单的前端和后端接口调用，例如某个前端A也是由自己的接口提供服务系统的，MQ不是直接为前端A提供参数的。应该是由前端A自己的服务端A订阅消息，前端A需要什么参数就有服务A查询需要的参数即可，前端B需要什么参数由服务B查询提供。而发布者A，发布者B等只需要传递关键参数userId即可，其他姓名，性别，年龄什么的都不需要传。
此时有人喜欢拿性能来说事，觉得应该由发布者一次性查出来传递并（作为日志）存储，订阅者不用每次都查询那么多相同参数，这是没理解MQ的意义，MQ应该是负责告诉其他人发布者做了什么，而不应该由订阅者决定发布者和MQ应该怎么做。因为既然是解耦系统，那么各个系统有不同需求，也可能有自己的数据库，就算是要记录日志也是由各系统自己负责存储，不应该由MQ来存储，如果所有参数都由发布者来查询那是不是会降低发布者的性能？就像上面的情况，MQ的参数随着各端要求不断增减，类型变化，最后存储的参数会变得乱七八糟，根本无法使用。
总结：消息队列应该只传递和存储关键信息，如ID就足够了，如果传递多余信息而造成不一致也会出现扯皮的事。各个订阅方自己负责其他参数查询和日志存储，否则就不是解耦了。</description>
    </item>
    
    <item>
      <title>beego注解路由404</title>
      <link>https://www.yuedun.wang/blogdetail/5ad46aebb9be3f8e30daaea8/</link>
      <pubDate>Sun, 15 Apr 2018 13:21:36 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ad46aebb9be3f8e30daaea8/</guid>
      <description>beego注解路由匹配不到，返回404页面 router.go使用了两种方式注册路由：
ns := beego.NewNamespace(&amp;#34;/admin&amp;#34;, beego.NSRouter(&amp;#34;/&amp;#34;, &amp;amp;controllers.UserController{}, &amp;#34;get:Welcome&amp;#34;), beego.NSInclude( &amp;amp;controllers.UserController{}, ), controller中的路由注解设置：
// @router /admin/user/get-all-user [get] func (c *UserGroupController) GetAllUser() { user := new(User) users, err := user.GetUserList() if nil != err { c.Data[&amp;#34;json&amp;#34;] = ErrorMsg(err) } c.Data[&amp;#34;json&amp;#34;] = users c.ServeJSON() } 使用上面的方式注册路由后结果是nomatch
最终结果显示上面的注解路由时错误的，下面是正确的注册方式： 问题在于controller的注解写法，如果该路由在namespace下，则不能在注解中拼接命名空间前缀，框架会自动拼接。 即/admin为命名空间，注解中只需写/user/get-all-user，不能这样写/admin/user/get-all-user
// @router /user/get-all-user [get] func (c *UserGroupController) GetAllUser() { user := new(User) users, err := user.GetUserList() if nil != err { c.Data[&amp;#34;json&amp;#34;] = ErrorMsg(err) } c.</description>
    </item>
    
    <item>
      <title>go并发获取数据</title>
      <link>https://www.yuedun.wang/blogdetail/5acb49ba45213aca5fde59e1/</link>
      <pubDate>Mon, 09 Apr 2018 11:08:42 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5acb49ba45213aca5fde59e1/</guid>
      <description>go语言可以很轻松的实现并发获取数据，就算是新手也可以按部就班的套用现成的并发模式来实现并发。以下是一个简单的测试程序，其中有串行，并行。
package main import ( &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { syncFunc() fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#34;) asyncFunc() fmt.Println(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#34;) asyncChanFunc() } // 串行执行 func syncFunc() { var n,m,x int start := time.Now() fmt.Println(&amp;#34;syncFunc start:&amp;#34;,start) func () { time.Sleep(time.Second*1) n = 1 }() func () { time.Sleep(time.Second*2) m = 2 }() func () { time.Sleep(time.Second*3) x =3 }() t := time.Now() fmt.Println(t) elapsed := t.Sub(start) fmt.Println(&amp;#34;syncFunc end:&amp;#34;, elapsed, n, m, x) } // 并行执行 func asyncFunc() { var n,m,x int var wg sync.</description>
    </item>
    
    <item>
      <title>go测试函数的编写及运行</title>
      <link>https://www.yuedun.wang/blogdetail/5ac588446a513c7b8bfd72e6/</link>
      <pubDate>Thu, 05 Apr 2018 02:21:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ac588446a513c7b8bfd72e6/</guid>
      <description>go test命令是一个按照一定的约定和组织的测试代码的驱动程序。在包目录内，所有以_test.go为后缀名的源文件并不是go build构建包的一部分，它们是go test测试的一部分。 在\*_test.go文件中，有三种类型的函数：测试函数、基准测试函数、示例函数。一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确； go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准函数以计算一个平均的执行时间。示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。
测试函数 每个测试函数必须导入testing包。测试函数有如下的签名：
func TestName(t *testing.T) { // ... } 测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：
func TestSin(t *testing.T) { /* ... */ } func TestCos(t *testing.T) { /* ... */ } func TestLog(t *testing.T) { /* ... */ } 其中t参数用于报告测试失败和附加的日志信息。让我们定义一个实例包gopl.io/ch11/word1，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。（下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。）
// gopl.io/ch11/word1 // Package word provides utilities for word games. package word // IsPalindrome reports whether s reads the same forward and backward. // (Our first attempt.) func IsPalindrome(s string) bool { for i := range s { if s[i] !</description>
    </item>
    
    <item>
      <title>Golang－ import 导入包的语法</title>
      <link>https://www.yuedun.wang/blogdetail/5aaf2e3da55bb1fd38001c70/</link>
      <pubDate>Mon, 19 Mar 2018 03:27:57 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5aaf2e3da55bb1fd38001c70/</guid>
      <description>一、 包的导入语法 在写Go代码的时候经常用到import这个命令用来导入包文件，看到的方式参考如下：
import( &amp;#34;fmt&amp;#34; ) 然后在代码里面可以通过如下的方式调用
fmt.Println(&amp;#34;hello world&amp;#34;) 上面这个fmt是Go语言的标准库，他其实是去GOROOT下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：
相对路径
import &amp;#34;./model&amp;#34; //当前文件同一目录的model目录，但是不建议这种方式import` 绝对路径
import &amp;#34;shorturl/model&amp;#34; //加载GOPATH/src/shorturl/model模块` 上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面是三种导入包的使用方法。
点操作 有时候会看到如下的方式导入包
import( . &amp;#34;fmt&amp;#34; ) 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的
fmt.Println(&amp;#34;hello world&amp;#34;) 可以省略的写成
Println(&amp;#34;hello world&amp;#34;) 别名操作 别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字
import( f &amp;#34;fmt&amp;#34; ) 别名操作调用包函数时前缀变成了重命名的前缀，即
f.Println(&amp;#34;hello world&amp;#34;) _操作 这个操作经常是让很多人费解的一个操作符，请看下面这个import
import ( &amp;#34;database/sql&amp;#34; _ &amp;#34;github.com/ziutek/mymysql/godrv&amp;#34; ) _操作其实只是引入该包。当导入一个包时，它所有的init()函数就会被执行，但有些时候并非真的需要使用这些包，仅仅是希望它的init()函数被执行而已。这个时候就可以使用_操作引用该包了。即使用_操作引用包是无法通过包名来调用包中的导出函数，而是只是为了简单的调用其init函数()。
二、 包的导入过程说明 程序的初始化和执行都起始于main包。如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程：
通过上面的介绍我们了解了import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，只初始化里面的init函数和一些变量，不能通过包名来调用其它的函数，这有什么用呢？往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的引起，在init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。
原文地址：http://blog.csdn.net/zhangzhebjut/article/details/25564457</description>
    </item>
    
    <item>
      <title>github提交不记录Contributions</title>
      <link>https://www.yuedun.wang/blogdetail/5aaf2794a55bb1fd38001c63/</link>
      <pubDate>Mon, 19 Mar 2018 02:59:32 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5aaf2794a55bb1fd38001c63/</guid>
      <description>github上提交了很多commit但是没有Contributions绿色方块，原因是提交的email和github不匹配，使用git log查看记录中使用的邮箱是否是github的邮箱，如果不是也不需要做什么修改，只需要在github上添加对应的邮箱地址即可。
右上角头像-settings-emails-Add email address
验证邮箱后就会立马重新统计</description>
    </item>
    
    <item>
      <title>pm2设置NODE_ENV环境变量</title>
      <link>https://www.yuedun.wang/blogdetail/5a98c43ff4583f741c210b89/</link>
      <pubDate>Fri, 02 Mar 2018 03:25:51 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a98c43ff4583f741c210b89/</guid>
      <description>nodejs中经常使用到环境变量，最常见的如：process.env.NODE_ENV。那么在生产环境中使用pm2如何设置环境变量？
设置方式一：shell命令设置 linux：export NODE_ENV=development&amp;amp;&amp;amp; node app.js
win：set NODE_ENV=development&amp;amp;&amp;amp; node app.js
一般是作临时变量在系统启动时设置，不影响其他系统，也可同时运行开发环境和生产环境，只需要根据process.env.NODE_ENV来运行不同逻辑即可。
设置方式二：配置文件设置 要在pm2设置环境变量也很简单。
pm2 start pm2.json &amp;ndash;env production
--env production参数是为了设置环境变量，由pm2.json中的配置决定设置什么样的环境变量。
pm2.json
{ &amp;#34;apps&amp;#34; : [{ &amp;#34;name&amp;#34;: &amp;#34;issue&amp;#34;, &amp;#34;cwd&amp;#34;: &amp;#34;dest&amp;#34;, &amp;#34;script&amp;#34; : &amp;#34;bin/www.js&amp;#34;, &amp;#34;instances&amp;#34; : &amp;#34;2&amp;#34;, &amp;#34;exec_mode&amp;#34; : &amp;#34;cluster&amp;#34;, &amp;#34;env&amp;#34;: { &amp;#34;NODE_ENV&amp;#34;: &amp;#34;development&amp;#34;, &amp;#34;PORT&amp;#34;: 3002 }, &amp;#34;env_production&amp;#34; : { &amp;#34;NODE_ENV&amp;#34;: &amp;#34;production&amp;#34;, &amp;#34;PORT&amp;#34;: 3003 }, &amp;#34;log_date_format&amp;#34;: &amp;#34;YYYY-MM-DD_HH:mm Z&amp;#34;, &amp;#34;merge_logs&amp;#34;: true }] } 如果不加参数则默认使用
&amp;#34;env&amp;#34;: { &amp;#34;NODE_ENV&amp;#34;: &amp;#34;development&amp;#34;, &amp;#34;PORT&amp;#34;: 3002 } 结果：NODE_ENV=development,PORT=3002
加--env production则使用的是</description>
    </item>
    
    <item>
      <title>webpack构建vue项目警告</title>
      <link>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</link>
      <pubDate>Fri, 16 Feb 2018 13:22:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</guid>
      <description>bundle.js:935 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. (found in &amp;lt;Root&amp;gt;) 解决方案：与entry属性平级添加
resolve: { alias: { &amp;#39;vue$&amp;#39;: &amp;#39;vue/dist/vue.esm.js&amp;#39; //该路径为node_modules下的vue目录 } } // 需要编译器 new Vue({ template: &amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39; }) // 不需要编译器 new Vue({ render (h) { return h(&amp;#39;div&amp;#39;, this.hi) } }) 出现警告的原因是使用了template属性。 文文点到为止，详情请直接访问中文官方文档https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释</description>
    </item>
    
    <item>
      <title>再聊docker和nodejs</title>
      <link>https://www.yuedun.wang/blogdetail/5a6ab02e260a5391e91a525f/</link>
      <pubDate>Fri, 26 Jan 2018 04:35:58 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a6ab02e260a5391e91a525f/</guid>
      <description>上一篇写到了如何在docker中运行nodejs，运行方式是在docker中安装了pm2来保证node服务宕机重启，这种方式更像是把docker当做虚拟机来使用。其实，既然使用了docker的话就可以不使用pm2来管理进程，因为docker自身可以充当守护进程，在node进程退出时进行重启。只要在启动docker容器时加上&amp;ndash;restart=always参数即可。例如：docker run -d --restart=always -p 3000:3000 mynode:1
没有pm2如何开启多进程 使用pm2可以开启多node进程，并且自带负载均衡，但是有个限制，pm2可以开启的进程数是CPU最大核心数。而使用docker的话就不会受限于此了，开启几十个上百个node服务都可以，然后通过nginx实现负载均衡。不过要手动开启几十上百个docker容器那怎么行？让我手动开启3个都很烦了，这时候就需要用到docker编排工具了，比如：Docker Swarm、Kubernetes、docker compose等，可以一键开启多个容器。但是使用编排工具启动docker端口就不确定了，是由编排工具随机开启服务端口的，这又要做到服务注册发现，所以这些工具结合起来使用。
哪一种部署方式支持并发高？ 使用jmeter在本机上进行了简单的并发测试，服务端进行简单的10万次hash计算，使用pm2开启4个实例，docker开启5个实例。docker使用Nginx做负载均衡，单次访问响应时间在1.2s~1.4s之间不等，在200个并发的情况下，两种模式响应时间相差不大，docker模式响应时间略占优势，大概快了0.1s。当并发数在300以上时两者的响应时间都有增加，此时docker部署方式出现了响应失败的情况，pm2就比较稳定了，虽然响应时间增加，但是并未出现过响应失败。 所以在单机上低并发docker还是有点优势，如果在高并发情况下还是pm2更稳定一些。（以上测试是单机上进行，准确性并不高）</description>
    </item>
    
    <item>
      <title>pm2日志记录和日志分割</title>
      <link>https://www.yuedun.wang/blogdetail/5a69a8301f395d7179259c45/</link>
      <pubDate>Thu, 25 Jan 2018 09:49:36 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a69a8301f395d7179259c45/</guid>
      <description>pm2介绍 pm2是nodejs进程管理工具，现在基本是node生产服务器的标准选择，可以帮助我们实现node多进程服务，开启的多个实例自动实现负载均衡。 最重要的是保证node单进程不会因为错误退出，作为守护进程保证nodejs服务不宕机。 总体来说就是有性能监控、自动重启、负载均衡的作用。
pm2-logrotate介绍 pm2本身是可以输出日志文件的，默认的文件路径：
error log path │ /home/username/.pm2/logs/app-error-0.log out log path │ /home/username/.pm2/logs/app-out-0.log 但是pm2的日志文件不能自动分割，这会导致一个文件不断变大，不但影响性能，查看这些日志也会带来麻烦。所以需要pm2-logrotate来实现自动分割日志。
安装pm2-logrotate pm2 install pm2-logrotate,是用pm2命令，不是npm命令
pm2-logrotate配置
max_size (默认 10M): 最大为多少时进行分割，例如: 10G, 10M, 10K retain (Defaults to all): This number is the number of rotated logs that are keep at any one time, it means that if you have retain = 7 you will have at most 7 rotated logs and your current one. compress (默认 false): 是否压缩日志 dateFormat (默认 YYYY-MM-DD_HH-mm-ss) : 日志格式 rotateModule (Defaults to true) : Rotate the log of pm2&amp;rsquo;s module like other apps workerInterval (Defaults to 30 in secs) : You can control at which interval the worker is checking the log&amp;rsquo;s size (minimum is 1) rotateInterval (Defaults to 0 0 * * * everyday at midnight): This cron is used to a force rotate when executed.</description>
    </item>
    
    <item>
      <title>最新版火狐Firefox Quantum 57没有pocket按钮</title>
      <link>https://www.yuedun.wang/blogdetail/5a615ab64bdc8ea471fd2ddd/</link>
      <pubDate>Fri, 19 Jan 2018 02:40:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a615ab64bdc8ea471fd2ddd/</guid>
      <description>从火狐量子浏览器开始，pocket按钮集成到了地址栏右侧，
如果你找不到，那么有可能是在浏览器配置中关闭了，开启方式：
地址栏中输入about:config,点击“我了解风险”继续，搜索“pocket.enabled”，如果是false双击修改为true就会出现。
其他情况可参考：https://help.getpocket.com/article/942-where-is-the-pocket-button-in-firefox</description>
    </item>
    
    <item>
      <title>在docker中运行nodejs</title>
      <link>https://www.yuedun.wang/blogdetail/5a6021fa4bdc8ea471fd2db0/</link>
      <pubDate>Thu, 18 Jan 2018 04:26:34 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a6021fa4bdc8ea471fd2db0/</guid>
      <description>首先看项目目录：
再看Dockerfile文件内容：
# 以最新的node为基础镜像 FROM hub.c.163.com/library/node:latest # 工作目录为app WORKDIR /app # 拷贝当前所在项目根目录到app目录 COPY . /app # 全局安装pm2 RUN npm install pm2 -g EXPOSE 8081 #使用pm2启动nodejs，如果没有--no-daemon参数docker启动后就退出 CMD [&amp;#34;pm2-runtime&amp;#34;, &amp;#34;dest/server.js&amp;#34;, &amp;#34;--no-daemon&amp;#34;] # ENTRYPOINT [&amp;#34;node&amp;#34;, &amp;#34;server.js&amp;#34;] 或者在Dockerfile中不添加CMD命令，可以在启动docker时执行命令： docker run --name ks -ti -p 8081:8081 kser:pm2 pm2-runtime dest/server.js
如果是后台运行的docker， docker run --name ks -d -p 8081:8081 kser:pm2 pm2-runtime dest/server.js -d选项是后台运行
需要进入到docker查看pm2运行情况 ，可以通过docker exec -ti ks /bin/sh查看运行的容器内部情况 </description>
    </item>
    
    <item>
      <title>pm2的fork模式和cluster模式的区别</title>
      <link>https://www.yuedun.wang/blogdetail/5a5f5bff4bdc8ea471fd2d9e/</link>
      <pubDate>Wed, 17 Jan 2018 14:21:51 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a5f5bff4bdc8ea471fd2d9e/</guid>
      <description>pm2的fork模式和cluster模式的区别
fork模式 pm2默认启动的是fork模式，是以单核单进程运行的，在fork模式下可以直接运行coffee-script，PHP，python。 参考：http://pm2.keymetrics.io/docs/tutorials/using-transpilers-with-pm2 运行非js语言必须设置运行模式为fork_mode
cluster模式 cluster模式可以根据CPU数量进行实例扩展，可以开启多进程而不需要修改代码。可提高程序性能和可靠性。类似于分布式系统，只不过是在单台机器上开启多实例，而pm2自带负载均衡。
** 使用方法 ** pm2 start app.js -i max 使用-i参数，max代表最大CPU进程数
也可以使用文件方式： processes.json文件：
{ &amp;#34;apps&amp;#34; : [{ &amp;#34;script&amp;#34; : &amp;#34;api.js&amp;#34;, &amp;#34;instances&amp;#34; : &amp;#34;max&amp;#34;, &amp;#34;exec_mode&amp;#34; : &amp;#34;cluster&amp;#34; }] } pm2 start processes.json</description>
    </item>
    
    <item>
      <title>本地producer和consumer连接不上远程kafka服务</title>
      <link>https://www.yuedun.wang/blogdetail/5a584429752e661009178c06/</link>
      <pubDate>Fri, 12 Jan 2018 05:14:17 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a584429752e661009178c06/</guid>
      <description>Hostname and port the broker will advertise to producers and consumers. If not set, it uses the value for &amp;ldquo;listeners&amp;rdquo; if configured. Otherwise, it will use the value returned from java.net.InetAddress.getCanonicalHostName(). advertised.listeners=PLAINTEXT://ip:9092
打开advertised.listeners=PLAINTEXT://ip:9092配置，ip为kafka服务ip</description>
    </item>
    
    <item>
      <title>推荐在Nodejs使用的java常用技术和工具</title>
      <link>https://www.yuedun.wang/blogdetail/5a430ce84aa3290e95cb0e67/</link>
      <pubDate>Tue, 26 Dec 2017 15:24:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a430ce84aa3290e95cb0e67/</guid>
      <description>作为Nodejs开发者可能会对java中常用的一些技术工具不太关心，主要原因大概除了语言级别的间隙就是Nodejs相对于java来说比较轻量级，大多用来开发简单系统，用不到其他工具。根据经验来说，开发相同功能的系统，Nodejs的开发周期和代码体量上也会比Java少太多，毕竟java出生年代长，生态丰富，如果不使用几个框架都感觉不是在开发系统。而Nodejs要开发一个web系统基本使用express或koa就差不多够了。所以对于Nodejs开发者来说，分布式，消息队列，远程调用等技术接触就少些。当然，不用这些技术其实也不会有太大影响，但是对于一个有追求有理想的码农来说我们的眼界不应该局限于系统能运行就行。 下面就来介绍一些可以在nodejs中使用的JAVA常用工具和技术。
elasticsearch ElasticSearch（以下简称ES）是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。看见了吧，这就是一个使用JAVA开发的全文搜索引擎，到底有什么用呢？就是可以提供像google和百度一样的搜索功能，就算不需要这样功能，也可以用于管理后台的字段搜索，大家知道数据库的搜索效率比较差，有索引的字段还好，没有的就很慢了，这时ES就可以派上用场了，把数据同步进ES,不论查询列表还是以字段搜索都是极快的，是redis缓存的很好补充。
ELK ELK（ElasticSearch,LogStash,Kibana）是三个工具的组合, Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。 Kibana是一个使用nodejs开发的web应用，用于查询和操作ES，就是一个ES的图形界面。 如果nodejs系统布署在多台服务器，那么查看日志是件很头疼的事，你不知道请求发送到哪一台服务器，需要挨个查看，如果服务超过5台，这绝对是噩梦。这时候ELK就是很好的解决方案，LogStash收集每一台服务器的日志统一存到ES中，利用ES的优点，查询任何关键字都很快很方便。
消息中间件（kafka） 拿用户注册为例，需要发送邮件，短信，这两个服务之间本没有关联关系，但我们的一贯作风是用户注册的时候调用邮件服务，短信服务，严谨一点会放在事务中操作，假如一个服务失败可能会让事务回滚，所有操作都失败。这是一种情况，另一种情况是如果要再注册后加积分，那么就得改代码，要是有更多服务要添加就得每次改代码发布，启停服务，不送积分了又要删代码，这就是耦合度太高导致的结果。使用消息中间件不仅能保证服务完整性还可以有效解耦，有兴趣可以去了解kafka,rabbitMQ,roketMQ等消息中间件。
远程调用RPC 通俗的来讲就是两台服务器A和B，A服务器直接调用B服务器上的函数，如果没有一个具体事例很难理解A服务器怎么可能调用到B服务器的函数，感兴趣可下载尝试：https://github.com/yuedun/nodejs-grpc 那么为什么要用rpc呢？A服务器要调用B服务的资源直接用http提供接口不就行了吗？其实http也算是一种远程调用，而且也比较简单直观，但是其效率较低，调用成本高，三次握手耗时，甚至请求头的数据量比请求体还大。那么就需要一种更高效的调用协议了——rpc。为什么需要RPC，而不是简单的HTTP接口
总结：以上的这些工具和技术和语言并没有绑定，java可以使用，nodejs也可以使用，推荐理由：投入成本小，使用收益高。</description>
    </item>
    
    <item>
      <title>为什么需要RPC，而不是简单的HTTP接口</title>
      <link>https://www.yuedun.wang/blogdetail/5a375f52e9a4cf008860c09b/</link>
      <pubDate>Mon, 18 Dec 2017 06:25:22 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a375f52e9a4cf008860c09b/</guid>
      <description>目前有很多Java的RPC框架，有基于Json的，有基于XML，也有基于二进制对象的。
论复杂度，RPC框架肯定是高于简单的HTTP接口的。但毋庸置疑，HTTP接口由于受限于HTTP协议，需要带HTTP请求头，导致传输起来效率或者说安全性不如RPC。
现在问题是，遇到怎样的瓶颈了才需要或者说更适合用RPC（比如像阿里这么大的请求并发量，简单的HTTP肯定达不到预期），但问题是大家所在的公司，要有像阿里这么大的量是比较少的，甚至说1/1000的量可能都没有，那我们还需要使用RPC吗？
技术应该不是为了使用新技术而去使用，而应该是旧技术存在某些瓶颈，存在难以支撑或者扩展性越老越差等问题暴露出来之后，用新技术来进行解决。
那RPC最大的优点，或者说它相比简单的HTTP接口，它的优势、更适合它的业务场景是怎样呢？简单的HTTP又哪里不足，哪些场景明显不太适合呢？
RPC=Remote Produce Call 是一种技术的概念名词. HTTP是一种协议,RPC可以通过HTTP来实现,也可以通过Socket自己实现一套协议来实现.所以楼主可以换一个问法,为何RPC还有除HTTP 之外的实现法,有何必要.毕竟除了HTTP实现外,私有协议不具备通用性.那么我想唯一的答案就在于HTTP不能满足其业务场景的地方,所以这个就要具体 案例具体分析了.
http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议 进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http 一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统 一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。
rpc是一种概念，http也是rpc实现的一种方式。论复杂度，dubbo/hessian用起来是超级简单的。最近用dubbo和hessian比较多，http的几乎都被废弃了。
至于为什么用，其实很简单，业务场景不一样。我最早的单位所有的代码都在一个工程里，一次要发布几百m的代码。这种架构是非常有利于小程序的。但是我们为什么要应用rpc层呢，一个功能，一套代码下来不就解决了么？我觉得有几个好处：
1 灵活部署 2 解耦 至于为什么，当你用到的时候，你会体会。
系统做大了，肯定是需要做微服务的。 现在我们做电商就是这样，单独有一个订单系统，支付系统，商品系统，用户系统。都是分开部署，单独上线的。 但我们交互是用HTTP接口来交互的，我想转用RPC，但问题是我现在还没发现为什么需要用RPC，我还没能理解它的作用和意义。
用http交互其实就已经属于rpc了。
RPC:远程过程调用。RPC的核心并不在于使用什么协议。RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。RPC的原理主要用到了动态代理模式，至于http协议，只是传输协议而已。简单的实现可以参考spring remoting，复杂的实现可以参考dubbo。
RPC是一个软件结构概念，是构建分布式应用的理论基础。就好比为啥你家可以用到发电厂发出来的电？是因为电是可以传输的。至于用铜线还是用铁丝还是其他 种类的导线，也就是用http还是用其他协议的问题了。这个要看什么场景，对性能要求怎么样。比如在java中的最基本的就是RMI技术，它是java原 生的应用层分布式技术。我们可以肯定的是在传输性能方面，RMI的性能是优于HTTP的。那为啥很少用到这个技术？那是因为用这个有很多局限性，首先它要 保证传输的两端都要要用java实现，且两边需要有相同的对象类型和代理接口，不需要容器，但是加大了编程的难度，在应用内部的各个子系统之间还是会看到 他的身影，比如EJB就是基于rmi技术的。这就与目前的bs架构的软件大相径庭。用http必须要服务端位于http容器里面，这样减少了网络传输方面 的开发，只需要关注业务开发即可。所以在架构一个软件的时候，不能一定根据需求选定技术。
转自：https://www.cnblogs.com/winner-0715/p/5847638.html</description>
    </item>
    
    <item>
      <title>请求发送到Nodejs服务器以后响应非常慢</title>
      <link>https://www.yuedun.wang/blogdetail/5a24ed6c2d700330ae669e89/</link>
      <pubDate>Mon, 04 Dec 2017 06:38:36 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a24ed6c2d700330ae669e89/</guid>
      <description>在项目中遇到过这种情况：请求发送后迟迟没有响应，但也并没有报错，在代码中一步步调试都没有发现问题，明明已经走到最后返回数据一步了客户端却没有返回。原因是在中间件中使用了redis或memcache缓存，然后连接缓存服务失败，然后就会一直等待，直到连接缓存超时才会继续执行后续操作。</description>
    </item>
    
    <item>
      <title>读写数据库与读写文件哪个更快？</title>
      <link>https://www.yuedun.wang/blogdetail/5a1d8147da5c711b612f4d88/</link>
      <pubDate>Tue, 28 Nov 2017 15:31:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a1d8147da5c711b612f4d88/</guid>
      <description>由于开发物流信息网，关于这个问题也是最近才想到的，就是到底读文件更快还是读数据库更快，能快多少，书生也搜索过，没见有网友就这个问题答复过， 也可能是太简单的缘故，我们本文还是来实测一下，由于时间关系，VC还没装，书生先用PHP测试了一下，下次有时间在C/C++上补充测试到本文来，因为 PHP的底层解析应该也是基于C的，所以估计两者环境测试结果差不多，小问题大收获，现在就来看一下测试过程及结果。
测试程序如下： //说明1：由于读数据库语句调用简单的封包函数两次，所以把读文件也改成连续调用两次，数据库记录ID为1就在第一条，并且唯一索引。
//说明2：测试两次一次是4K数据，一次是整形数据
set_time_limit(0); function fnGet($filename) { $content = file_get_contents($filename); return $content; } function fnGetContent($filename) { $content = fnGet($filename); return $content; } $times=100000; echo &amp;#39;数据库查询结果：&amp;lt;br/&amp;gt;&amp;#39;; //--------------------------------- $begin=fnGetMicroTime(); for($i=0;$i&amp;lt;$times;$i++) { $res=$dbcon-&amp;gt;mydb_query(&amp;#34;SELECT log_Content FROM blog WHERE log_ID=&amp;#39;1&amp;#39;&amp;#34;); $row=$dbcon-&amp;gt;mydb_fetch_row($res); $content=$row[0]; } echo &amp;#39;fetch_row &amp;#39;.$times.&amp;#39; 次时间：&amp;lt;font color=red&amp;gt;&amp;#39;.(fnGetMicroTime()-$begin).&amp;#39;&amp;lt;/font&amp;gt;秒&amp;lt;br/&amp;gt;&amp;#39;; //--------------------------------- $begin=fnGetMicroTime(); for($i=0;$i&amp;lt;$times;$i++) { $res=$dbcon-&amp;gt;mydb_query(&amp;#34;SELECT log_Content FROM blog WHERE log_ID=&amp;#39;1&amp;#39;&amp;#34;); $row=$dbcon-&amp;gt;mydb_fetch_array($res); $content=$row[&amp;#39;log_Content&amp;#39;]; } echo &amp;#39;fetch_array &amp;#39;.$times.&amp;#39; 次时间：&amp;lt;font color=red&amp;gt;&amp;#39;.(fnGetMicroTime()-$begin).&amp;#39;&amp;lt;/font&amp;gt;秒&amp;lt;br/&amp;gt;&amp;#39;; //--------------------------------- $begin=fnGetMicroTime(); for($i=0;$i&amp;lt;$times;$i++) { $res=$dbcon-&amp;gt;mydb_query(&amp;#34;SELECT log_Content FROM blog WHERE log_ID=&amp;#39;1&amp;#39;&amp;#34;); $row=$dbcon-&amp;gt;mydb_fetch_object($res); $content=$row-&amp;gt;log_Content; } echo &amp;#39;fetch_object &amp;#39;.</description>
    </item>
    
    <item>
      <title>Dockerfile CMD命令没有执行npm start</title>
      <link>https://www.yuedun.wang/blogdetail/5a1be456da5c711b612f4d39/</link>
      <pubDate>Mon, 27 Nov 2017 10:09:26 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a1be456da5c711b612f4d39/</guid>
      <description>Dockerfile
FROM hub.c.163.com/public/nodejs:6.11.0 WORKDIR /app COPY . /app RUN npm install EXPOSE 3000 # CMD [&amp;#34;npm&amp;#34;, &amp;#34;start&amp;#34;] ENTRYPOINT [&amp;#34;npm&amp;#34;, &amp;#34;start&amp;#34;] docker ps:
CONTAINER ID IMAGE COMMAND 59988bd90894 myfd &amp;#34;/bin/sh -c &amp;#39;/usr/...&amp;#34; 在Dockerfile中配置了CMD [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;],docker ps后显示COMMAND为&amp;quot;/bin/sh -c &#39;/usr/...&amp;quot; 改为ENTRYPOINT [&amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot;]就可以了</description>
    </item>
    
    <item>
      <title>sequelize外键关联报错SequelizeDatabaseError: Cant write; duplicate key in table #sql-454_d</title>
      <link>https://www.yuedun.wang/blogdetail/5a06d5989f088c0683b93d26/</link>
      <pubDate>Sat, 11 Nov 2017 10:48:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a06d5989f088c0683b93d26/</guid>
      <description>Assistance.belongTo(User)会报以下错误：
ALTER TABLE `assistance` ADD CONSTRAINT `assistance_user_id_foreign_idx` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE NO ACTION ON UPDATE CASCADE; Unhandled rejection SequelizeDatabaseError: Can&amp;#39;t write; duplicate key in table &amp;#39;#sql-454_d&amp;#39; at Query.formatError (/home/hale/workspace/issue-tracking-system/node_modules/sequelize/lib/dialects/mysql/query.js:223:16) at Query.connection.query [as onResult] (/home/hale/workspace/issue-tracking-system/node_modules/sequelize/lib/dialects/mysql/query.js:55:23) at Query.Command.execute (/home/hale/workspace/issue-tracking-system/node_modules/mysql2/lib/commands/command.js:30:12) at Connection.handlePacket (/home/hale/workspace/issue-tracking-system/node_modules/mysql2/lib/connection.js:515:28) at PacketParser.onPacket (/home/hale/workspace/issue-tracking-system/node_modules/mysql2/lib/connection.js:94:16) at PacketParser.executeStart (/home/hale/workspace/issue-tracking-system/node_modules/mysql2/lib/packet_parser.js:77:14) at Socket.&amp;lt;anonymous&amp;gt; (/home/hale/workspace/issue-tracking-system/node_modules/mysql2/lib/connection.js:102:29) at emitOne (events.js:115:13) at Socket.emit (events.js:210:7) at addChunk (_stream_readable.js:264:12) at readableAddChunk (_stream_readable.js:251:11) at Socket.Readable.push (_stream_readable.js:209:10) at TCP.onread (net.</description>
    </item>
    
    <item>
      <title>typescript开发sequelize返回ModelInstance或null值无法获取属性值</title>
      <link>https://www.yuedun.wang/blogdetail/59f4a228f99acfed859c831e/</link>
      <pubDate>Sat, 28 Oct 2017 15:28:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/59f4a228f99acfed859c831e/</guid>
      <description>从图片中的代码可以看出 let userRecord = await item.getUser();获取到的是Bluebird&amp;lt;UserInstance | null&amp;gt;类型，然后在下面获取对象属性的时候报错，错误信息是：
[ts] Object is possibly &amp;#39;null&amp;#39;. let userRecord: UserInstance | null 说对象可能是null，所以无法获取其中的属性。遇到这种情况请设置typescript的编译选项，tsconfig.json文件中的 &amp;quot;strictNullChecks&amp;quot;: true, /* Enable strict null checks. */ 默认是true，即严格null检查，设置为falsse即可。</description>
    </item>
    
    <item>
      <title>sequelize.js不能将驼峰camelCased命名转化为下划线underscored命名</title>
      <link>https://www.yuedun.wang/blogdetail/59eab23989faeadc30eac826/</link>
      <pubDate>Sat, 21 Oct 2017 02:34:33 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/59eab23989faeadc30eac826/</guid>
      <description>定义Model的时候有这样两个参数： underscored,underscoredAll,
Converts all camelCased columns to underscored if true. Will not affect timestamp fields named explicitly by model options and will not affect fields with explicitly set field option
其意思是说转化所有驼峰字段为下划线字段，但实际情况并不是如此。
var Model = sequelize.define&amp;lt;ModelInstance, ModelAttributes&amp;gt;( &amp;#39;Assistance&amp;#39;, { title: Sequelize.STRING, description: Sequelize.STRING, fullName: Sequelize.STRING }, { underscored: true, tableName: &amp;#39;assistance&amp;#39;, charset: &amp;#39;utf8&amp;#39;, collate: &amp;#39;utf8_unicode_ci&amp;#39; } ); CREATE TABLE IF NOT EXISTS `assistance` (`id` INTEGER NOT NULL auto_increment , `title` VARCHAR(255), `description` VARCHAR(255), `fullName` VARCHAR(255), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE utf8_unicode_ci; 其中fullName字段在创建表的时候还是和模型中保持一致，并没有转换为full_name，underscored的设置其实只影响到了createdAt和updatedAt等内置字段。 在github上也有相关讨论：https://github.</description>
    </item>
    
    <item>
      <title>Unhandled rejection CastError: Cast to ObjectId failed for value catalog at path _id for model Blog</title>
      <link>https://www.yuedun.wang/blogdetail/599cf46c1bffdb00880597b3/</link>
      <pubDate>Wed, 23 Aug 2017 03:20:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/599cf46c1bffdb00880597b3/</guid>
      <description>Unhandled rejection CastError: Cast to ObjectId failed for value &amp;#34;catalog&amp;#34; at path &amp;#34;_id&amp;#34; for model &amp;#34;Blog&amp;#34; at MongooseError.CastError (e:\workspace\yuedun_ts\node_modules\mongoose\lib\error\cast.js:27:11) at ObjectId.cast (e:\workspace\yuedun_ts\node_modules\mongoose\lib\schema\objectid.js:149:13) at ObjectId.SchemaType._castForQuery (e:\workspace\yuedun_ts\node_modules\mongoose\lib\schematype.js:1064:15) at ObjectId.castForQuery (e:\workspace\yuedun_ts\node_modules\mongoose\lib\schema\objectid.js:189:15) at ObjectId.SchemaType.castForQueryWrapper (e:\workspace\yuedun_ts\node_modules\mongoose\lib\schematype.js:1021:15) at cast (e:\workspace\yuedun_ts\node_modules\mongoose\lib\cast.js:269:32) at Query.cast (e:\workspace\yuedun_ts\node_modules\mongoose\lib\query.js:3103:12) at Query._castConditions (e:\workspace\yuedun_ts\node_modules\mongoose\lib\query.js:1144:10) at Query._findOne (e:\workspace\yuedun_ts\node_modules\mongoose\lib\query.js:1346:8) at e:\workspace\yuedun_ts\node_modules\mongoose\node_modules\kareem\index.js:250:8 at e:\workspace\yuedun_ts\node_modules\mongoose\node_modules\kareem\index.js:23:7 at nextTickCallbackWith0Args (node.js:489:9) at process._tickCallback (node.js:418:13) From previous event: at Query.exec (e:\workspace\yuedun_ts\node_modules\mongoose\lib\query.js:2897:17) at Query.then (e:\workspace\yuedun_ts\node_modules\mongoose\lib\query.js:2945:15) at Object.default_1 [as default] (e:\workspace\yuedun_ts\utils\viewer-log.ts:21:10) at e:\workspace\yuedun_ts\app.ts:53:14 at Layer.</description>
    </item>
    
    <item>
      <title>open() is deprecated in mongoose &gt;= 4.11.0, use openUri()</title>
      <link>https://www.yuedun.wang/blogdetail/5996a2dc9205bd72e7290ebb/</link>
      <pubDate>Fri, 18 Aug 2017 08:18:36 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5996a2dc9205bd72e7290ebb/</guid>
      <description>`open()` is deprecated in mongoose &amp;gt;= 4.11.0, use `openUri()` instead, or set the `useMongoClient` option if using `connect()` or `createConnection()`. See http://mongoosejs.com/docs/connections.html#use-mongo-client Db.prototype.authenticate method will no longer be available in the next major release 3.x as MongoDB 3.6 will only allow auth against users in the admin db and will no longer allow multiple credentials on a socket. Please authenticate using MongoClient.connect with auth credentials. 修改连接参数：
url = `mongodb://${this.username}:${this.password}@${this.host}:${this.port}/${this.dbName}`; const opts = { // autoReconnect: false,//默认true // reconnectTries: 30,//尝试重连，默认30次 // reconnectInterval: 1000, //重连间隔，默认1000毫秒 loggerLevel: &amp;#34;warn&amp;#34;, //error/warn/info/debug useMongoClient: true }; mongoose.</description>
    </item>
    
    <item>
      <title>windows好用的bash工具——ConEmu</title>
      <link>https://www.yuedun.wang/blogdetail/598aaf0525207f400eeb1b87/</link>
      <pubDate>Wed, 09 Aug 2017 06:43:17 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/598aaf0525207f400eeb1b87/</guid>
      <description>其实git-bash-for-windows这个git bash工具已经很好用了，不过对于平时需要开3-5的bash窗口的我来说就比较烦了，一直要不停的切换窗口，所以想找一款像linux terminal一样可以多开的工具，幸好有这样的工具，那就是ConEmu。
使用前需要一些配置，不配置也没关系，就是使用起来不方便，我是按照的习惯完全配置成了git bash的使用方式。
第一步: 第二步： 配置本地git bash地址（此步骤可适当配置 第三步： 设置ConEmu启动即打开bash而非windows cmd 第四步： 如果前面都没问题，可以设置自动保存打开的窗口，以便下次打开即可使用 最后： 根据个人喜好修改字体等 这样就可以完美使用git bash，不论是自动补全还是颜色主题都和git bash无异。
另外cmder其实也是我使用过的一个不错的工具，同时推荐试用。</description>
    </item>
    
    <item>
      <title>Sequelize批量插入数据</title>
      <link>https://www.yuedun.wang/blogdetail/5967123a3d2aae2ccfdc61a3/</link>
      <pubDate>Thu, 13 Jul 2017 06:24:58 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5967123a3d2aae2ccfdc61a3/</guid>
      <description>sequelize提供了批量插入数据的方法：Model.bulkCreate([…object])。
User.bulkCreate([ { username: &amp;#39;barfooz&amp;#39;, isAdmin: true }, { username: &amp;#39;foo&amp;#39;, isAdmin: true }, { username: &amp;#39;bar&amp;#39;, isAdmin: false } ]).then(() =&amp;gt; { // Notice: There are no arguments here, as of right now you&amp;#39;ll have to... return User.findAll(); }).then(users =&amp;gt; { console.log(users) // ... in order to get the array of user objects }) </description>
    </item>
    
    <item>
      <title>npm ERR! Error: EPERM: operation not permitted</title>
      <link>https://www.yuedun.wang/blogdetail/59532a3233c3c869639761db/</link>
      <pubDate>Wed, 28 Jun 2017 04:01:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/59532a3233c3c869639761db/</guid>
      <description>windows下npm install安装依赖的时候出现下面的错误：
npm ERR! Windows_NT 6.1.7601 npm ERR! argv &amp;#34;D:\\Program Files\\nodejs\\node.exe&amp;#34; &amp;#34;D:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js&amp;#34; &amp;#34;install&amp;#34; &amp;#34;yog2@1.0.0&amp;#34; npm ERR! node v4.8.0 npm ERR! npm v2.15.11 npm ERR! path C:\Users\Administrator\AppData\Roaming\npm-cache\images\3.0.0\package.tgz.1683947925 npm ERR! code EPERM npm ERR! errno -4048 npm ERR! syscall rename npm ERR! Error: EPERM: operation not permitted, rename &amp;#39;C:\Users\Administrator\AppData\Roaming\npm-cache\images\3.0.0\package.tgz.1683947925&amp;#39; -&amp;gt; &amp;#39;C:\Users\Administrator\AppData\Roaming\npm-cache\images\3.0.0\package.tgz&amp;#39; npm ERR! at Error (native) npm ERR! { [Error: EPERM: operation not permitted, rename &amp;#39;C:\Users\Administrator\AppData\Roaming\npm-cache\images\3.0.0\package.tgz.1683947925&amp;#39; -&amp;gt; &amp;#39;C:\Users\Administrator\AppData\Roaming\npm-cache\images\3.0.0\package.tgz&amp;#39;] npm ERR! errno: -4048, npm ERR!</description>
    </item>
    
    <item>
      <title>2017年上海办理居住证</title>
      <link>https://www.yuedun.wang/blogdetail/594758a99d957900957ff024/</link>
      <pubDate>Mon, 19 Jun 2017 04:52:57 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/594758a99d957900957ff024/</guid>
      <description>说起居住证这东西，对于来沪务工的人平时没什么用，但是到一些关键时候却是不可缺少的，比如考驾照，子女上学，落户等。我也是来上海几年了都没办过，最近为了孩子上学做准备不得已就赶紧办了，之前之所以没办就是觉得麻烦。
办居住证麻烦的是准备材料，其实材料准备好了一小时甚至半小时就能办好。要准备的资料当中恐怕最难的就是房东方面了，如果房东OK其他倒是很简单。
房东方面
房东本人 房东身份证 房产证 房产所有人身份证 租赁合同 备案证明 按照上海市条文规定，房屋租赁备案证明是要缴纳5%的房租税的，这是要房东缴纳的，所以很多房东恐怕不太愿意，但实际上目前没有具体单位来收取这个税的，如果房东还是害怕收税那你们可以商量好另拟一份房租比较低的合同。办理居住证房东还需要准备身份证，房产证，如果房产为多人共同所有，那么就需要其他共有人的身份证，其实户口本是不行的，因为要刷身份证信息的。如果无法提供其他人身份证，那么就让其他人写一份委托书，这个委托书嘛！其实是不是真正的委托人写的无所谓。如果办事处还是不能接受，那么就让房东现场写一份承诺书，大概内容就是说房东可以全权代理其他人来出租这一套房产，保证今后不会产生分歧，如有分歧可以承担一切责任。其实就是保证这套房子不是由房东私自出租就行。有些房子是由二房东来出租的，没有房产证，这种情况可以先去街道办事处问一下。房东准备这些东西其实就是为了办理房屋租赁备案证明。
自己方面
身份证，2份复印件 租赁合同 劳动合同 1份复印件 近6个月社保单 在办理之前需要做一些准备，先去居委问一下街道办事处地址，也可以自己网上查，别去错地方，比如我住的地方近处就有一个街道办，但并不属于这个街道办事处管理。然后关心的可能是再哪办房屋租赁备案证明，我所在的甘泉街道办事处就是在一块的，我想其他地方也是一样的，要不然去两个地方跑就太不方便了。</description>
    </item>
    
    <item>
      <title>go语言实现继承，重写</title>
      <link>https://www.yuedun.wang/blogdetail/5944b81d9d957900957feff6/</link>
      <pubDate>Fri, 16 Jun 2017 15:03:25 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5944b81d9d957900957feff6/</guid>
      <description>以实际遇到过得情况为例，用户的数据结构中有类型为日期类型time.Time的createdAt属性，经过反复的格式化处理，在页面上输出的还是2017-05-31 06:49:09 +0800 CST这种格式，所以猜想日期类型是不能直接输出2017-05-31 06:49:09格式的，只能输出格式化后的字符串类型。于是利用go的继承将User的数据结构继承都UserPojo里，再单独对createdAt进行修改，重写为string类型。
package main import &amp;#34;fmt&amp;#34; import &amp;#34;time&amp;#34; type User struct { name string age int createdAt time.Time } type UserPojo struct { User createdAt string } func (user *User) getName(){ fmt.Println(&amp;#34;获取用户名：&amp;#34;, user.name) } func main() { user := new(User) user.name=&amp;#34;张三&amp;#34; user.age=26 user.createdAt=time.Now() fmt.Println(&amp;#34;user.createdAt&amp;#34;,user.createdAt) userpj := new(UserPojo) userpj.User = *user userpj.createdAt = user.createdAt.Format(&amp;#34;2006-01-02 15:04:05&amp;#34;) fmt.Println(&amp;#34;userpj.createdAt&amp;#34;,userpj.createdAt) } //输出 //user.createdAt 2017-06-17 10:39:29.5294 +0800 CST //userpj.createdAt 2017-06-17 10:39:29 在go的继承中有一点需要注意，使用结构体struct字面量赋值会出现找不到属性的问题：
# command-line-arguments .</description>
    </item>
    
    <item>
      <title>mongoose自动添加createdAt和updatedAt</title>
      <link>https://www.yuedun.wang/blogdetail/593b6b37b787b03177cfff16/</link>
      <pubDate>Sat, 10 Jun 2017 04:44:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/593b6b37b787b03177cfff16/</guid>
      <description>export var CommentSchema: Schema = new Schema({ Id: String, content: String, status: { type: Boolean, default: true } }, { timestamps: true}); 添加{ timestamps: true}选项即可，如果需要自定义属性名称可以直接指定： { timestamps: {createdAt:&#39;created_at&#39;, updatedAt:&#39;updated_at&#39;}}</description>
    </item>
    
    <item>
      <title>基于beego框架的go项目目录结构</title>
      <link>https://www.yuedun.wang/blogdetail/59278639c1abbe00911df03c/</link>
      <pubDate>Thu, 25 May 2017 15:34:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/59278639c1abbe00911df03c/</guid>
      <description>原生的go推荐目录是
├─bin ├─pkg ├─src bin目录放二进制文件，可以是编译后的可执行文件，也可以是安装的第三方命令行，比如beego的命令行工具会安装在bin目录。pkg存放第三方依赖，src存放代码文件。单个项目没什么疑问，就这么存放，主要是有多个项目的时候对新手来说会有点迷糊，就像我，建立了两个项目就像进了迷宫，提交到git上就更乱了，究其原因是把bin目录和pkg目录当做项目源码的一部分了。其实这两个目录是作为公共目录存在的，多个项目公用。src目录下也是可以有多个项目的，每个项目有自己独立的文件夹。
.src\ ├─project1 ├─project2 ├─project3 所以在创建项目和克隆代码时都是在src目录下进行，不能把bin目录和pkg目录提交到git上。
但是beego并没有完全遵循这一原则，它将二进制文件直接编译到了项目源码目录下，或许可配置生成目录，暂时没有了解到，所以需要在.gitignore中排除掉生成的可执行文件，否则提交的时候就比较费时了。</description>
    </item>
    
    <item>
      <title>婴儿学步牵引绳需不需要？</title>
      <link>https://www.yuedun.wang/blogdetail/592195fed65a0126c7cdf455/</link>
      <pubDate>Sun, 21 May 2017 13:28:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/592195fed65a0126c7cdf455/</guid>
      <description>我女儿12个月开始学走路，由于她身高还很低，所以需要大人弯着腰搀扶着，时间长了大人的腰比较累，当时就在网上买了个绑带。 本以为能轻松点，结果发现排不上用场，因为实在不好用，宝宝根本不会老实的配合，她一感觉到胸前有个东西扶着她，就整个人爬下来了，所有重点都放在牵引绳上，所以大人就只能提着，而且由于刚学走路，也不能稳当的走，总是东倒西歪，牵引绳其实不能保证宝宝的平衡，反而会过于依赖绑带，结果就导致失去平衡类似于一只脚在地上一只脚翘起来打转，也容易勒到胳膊。
宝宝学走路一般一个月就能自己走了，所以我觉得没必要用这个。</description>
    </item>
    
    <item>
      <title>RockMongo使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/591ea6966af6717b614f9b2b/</link>
      <pubDate>Fri, 19 May 2017 08:02:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/591ea6966af6717b614f9b2b/</guid>
      <description>RockMongo是一个PHP5写的MongoDB管理工具。
鉴于百度bce的mongodb数据使用了RockMongo来管理数据，就以此来说明。
查询操作 点击某个collection后的默认画面：
查询界面很简单，关键是怎么写查询语句？
点击文本可以查看所有数据字段，查询title为“测试”文档：
array( &amp;#39;title&amp;#39; =&amp;gt; &amp;#39;测试&amp;#39; ) 模糊查询：
array( &amp;#39;title&amp;#39;=&amp;gt; new MongoRegex(&amp;#34;/测试/i&amp;#34;) ) 字段名要加引号，中间使用=&amp;gt;而不是使用:分割，需要查询的值也需要注意，字符串加引号，数字不加，如果类型不匹配就会查不出数据。查询结果有一条数据
修改操作 动作中选择“modify”
再查询一下
基本操作就是这样，删除操作不用说也应该能知道怎么做了。</description>
    </item>
    
    <item>
      <title>nodejs中promise的if流程控制</title>
      <link>https://www.yuedun.wang/blogdetail/591c5eac35b6751981e4681e/</link>
      <pubDate>Wed, 17 May 2017 14:31:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/591c5eac35b6751981e4681e/</guid>
      <description>Promise虽然解决了原生回调的金字塔写法，但是并不能很好的处理if else流程，相比起Java等同步方式编写还是有点难度，不过还是有方法写出优雅的代码。 下面用了一个不复杂的例子来说明：
假设一个人去银行开户，存钱，如果这个人是普通用户，需要先1.排队等候，2.开户，3.存钱。 如果是VIP用户，直接进行第2，3步操作。 如果普通用户是黑名单用户不给开户办卡。
var fs = require(&amp;#34;fs&amp;#34;); function queue(){ return new Promise((resolve, reject)=&amp;gt;{ fs.readFile(&amp;#34;../queue.txt&amp;#34;, &amp;#34;utf8&amp;#34;, (err, data)=&amp;gt;{ if (err) reject(err); console.log(data.toString()); resolve(data.toString()); }) }) } function account(id){ return new Promise((resolve, reject)=&amp;gt;{ fs.writeFile(&amp;#39;../account.txt&amp;#39;, id+&amp;#39;一个新账户&amp;#39;, (err) =&amp;gt; { if (err) reject(err); console.log(&amp;#39;办卡成功!&amp;#39;); resolve(); }); }) } function money(id){ return new Promise((resolve, reject)=&amp;gt;{ fs.writeFile(&amp;#39;../money.txt&amp;#39;, id+&amp;#39;存了10万&amp;#39;, (err) =&amp;gt; { if (err) reject(err); console.log(&amp;#39;存款成功!&amp;#39;); resolve(); }); }) } //入口 function enter(id) { Promise.</description>
    </item>
    
    <item>
      <title>typescript泛型的使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/590c93d3266e3f1c8fd4aa83/</link>
      <pubDate>Fri, 05 May 2017 15:01:39 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/590c93d3266e3f1c8fd4aa83/</guid>
      <description>typescript（以下简称ts）中泛型如何使用？（以下代码为ts书写） 个人认为开发语言中一些高级特性如果在不太理解的情况下不使用也无妨，无非是代码写的多一点，烂一点。但是我想作为程序猿大家还是会有所追求的。就以泛型来说，不使用也能正常开发，只不过在个别情况下需要写几份看起来相同的代码。比如在不使用泛型的情况下要求函数参数为number类型，并且返回number。
function a(args: number ): number { return args; } console.log(a(123)); 又有另外一个要求，参数为string类型，并且返回string
function b(args: string ): string { return args; } console.log(b(&amp;#34;sdg&amp;#34;)); 如果还有其他类似的要求，就要不停的写类似格式的代码，那么改进一下：
function c(args: any ): any { return args; } console.log(c(&amp;#34;sdg&amp;#34;)); 这样是可以接受任何类型参数并且返回，但缺点是可以知道能传入任何类型而不知道返回的具体类型是什么，只知道是any类型。将上面的c函数稍作修改：
function c(args: any ): any { let n = args + &amp;#34;变成了字符串&amp;#34;; //甚至更多的处理 return n; } console.log(c(1)); c函数参数是数字，返回的可能是其他类型。 知道前面几种写法的不足再对比一下泛型的写法：
function d&amp;lt;A&amp;gt;(args: A ): A { let n = args + &amp;#34;变成了字符串&amp;#34;; //甚至更多的处理 return n; } console.</description>
    </item>
    
    <item>
      <title> error TS7010: skipTo, which lacks return-type annotation, implicitly has an any return type.</title>
      <link>https://www.yuedun.wang/blogdetail/58f8c22ae17cc00088e5ba4f/</link>
      <pubDate>Thu, 20 Apr 2017 14:14:02 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/58f8c22ae17cc00088e5ba4f/</guid>
      <description>node_modules/nodemailer/node_modules/socks/node_modules/smart-buffer/typings/index.d.ts(351,5): error TS7010: &amp;#39;skipTo&amp;#39;, which lacks return-type annotation, implicitly has an &amp;#39;any&amp;#39; return type. 缺少返回类型的注释，隐含地具有&amp;rsquo;any&amp;rsquo;返回类型。 tsconfig.json配置文件中noImplicitAny设置为false,该选项的意思是：在表达式和声明上有隐含的&amp;rsquo;any&amp;rsquo;类型时报错。</description>
    </item>
    
    <item>
      <title>手机丢前必做的两件事</title>
      <link>https://www.yuedun.wang/blogdetail/5875a127ea6fa8193f372f35/</link>
      <pubDate>Wed, 11 Jan 2017 03:06:15 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5875a127ea6fa8193f372f35/</guid>
      <description>很多段子手都曾经发过《手机丢后必做的N件事》这类教程，比如：致电运营商挂失手机号；致电银行冻结手机网银；手机解绑支付宝；微信冻结账号；修改微博、微信、QQ等密码；找手机运营商补手机卡；等等等等，实际上，这类教程所要求的事情都不是必要的，真正要做到丢失后手机安全，只需要事前做两件事情：设置指纹密码和SIM卡密码。
以iPhone为例，一般都会设置“查找我的iPhone”功能，由于iPhone有GPS定位功能，小偷如果偷到手机不关机的话，会被GPS定位追踪，因此绝大多数小偷拿到手机后做的第一件事情往往是关机，这正好让指纹锁屏密码和SIM卡PIN码发挥最大作用：如果重新开机，必须要输入手机密码才能开机，同时，SIM卡处于锁定状态，需要输入PIN码才能正常通信，输错3次PIN码后就只能用PUK码来解锁，把SIM卡拔出来查到别的手机上，也需要输入SIM卡PIN码才能通讯，也就是说，不知道PIN码，这个SIM卡就无法接收短信和拨打电话，因此小偷就无法通过这个SIM卡来盗取用户的网银、支付宝、微信上的财产，甚至，小偷连这个手机的手机号码都无法获得，更不用说盗取微信和QQ密码了。
当然，丢失iPhone手机的用户还需要补SIM卡和设置远程抹除iPhone内容最安全，千万不要关闭“查找我的iPhone”功能，忽略那些以苹果名义发来的钓鱼邮件和短信。
以下是iPhone指纹解锁功能设置方法和iPhone的修改SIM卡密码的方法：
指纹密码 指纹天生就是一种个人认证工具，虽然人人都有指纹，但各不相同，据说，现在还没有发现两个指纹完全相同的人。随着年龄的增长，指纹的纹样不会发生变化。因此，使用指纹做为身份验证是非常理想的。
iPhone指纹解锁功能设置
iPhone设置指纹密码的具体方法是：
第一步：依次进入iPhone的“设置”，然后再找到，并点击进入“Touch ID与密码”设置。
第二步：接下来需要输入一次四位数字的iPhone6手机密码，这个密码就是手机解锁密码，输入密码后，就可以进入iPhone指纹识别设置界面了。然后我们就可以开始录入指纹了，点击下方的“添加指纹”开始添加。
第三步：接下来我们按照提示开始录入指纹，请将需要设置指纹的手指放置在iPhone屏幕底部的指纹识别Home键上，按照提示放置上去，再移开手指，反复几次，等待指纹录入完成。
第四步：以上操作完成就，就可以成功完成一个手指的指纹录入，在返回的指纹设置中，已经可以看到有一个“指纹1”的记录了，如果还想录入多个指纹信息，继续点击下方的“添加指纹”，按照上面的步骤完成其他指纹信息录入即可。
iPhone最多支持设置5个指纹，可以同时录入自己的和自己亲人的，另外录入成功的指纹1和指纹2名称，还可以自行修改名称。指纹信息录入成功后，在iTunes Stor与App Store安装应用开启指纹识别即可。
SIM卡密码
SIM卡是（Subscriber Identity Module 客户识别模块）即用户身份识别卡，是手机的一张个人资料卡。SIM卡通常用来存储用户的电话号码、安全数据、通讯费用以及能让运营商判定用户是否是其公司客户的数据。当用户更换新的手机，可以直接插入旧手机原有的SIM卡，即可继续享受之前的各项手机服务。
SIM卡的PIN码（Personal Identification Number 个人识别码）主要用于保护SIM卡的安全性和隐私性，当手机重启、或者插拔SIM卡后，需要输入最正确的SIM卡PIN码才能使用SIM卡的通讯功能（拨打电话、收发短信等操作），当输入三次失败后，SIM卡则会被锁定，而需要输入PUK码（Personal Unlock Key 个人解锁码）进行解锁，PUK码共有10次输入机会，输错10次后，SIM卡会自动启动自毁程序，使SIM卡失效。
修改设置SIM卡PIN码的步骤是：设置 - 电话 - SIM卡PIN码，将其启用。修改PIN码要先输入原有PIN码，SIM卡的默认PIN码为0000或1234，如果都不对的话，可以输错3次，使用PUK码强制修改PIN码。
修改SIM卡PIN码
修改SIM卡PIN码
PUK码由8位数字组成，这是用户无法更改的。一些SIM卡的PUK码是用户在购卡时随卡附带的，通常在卡套背后附有PUK码，也可以登录运营商的网上营业厅，在自助服务里通常会提供查询PUK码的功能。实在找不到的话，也可以致电SIM卡所属运营商的服务热线，客服人员也可以提供查询PUK码的服务。
SIM卡的PIN码有效地防止了盗用SIM卡的情况发生，使用户的正常通信得到了可靠保障。设置了PIN码之后，当用户手机丢失后，别人无法通过取出SIM卡插入另一部手机，来进行原SIM卡的通讯功能（拨打电话、收发短信等）。因此，建议所有手机用户都立刻启用SIM卡的PIN码。
iPhone被偷
iPhone丢失前后的处理流程 1、手机的指纹锁屏（密码锁屏）和SIM卡PIN码应该同时启用，缺一不可。如果手机的SIM卡设置了PIN码，那么这个SIM卡插入另一个手机就需要PIN码解锁，重启手机也要PIN码解锁，不解锁无法进行通讯，这从一定程度上保证了手机通讯的安全性，SIM卡默认的PIN码通常是1234，建议手机用户都修改一下这个PIN码。锁屏密码不要使用简单密码，使用数字字母组合长密码，有条件的话建议选择支持指纹密码的iPhone，其使用体验远远优于普通的密码解锁。
2、开启“查找我的iPhone”功能。iCloud设置强密码。iCloud开通二次验证。
3、支付宝等应用启用指纹密码。
4、发现手机丢失后，立即打电话给移动运营商，挂失SIM卡。登录iCloud的“查找我的iPhone”功能，启用“丢失模式”。
5、登录appleid网站，将该手机从“受信任设备”中移除。
6、忽略那些以苹果名义发来的钓鱼邮件和短信。
7、如果手机确认无法找回，在“查找我的iPhone”里，使用“抹掉iPhone”功能。
8、申请一个新的SIM卡并启用。
总结：iPhone丢失后应该做什么？丢失前：设置指纹锁屏和SIM卡PIN码；开启“查找我的iPhone”功能。iCloud设置强密码。丢失后：打电话给移动运营商，挂失SIM卡。登录iCloud，启用“丢失模式”（无法找回的话就用“抹掉iPhone”）。电话冻结绑定的支付宝和网银。申请一个新的SIM卡并启用。
作者：月光 (williamlong) | 来自：月光博客</description>
    </item>
    
    <item>
      <title>使用typescript开发nodejs的环境搭建（二）</title>
      <link>https://www.yuedun.wang/blogdetail/58243e338fa26c04fd124ee6/</link>
      <pubDate>Thu, 10 Nov 2016 09:30:27 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/58243e338fa26c04fd124ee6/</guid>
      <description>完成了最基本的项目框架以后就是配置编辑器和编译选项，在没有特别配置的情况下，根目录下执行tsc会在ts后缀文件同级目录下生成js后缀的文件， 这样也没什么不可以，但是在编辑器列表中看着有点混乱，生成的js文件是不建议直接修改的，就算修改了下次修改ts文件编译后也会重置文件内容。 所以还是单独有个文件夹存放生成的js文件，这时就要配置tsconfig.json文件了。tsconfig.json文件可以通过tsc --init命令生成，自动生成内容比较简单，是可以直接使用的。 以下的配置是经过一些特别需求配置的，可以直接复制一下内容到tsconfig.json文件中，然后根据自己的需求加减内容。 其余参数可以参考:http://www.tslang.cn/docs/handbook/compiler-options.html
typescript编译配置
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;module&amp;#34;: &amp;#34;commonjs&amp;#34;,//模块化规范 &amp;#34;target&amp;#34;: &amp;#34;es5&amp;#34;,//生成js &amp;#34;noImplicitAny&amp;#34;: true,//在表达式和声明上有隐含的&amp;#39;any&amp;#39;类型时报错 &amp;#34;noImplicitReturns&amp;#34;: true,//函数没有返回值提示 &amp;#34;noFallthroughCasesInSwitch&amp;#34;: true,//switch没有break提示 &amp;#34;removeComments&amp;#34;: true,//输出文件移除注释 &amp;#34;noEmitOnError&amp;#34;: true,//ts文件错误时不生成js &amp;#34;rootDir&amp;#34;: &amp;#34;./&amp;#34;,//需要编译的根目录 &amp;#34;outDir&amp;#34;: &amp;#34;./build&amp;#34;,//编译文件输出目录 &amp;#34;sourceMap&amp;#34;: ture//是否生成.map文件，用于ts debug调试 }, &amp;#34;include&amp;#34;: [ &amp;#34;*/**/*.ts&amp;#34; ], &amp;#34;exclude&amp;#34;: [ //默认排除了node_modules ] } 为了能抛开在命令行中执行tsc命令，能直接通过vscode编辑器来编译，可以使用ctrl+shift+B快捷方式来编译ts文件。第一次使用会有提示
选择TypeScript - Watch-Mode，会在项目根目录下创建.vscode文件夹和tasks.json文件，内容如下：
vscode编译typescript配置
{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, &amp;#34;command&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;isShellCommand&amp;#34;: true, &amp;#34;args&amp;#34;: [&amp;#34;-w&amp;#34;, &amp;#34;-p&amp;#34;, &amp;#34;.&amp;#34;], &amp;#34;showOutput&amp;#34;: &amp;#34;silent&amp;#34;, &amp;#34;isWatching&amp;#34;: true, &amp;#34;problemMatcher&amp;#34;: &amp;#34;$tsc-watch&amp;#34; } 这样就不用每次编译了，只要文件有修改就会自动编译</description>
    </item>
    
    <item>
      <title>我喜欢的电影之《吸血鬼猎人D》</title>
      <link>https://www.yuedun.wang/blogdetail/581dae6e8c4c3f206816c226/</link>
      <pubDate>Sat, 05 Nov 2016 10:03:26 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/581dae6e8c4c3f206816c226/</guid>
      <description>在遥远的未来，由于最后一次世界大战破坏了所有科学文明，曾经君临天下的贵族，凌驾于人类的统治者吸血鬼面临着原因不明的物种衰退，但是他们仍然威胁着人类的生存，猎杀吸血鬼的职业猎人便应运而生。其中人与吸血鬼贵族的混血儿由于兼备了吸血鬼和人类两方的优点，理所当然的成为了最理想的猎人。然而不幸的是，这些被称为“丹皮尔”的混血儿，无法过正常人的生活，就连吸血鬼也不欢迎他们。在这群孤独的人中有一位英俊的佼佼者，他就是吸血鬼猎人D。
故事发生在西历12090年，埃尔邦家族的小姐夏洛特被吸血鬼贵族玛埃尔从家中绑架，于是埃尔邦老爷雇佣了远近闻名，连吸血鬼贵族也害怕的第一吸血鬼猎人D和另一组猎人玛克斯兄妹去救回女儿。
外表高贵俊美，一身漆黑，骑着黑马的“D”，与玛克斯兄妹一路追踪驾马车逃走的吸血鬼。途中D和玛克斯兄妹为争夺奖金发生激斗，并且得知夏洛特并非被绑架，而是爱上了吸血鬼玛埃尔，但他们的爱不被接受，所以他们打算到没有人类和吸血鬼贵族的理想国度“夜之都”去过平静的生活。D受到贵族三杰“影子使者”、“千面人”和“狼人”的阻击，关键时刻D的“阳光症”发作，玛克斯兄妹中的雷拉及时伸出援手，他们约定两人中不管谁先死，另一个一定要到墓上献花。吸血鬼玛埃尔的目的地是让吸血鬼都闻风丧胆，被称为“喋血伯爵夫人”卡蜜拉的旧领地切迪城堡。卡蜜拉称自己理解他们，愿意帮助他们离开纷乱的世界前往理想的国度，并向他们展示了城堡内的飞船。
一切都看似顺利，但玛埃尔和夏洛特没有想到卡蜜拉邀请他们来此只是一个险恶的阴谋，卡蜜拉为了复活需要夏洛特的鲜血。一番恶斗后，D彻底消灭了卡蜜拉，被吸血鬼洗礼的夏洛特则昏死在吸血鬼玛埃尔的怀中，等待新的生命。城堡在主人消失后开始崩溃，玛埃尔抱着夏洛特乘上飞船飞上蓝天，飞向他们梦想的地方。很多年过去了，在雷拉的葬礼上，她的小孙女看到远处的黑衣猎人，D遵守了和雷拉的约定。</description>
    </item>
    
    <item>
      <title>Mongodb和mongoose模糊查询</title>
      <link>https://www.yuedun.wang/blogdetail/581d736c43c18f1b7ae3e3ff/</link>
      <pubDate>Sat, 05 Nov 2016 05:51:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/581d736c43c18f1b7ae3e3ff/</guid>
      <description>需求说明：在mongdb中使用模糊查询，就像sql中的like查询，在where条件中使用模糊匹配，当然最重要的是需要模糊查询的字符串是动态传入的
以一篇文章为例，content字段为文章内容，我们要查询文章内容中包含Nodejs关键字的文章
mongodb中查询
select * from articles where content like &amp;#39;%Nodejs%&amp;#39;; db.articles.find( { content: /Nodejs/i } ) Article.find({ content: /Nodejs/i}, function (err, docs) {}); 这种写法是一种简写操作，需要注意的是不能带双引号，带了双引号就成了字符串。但是这种写法是用/包裹了一个字符串类型的关键字，在实际程序是动态传入的，比如：
var a=&amp;#34;Nodejs&amp;#34; ; Article.find({ content: /a/i}, function (err, docs) {}); 此时会把&amp;quot;a&amp;quot;当做要查询的关键字而不是&amp;quot;Nodejs&amp;quot;，所以这时还是需要用到完整的查询方式，就是使用$regex关键字，还有$options选项
var text = &amp;#39;Nodejs&amp;#39;;//动态传入的变量 Article.find({ content: { $regex: text, $options: &amp;#39;i&amp;#39; }}, function (err, docs) {}); $options选项值：
i 大小写不敏感 m $regex包含正则^,$符号的表达式 x 忽略空格 s 允许逗点匹配所有字符串 其实$regex就是正则表达式的写法
查找数组中的字段：
contacts:{ [ { address: &amp;#34;address1&amp;#34;, name: &amp;#34;张三&amp;#34; }, { address: &amp;#34;address2&amp;#34;, name: &amp;#34;李四&amp;#34; }, .</description>
    </item>
    
    <item>
      <title>Mongodb和mongoose聚合查询</title>
      <link>https://www.yuedun.wang/blogdetail/5819b2b7c4d0a377509b8f1a/</link>
      <pubDate>Wed, 02 Nov 2016 09:32:39 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5819b2b7c4d0a377509b8f1a/</guid>
      <description>mongdb查询某一字段sum值 需求说明：articles有一个字段pv记录了该文章的访问量，现在要统计所有文章访问量，类似于sql中的sum统计
mongodb中查询
select sum(pv) from articles; db.articles.aggregate([{$group:{_id:null,pv:{$sum:&amp;#34;$pv&amp;#34;}}}]); 结果：{ &amp;#34;_id&amp;#34; : null, &amp;#34;pv&amp;#34; : 2 } select sum(pv) from articles where createDate &amp;lt;= &amp;#39;2016-10-20&amp;#39;; db.articles.aggregate([{$match:{createDate:{$lte:&amp;#34;2016-10-20&amp;#34;}}},{$group:{_id:null,pv:{$sum:&amp;#34;$pv&amp;#34;}}}]); 结果：{ &amp;#34;_id&amp;#34; : null, &amp;#34;pv&amp;#34; : 9 } select sum(pv) from articles where category = &amp;#39;Nodejs&amp;#39;; db.articles.aggregate([{$match:{category:&amp;#34;Nodejs&amp;#34;}},{$group:{_id:null,pv:{$sum:&amp;#34;$pv&amp;#34;}}}]); 结果：{ &amp;#34;_id&amp;#34; : null, &amp;#34;pv&amp;#34; : 7 } 需要注意$match和$group的顺序，反了是不行的，因为这是Aggregation Pipeline（管道流）
mongoose实现方式，与上面sql的顺序对应：
Article.aggregate({ $group: { _id: null, pvCount: { $sum: &amp;#39;$pv&amp;#39; }}}, function(err, doc) { console.log(&amp;#34;1&amp;#34;, doc); }); Article.aggregate([{$match:{createDate:{$lte:&amp;#34;2016-10-20&amp;#34;}}},{$group:{_id:null, pvCount:{$sum:&amp;#34;$pv&amp;#34;}}}], function(err, doc) { console.</description>
    </item>
    
    <item>
      <title>TypeScript中的装饰器Decorato什么时候执行？</title>
      <link>https://www.yuedun.wang/blogdetail/58037ab767a381257039c926/</link>
      <pubDate>Sun, 16 Oct 2016 13:03:51 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/58037ab767a381257039c926/</guid>
      <description>ES6引入了类的概念，同时也引入了类似于java的注解概念，我们称之为装饰器，用于在某些场景下修改类和类成员。typescript要支持装饰器需要手动开启experimentalDecorators。
命令行编译
tsc --target ES5 --experimentalDecorators /test.ts 或者配置文件设置：
tsconfig.json:
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;experimentalDecorators&amp;#34;: true } } 那么这个装饰器到底什么原理呢？它是什么时候执行的？用下面代码为例：
//test.ts class Route { greeting: string; constructor(greet: string){ this.greeting = greet; } @route(&amp;#34;hello&amp;#34;) default(): any { console.log(this.greeting); } } function route(name: string) { return function (target: Object, value: string, desc: PropertyDescriptor) { console.log(&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#39;, name); } } 生成的js代码：
//test.js var __decorate = (this &amp;amp;&amp;amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.</description>
    </item>
    
    <item>
      <title>使用typescript开发nodejs的环境搭建（一）</title>
      <link>https://www.yuedun.wang/blogdetail/57fcf50869c8bf6e323dff48/</link>
      <pubDate>Tue, 11 Oct 2016 14:19:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57fcf50869c8bf6e323dff48/</guid>
      <description>在一切开始之前先具备的开发环境：
nodejs4.0+
推荐的开发工具vscode
我希望通过本文介绍能直接做出一个最简单的项目框架，以便日后参考，这也是我想把之前纯nodejs写的博用typescript客重写一遍。
还是以expressjs为框架来搭建
使用express-generator来生成项目基本框架，需要全局安装
npm install -g express-generator
express -e mpro
参数-e是以ejs为模板引擎，mpor为项目目录名，最后生成这样的目录结构：
. ├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.ejs └── index.ejs 然后是全局安装typescript，便于在任何目录下编译，也可以安装在项目目录下。
npm install -g typescript
安装完以后初始化typescript:
tsc &amp;ndash;init
会在根目录下生成tsconfig.json文件，用于配置ts的编译选项。 有了基本目录以后就可以着手编写代码了，为了使用ts开发，可以手动将routes目录下的js文件 和app.js后缀名改成.ts. 做完以上步骤以后可以试着在项目根目录下执行&amp;gt; tsc命令，可能什么都没发生， 这个命令会默认编译当前目录下的ts文件，但是我们项目中并没有这样的文件， 你可以自己新建一个后缀为.ts的文件再执行&amp;gt; tsc还是什么都没有发生一样，但是如果我们把app.ts (已经改过后缀的app.js文件)中的
var bodyParser = require(&#39;body-parser&#39;); 改成</description>
    </item>
    
    <item>
      <title>使用半年TypeScript后的感受</title>
      <link>https://www.yuedun.wang/blogdetail/57fb9d3169c8bf6e323dff46/</link>
      <pubDate>Mon, 10 Oct 2016 13:52:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57fb9d3169c8bf6e323dff46/</guid>
      <description>初识TypeScript 从入职新公司开始算，使用typescript已经有半年多了，这是一个创业公司使用nodejs开发的后台业务管理系统，已经做的很大了，支撑着公司每月千万人民币的业务处理。很多怀疑nodejs是否可以开发后台管理，作为一个过来人告诉你可以放心使用，现在的javascript早已不是10年前用来写前端特效的js了。美中不足的是nodejs对报表这类数据处理量较大的功能有点力不从心，经常拖垮系统，当然也不是完全不能用nodejs来处理报表，可以合理的使用子进程单独处理数据而不影响主进程。但还是不推荐。
使用感受 其实起初对于typescript开发nodejs我是拒绝的，原因是建立起这个项目的人都走了，而这个项目结构实在是复杂，在windows下环境搭建费了好大精力，尤其是为了使用一个bcrypt加密包，需要安装Python,C++来编译，还不能使用nodejs0.12以上版本，最烦人的是每次修改文件后编译速度非常慢，这让我重新体验了开发JAVA时期的痛苦。而且服务启动方法也是前人自己编写shell脚本来同时编译前端文件和后端文件。并没有使用nodemon,supervisor这种监控工具。后来折腾发现可以直接使用vscode单独编译ts文件，一般12秒就编译完成，这与我之前的项目1秒修改重启相比还是慢了很多，不过也免强只能接受，此时只觉得如此麻烦和JAVA开发有什么区别！所以基于这些不好的体验我很不喜欢typescript。
重新认识 最近又折腾了下我用纯nodejs开发的博客，突然发现，写起来确实不如typescript爽，主要是纯nodejs在webstorm和vscode上语法提示和错误提示较弱，而typescript则可以很好的提示并且在开发过程中就能发现一些很低级错误，不用等到运行时才发现。尤其是对ES6的支持比较完整，甚至可以使用async,await这些ES7提案中的特性。虽然现在高版本的nodejs已经支持一些新特性，但是并不是所有项目都可以使用高版本。如果说为什么要使用typescript，那就是typescript集合了js的快速和强类型语言的安全稳定，用于开发一些较大的项目绝对利大于弊。 尤其是对于一些多人合作的项目来说，typescript的强类型能够很好约束对象属性，参数传递，对后续的重构也起到至关重要的作用。 有人可能会担心降低开发效率，这一点大可不必担心，你定义类型消耗的时间会从强类型提示上补回来的。 接下来会写一篇完整的环境搭建教程：使用typescript开发nodejs的环境搭建（一）</description>
    </item>
    
    <item>
      <title>beego post请求获取request body参数</title>
      <link>https://www.yuedun.wang/blogdetail/57d6aaa7471c11fa271ed1bb/</link>
      <pubDate>Mon, 12 Sep 2016 13:16:23 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57d6aaa7471c11fa271ed1bb/</guid>
      <description>为了获取json类型的参数煞费苦心，差点不再爱了。
前端请求代码：
$.ajax({ url: &amp;#34;/user&amp;#34;, type: &amp;#34;post&amp;#34;, contentType: &amp;#39;application/json&amp;#39;, data: JSON.stringify({username:&amp;#34;张三&amp;#34;,mobile:&amp;#34;13265478965&amp;#34;}), //这才是最重要的地方，必须用JSON.stringify序列化成字符串， //直接使用对象死活都接收不到，至于大小写并不影响，只要写对了就行 dataType: &amp;#34;json&amp;#34; }).done(function(res) { if(res.result){ alert(&amp;#34;成功&amp;#34;) } }); 需要传输json类型数据，同时数据需要使用JSON.stringify序列化。
后端接收代码：
func (c *UserController) Post() { var form struct { Username string `json:&amp;#34;username&amp;#34;` Mobile string `json:&amp;#34;mobile&amp;#34;` } c.BindJSON(&amp;amp;form) user := &amp;amp;User{Username: form.UserName, Mobile: form.Mobile} err := user.AddUser()//这是添加用户函数 if nil != err { c.Data[&amp;#34;json&amp;#34;] = map[string]interface{}{&amp;#34;result&amp;#34;: false, &amp;#34;msg&amp;#34;: err} } else { c.Data[&amp;#34;json&amp;#34;] = map[string]interface{}{&amp;#34;result&amp;#34;: true, &amp;#34;msg&amp;#34;: &amp;#34;新增成功&amp;#34;} } c.</description>
    </item>
    
    <item>
      <title>把公司电脑拿回家用</title>
      <link>https://www.yuedun.wang/blogdetail/57ca186925f9289500f49cf1/</link>
      <pubDate>Sat, 03 Sep 2016 00:25:13 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57ca186925f9289500f49cf1/</guid>
      <description>每个上班的人都会有这样的情况：在公司写一篇文档，设计一份PPT，但是此时已经下班了，又不想继续待在公司做，想拿回家做，所以只能将正在做的文件拷到U盘带回家，或保存到网络硬盘里，回家以后再打开自己的电脑插上U盘打开文件，做完以后再拷到U盘，说不定第二天还忘记带U盘，到了公司还得重做。
基于以上情况，目前想到的有两种解决方案：
第一种，在公司和家里的电脑上分别安装teamviewer软件，登录注册添加远程计算机，回家以后不需要再携带U盘，打开自己的电脑可以直接远程公司电脑工作。
第二种，虽然第一种方法省去了带U盘的麻烦，但还是要开自己的电脑远程连接才行，也没省多少事。终究还是要开自己的电脑才能开始工作，而且远程连接的体验也不是很好，屏幕分辨率不一致导致显示效果不一样，尤其是字体会放大缩小。如果有条件的话何不在家里配一台大屏幕的显示器。而且你买一台三五千的笔记本就看看电影之类的小事情那就大才小用了，也根本没必要。所以我们何不将公司的电脑当做自己拿回来用呢！我的意思不是真的将公司的电脑扛回来用，而是用公司的电脑主机，家里只需要显示器，鼠键即可。要实现这样的需求要借助目前一些现成的解决方案。
比如http://www.yun0101.com/xnhcp/nc61.html这样的设备，或者以前一家公司使用过的华为云终端。只需要一个小盒子即可连接云主机。第二种方案是我想要的，但是还没有亲自实现，需要继续探究去实现。</description>
    </item>
    
    <item>
      <title>nodejs请求网络资源写到本地</title>
      <link>https://www.yuedun.wang/blogdetail/57c7f2301165e2677d137d65/</link>
      <pubDate>Thu, 01 Sep 2016 09:17:36 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57c7f2301165e2677d137d65/</guid>
      <description>nodejs请求网络资源写到本地 有这样一个需求：抓取网络上的图片或其他类型文件保存的本地，根据以往的经验这样写：
var request=require(&amp;#34;request&amp;#34;); var fs=require(&amp;#34;fs&amp;#34;); var url=&amp;#34;http://h.hiphotos.baidu.com/zhidao/pic/item/6d81800a19d8bc3ed69473cb848ba61ea8d34516.jpg&amp;#34;; HttpRequest.get(url, (err, res, body) =&amp;gt; { res.setEncoding(&amp;#34;binary&amp;#34;);//二进制（binary） FS.writeFile(&amp;#34;out.png&amp;#34;, body, &amp;#34;binary&amp;#34;, function (err) {//以二进制格式保存 if (err) throw err; console.log(&amp;#34;file saved&amp;#34;); }); }); 这个例子可能看起来比较眼熟，其实我就是从网上找来的，如果用这种方法成功的话那么恭喜你了，反正我是没有成功。还有一种情况是虽然成功的写文件到本地了，但是打不开，反正提示就是文件损坏之类的。总之，就是上面的方法行……不……通……
还好，有另一种方法可行，而且看起来代码量也少了很多。
var url=&amp;#34;http://h.hiphotos.baidu.com/zhidao/pic/item/6d81800a19d8bc3ed69473cb848ba61ea8d34516.jpg&amp;#34;; request(url).pipe(fs.createWriteStream(&amp;#34;out.png&amp;#34;)); 不过，虽然代码少了很多，但是疑问多了很多，pipe函数是什么东西，还有fs.createWriteStream()函数，借助nodejs帮助文档大概解释一二。
_pipe_函数把他称作为管道吧，回头看一下代码，就是把前面请求的内容通过管道输送到后面的容器里面。虽然这么说还是不太理解，为什么可以调用pipe管道？
非郑重声明：本人也是用蹩脚的英语大概理解nodejs stream的相关知识，如果有不妥的地方误导了人只能表示抱歉
有关网络请求，比如http request，和文件操作方面的都涉及到流的概念，流是可读可写的，
const http = require(&amp;#34;http&amp;#34;); var server = http.createServer( (req, res) =&amp;gt; { } 其中req是可读Readable Stream的流，res是可写Writable Stream的流，再看request(url).pipe(fs.createWriteStream(&amp;quot;out.png&amp;quot;));,
request是继承自stream模块的，所以它也是具有可读可写的特性，自然就能调用pipe函数，从而获取到数据，然后需要写入到一个文件中，就需要由pipe输出到一个可写的流中，fs.createWriteStream(path)返回一个可写WriteStream的流，就可以接受pipe管道的输出，最后写入到本地文件。</description>
    </item>
    
    <item>
      <title>iphone快速锁屏</title>
      <link>https://www.yuedun.wang/blogdetail/57ac0b71a2e66e6c13c08862/</link>
      <pubDate>Thu, 11 Aug 2016 05:21:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57ac0b71a2e66e6c13c08862/</guid>
      <description>以iphone5s来说明，要关闭屏幕通常需要按顶部电源键，但是iphone5s的电源键高度太低，如果再装个手机壳的话基本很难按到，或者需要很大的力气才能锁屏。而且长期按压也会按坏，就算现在没坏也有这样的担心不是吗？所以我们希望有个快捷方式点击屏幕就能锁屏，所幸iphone提供了这样的功能，不过默认没有放到第一级菜单中，所以不太好找，但是可以通过设置来放到第一级菜单，就是屏幕上的虚拟home键打开后的菜单。
设置-通用-辅助功能-AssistiveTouch-自定顶层菜单，点击一个不常用的按钮，选择锁定屏幕，完成。</description>
    </item>
    
    <item>
      <title>使用scp在Windows和linux之间传输文件</title>
      <link>https://www.yuedun.wang/blogdetail/575134e682887be008614fc5/</link>
      <pubDate>Fri, 03 Jun 2016 07:42:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/575134e682887be008614fc5/</guid>
      <description>获取远程服务器（linux）文件到本地（Windows）： scp 远程name@远程IP:远程文件 本地文件
发送本地文件（Windows）到远程服务器（linux）： scp 本地文件名 远程name@远程IP地址**:远程文件**</description>
    </item>
    
    <item>
      <title>js复制文本内容</title>
      <link>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</link>
      <pubDate>Thu, 02 Jun 2016 05:36:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</guid>
      <description>http://yuedun.github.io/copy.html
点击链接查看:js复制</description>
    </item>
    
    <item>
      <title>nodejs中vm模块的作用</title>
      <link>https://www.yuedun.wang/blogdetail/5745791ed5034dff53ec6aa4/</link>
      <pubDate>Wed, 25 May 2016 10:06:22 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5745791ed5034dff53ec6aa4/</guid>
      <description>vm提供了一个沙箱环境，什么叫沙箱环境？类似于一个独立的执行空间，什么时候会用到vm模块？就以我现在接触的需求来说，每个月都有运营活动，但是每次需求又不同，比如一些优惠规则不同，最后可能只需要得到一个结果，如果每次活动都去修改代码就会显得很麻烦，我们提供一个后台管理界面，或者直接在数据库里写入每次活动的不同计算规则，这些规则其实也是JavaScript代码，既然是代码就需要执行才行。这就形成了一种情况：在已有的程序中插入一段代码进行执行，这要怎么实现？如果觉得很容易插入的话，那么是不是黑客可以在你的程序中插入一段代码执行呢？这当然是不允许的，所以就需要提供一种安全环境来执行——就是沙箱了，而vm模块就是提供了这样一种执行环境。 http://www.cnblogs.com/softlover/archive/2012/10/03/2707144.html</description>
    </item>
    
    <item>
      <title>VMware重新安装VMware Tool</title>
      <link>https://www.yuedun.wang/blogdetail/5742d3bb44b00beb2d26238d/</link>
      <pubDate>Mon, 23 May 2016 09:56:11 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5742d3bb44b00beb2d26238d/</guid>
      <description>VMware重新安装VMware Tool 将虚拟机从Ubuntu 14重新安装为Ubuntu 16以后不能将Windows的文本内容复制到Linux中，需要重新安装VMware Tool,VMware版本为12
一、安装VMware Tool 安装时需要在虚拟机启动登录的情况下进行，
点击以后应该会弹出磁盘图标并且打开一个文件夹
文件夹中包含一个压缩文件，需要解压，解压需要root权限，打开命令行 # sudo su 提升为超级用户，可以右击查看gz压缩文件路径，并切换到该目录下，或者可以直接使用图形界面，右击-提取，不能提取到当前目录下，该目录为磁盘目录，不能写入数据，解压到其他目录下即可。解压完成会得到vmware-tools-distrib文件夹，文件夹下有多个文件，其中有vmware-install.pl，命令行中执行这个文件 ./vmware-install.pl 基本可以一路按回车，安装完成后需要重启。重启后可能会有这样的显示，不过不影响。</description>
    </item>
    
    <item>
      <title>linux下安装nodejs</title>
      <link>https://www.yuedun.wang/blogdetail/574019ee0bdb5de027394523/</link>
      <pubDate>Sat, 21 May 2016 08:18:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/574019ee0bdb5de027394523/</guid>
      <description>此文过旧，请参阅linux安装nodejs——快捷版 首先下载nodejs压缩文件node-v4.4.4-linux-x64.tar.xz，先解压文件， &amp;gt; xz -d node-v4.4.4-linux-x64.tar.xz解压为tar格式文件，再通过tar命令解压 &amp;gt; tar -xvf node-v4.4.4-linux-x64.tar 可以将解压后的文件夹移动到自己的软件安装文件夹下，比如：/usr/local下，因为nodejs的版本更新太快，每次更新都这么移动文件夹太麻烦，所以还是改成一个通用的名字，就叫node，执行命令这样： mv /home/huo/Download/node-v4.4.4-linux-x64 /usr/local/node 为了能够全局执行node和npm命令，需要建立软链接到可执行目录下，执行命令： echo $PATH 可以看到：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin是linux全局执行目录，所以就选择在/usr/local/bin下建立软链接吧。
ln -s /usr/local/node/bin/npm /usr/local/bin/npm 这样就可以在任意目录下执行node和npm命令了，不过这样还没结束，使用npm全局安装包后，在命令行里执行会找不到命令，因为npm全局安装目录在node安装目录，也就是安装在了/usr/local/node/lib/node_modules目录下，所以还需要将这个目录添加的$PATH变量中，sudo vim /etc/profile在文件最下边添加export PATH=&amp;quot;/usr/local/node/bin:$PATH&amp;quot;,此处的路径/usr/local/node/bin并不是上面说的/usr/local/node/lib/node_modules目录，因为npm全局安装以后会在node安装目录下的bin文件夹中建立软链接，直接在$PATH中添加npm的全局安装目录是无法找到可执行文件的。
升级node版本 可以通过全局安装n工具来升级 npm install -g n，或者nvm工具 或者就是直接下载新的tar文件覆盖升级 cp -Rv node-v8.11.3-linux-x64/* /home/yuedun/software/nodejs/</description>
    </item>
    
    <item>
      <title>用java的思想方式写javascript</title>
      <link>https://www.yuedun.wang/blogdetail/56f15a4a3823e4e62593d4e2/</link>
      <pubDate>Tue, 22 Mar 2016 14:44:26 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56f15a4a3823e4e62593d4e2/</guid>
      <description>javascript和java有相似之处也有很大区别，对于初学者来说很容易被名称迷惑，其实当初javascript就是借着java的顺风车进行推广的。
由于javascript是动态语言，java是静态语言，所以两者在编写方式上有很大区别，主要是因为javascript没有类的概念，在ES6标准发布之前要构造一个对象需要用new关键字实例化一个function或者直接使用对象字面量。不过ES6标准的发布，使得javascript也可像java一样声明类了。
在使用nodejs开发大型应用时需要到类的概念来封装一个复杂的逻辑，我们可以从现在开始逐步使用ES6开发，但是基于现有的支持环境，很多时候还得用ES5编写代码，那么这时候怎么来抽象一个类和实例化对象？
以Java的思想方式来编写JavaScript，首先是一个构造函数：
function Person(name, age){ this.name = name; this.age = age; } 这就像是Java的构造函数，可以new一个对象出来
var tom = new Person(&amp;quot;Tom&amp;quot;,12);
构造函数的用处是在创建对象的时候就初始化了属性的值，不用再单独赋值，不需要再像这样赋值:
var tom = new Person(); tom.name = &amp;#34;Tom&amp;#34;; tom.age = 13; 有了构造函数，还要有普通函数：
tom.sayHello = function(){ console.log(&amp;#34;my name is &amp;#34;+this.name);//my name is Tom } 接下来是静态函数：静态方法就是由类名直接调用的的方法，不需要new一个对象
function Person(name, age){ this.name = name; this.age = age; } Person.getAge = function(){ console.log(this.age); } Person.age = 12; Person.getAge();//类似于Java中的静态方法只能使用静态变量，所以此处也需要一个静态age 至于普通函数与静态函数有什么区别？区别就在于静态函数会一开始就加载到内存中，当然就比较占用内存了，普通函数是在new以后才被初始化，函数使用完就释放内存。</description>
    </item>
    
    <item>
      <title>fullcalendar点击prve或者next按钮翻月触发事件调用</title>
      <link>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</link>
      <pubDate>Tue, 22 Mar 2016 13:32:59 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</guid>
      <description>$(&amp;#39;#calendar&amp;#39;).fullCalendar({ lang: &amp;#34;zh-cn&amp;#34;, header: { left: &amp;#39;prev, next, today&amp;#39;, center: &amp;#39;title&amp;#39;, right: &amp;#39;month&amp;#39; }, height: 500, dayClick: function(date, jsEvent, view) { //点击空白日期调用 }, eventClick: function(calEvent, jsEvent, view) { //点击已有数据的日期调用 }, defaultDate: moment(),//默认日期 events:function(start, end, callback){ //点击prev上一月, next下一月等事件时调用 } }); </description>
    </item>
    
    <item>
      <title>系统开发中默认值的设置 </title>
      <link>https://www.yuedun.wang/blogdetail/56c1b67cbf2e89202c146372/</link>
      <pubDate>Mon, 15 Feb 2016 11:29:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56c1b67cbf2e89202c146372/</guid>
      <description>多人协作开发过程中会遇到一些字段设置默认值的情况，但是这个默认值到底该由哪一阶段来设置？比如有三个阶段:前端或移动端，接口程序，数据库。说个具体场景，APP上有个医生需要显示挂号费，这个挂号费是由后台管理系统添加的，但是在添加医生这个过程不是一次性完成的，先是添加员工信息，角色为医生，这个挂号费是添加完成员工信息以后在医生管理里设置的，那么在完成添加员工后还没来得及设置挂号费医生就显示到了APP中，由于这个医生没有挂号费，就会导致用户误解或者APP程序报错。这时候问题来了，挂号费该有个默认值吧！但是这个默认值由谁来设置呢？尤其是程序上线以后出现问题大家都不想背这个黑锅，移动端问接口，你要传个默认值给我，接口对后台管理说你怎么没传个默认值给我？后台管理说，就不能在数据库设置吗，没有值我干嘛还要传？究竟该由谁来设置这个默认值，好像谁都可以，但是有很多字段要设置的时候就有很多工作量要做了，需要判断用户有没有填，没有填就设置默认值。一堆的if判断，很不明智的做法，而且也不能保证万无一失。
最后总结：默认值由数据库来设置，这是最简单的方法，可以为程序省去很多判断，而且数据库不为null的设置可以为索引字段带来好处，节省空间。</description>
    </item>
    
    <item>
      <title>vue.js做的应用中点击搜索功能会改变URI</title>
      <link>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</link>
      <pubDate>Thu, 04 Feb 2016 07:59:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</guid>
      <description>用vue.js做的后台管理系统，有一个列表搜索功能，正常登陆进去，直接点击搜索功能，页面就会刷新一遍，原因是url地址变化了
原本地址是：
http://www.mydomain/#!/index
点击搜索以后就变成了
http://www.mydomain/?#!/index
在#!前面自动加了?，导致页面刷新一遍，这样第一次搜索就没意义了.
经过初步排查后发现点击其他按钮不会改变URL地址，对比后发现搜索按钮的type=&amp;ldquo;submit&amp;rdquo;，可能是提交表单导致跳转了，那么将type改为button或者直接去掉试试，结果还是不行，干脆也改为标签（加了bootstrap按钮样式），结果好了。为什么将button type改为button不行呢，原因是在标签内标签type会被默认当做submit，（IE浏览器默认type=button）</description>
    </item>
    
    <item>
      <title>vue.js click点击事件获取当前元素对象</title>
      <link>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</link>
      <pubDate>Wed, 27 Jan 2016 14:59:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</guid>
      <description>Vue.js可以传递$event对象
&amp;lt;body id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-on:click=&amp;#34;say(&amp;#39;hello!&amp;#39;, $event)&amp;#34;&amp;gt;点击当前行文本&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;li2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;li3&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;Hello Vue.js!&amp;#39; }, methods: { say: function(msg, event) { //获取点击对象 var el = event.currentTarget; alert(&amp;#34;当前对象的内容：&amp;#34;+el.innerHTML); } } }) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 函数调用处传递$event
v-on:click=&amp;quot;say(&#39;hello!&#39;, $event)&amp;quot;
函数中获取到的event.currentTarget对象就是当前元素
在线示例
请查看HTML页面示例源码</description>
    </item>
    
    <item>
      <title>vue.js对表单值初始化</title>
      <link>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</link>
      <pubDate>Thu, 14 Jan 2016 01:57:43 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</guid>
      <description>新建表单有些input输入框需要默认值，比如性别需要一个男或女默认值。再比如一个日期选择框需要默认今天。如果按照HTML的方式设置不会起作用
&amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;0&amp;#34; checked=&amp;#34;checked&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;男 &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;1&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;女 &amp;lt;input type=&amp;#34;date&amp;#34; value=&amp;#34;2016-01-06&amp;#34; v-model=&amp;#34;date&amp;#34;&amp;gt; 在vue.js页面中上面这种设置方式是不会起作用的,性别不会选中，日期也不会有值。解决办法是对v-model属性设值，在初始化时给gender=0，那么默认会选中性别男，给date=&amp;ldquo;2016-01-06&amp;quot;日期控件也有值。</description>
    </item>
    
    <item>
      <title>js省市级联动插件</title>
      <link>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</link>
      <pubDate>Tue, 12 Jan 2016 04:45:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</guid>
      <description>在线示例：http://www.yuedun.wang/views/address
具体代码看页面源码</description>
    </item>
    
    <item>
      <title>vue.js中使用focus，blur事件</title>
      <link>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</link>
      <pubDate>Sun, 10 Jan 2016 04:08:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</guid>
      <description>在线示例
使用focus，blur可对表单进行验证，除了这两个事件，还有一个watch属性可监听data属性值得变化，具体可打开浏览器控制台看属性值得变化情况，代码可直接在浏览器中查看源码</description>
    </item>
    
    <item>
      <title>webuploader模态框按钮不起作用或每次打开都会变大</title>
      <link>https://www.yuedun.wang/blogdetail/568b2d05db1fef9e0cda949f/</link>
      <pubDate>Tue, 05 Jan 2016 02:40:05 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568b2d05db1fef9e0cda949f/</guid>
      <description>在bootstra模态框中放置webuploader上传控件，每次打开模态框按钮都会成倍放大，原因是每次打开模态框都会进行一次初始化，在原来按钮的基础上又加了一层样式，那么初始化一次应该可以吧。
修改后的确不会再放大了，可以又有新问题出现了，就是不能点击上传文件了。
上传实例初始化一次，先然按钮正常显示， var uploader = WebUploader.create({})， 再通过uploader提供的API重新添加一个按钮uploader.addButton({})，这样类似于将前一个按钮覆盖了。</description>
    </item>
    
    <item>
      <title>vue.js开发gulp监听文件变化自动编译</title>
      <link>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</link>
      <pubDate>Mon, 04 Jan 2016 05:52:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</guid>
      <description>直接看代码：
var gulp = require(&amp;#39;gulp&amp;#39;) var webpack = require(&amp;#34;gulp-webpack&amp;#34;); var webpackConfig = require(&amp;#34;./webpack.config.js&amp;#34;); // gulp.task(&amp;#34;webpack&amp;#34;, function(callback) { // var myConfig = Object.create(webpackConfig); // webpack(myConfig, function(err, stats) { // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;err:&amp;#34;+JSON.stringify(err)) // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;stats:&amp;#34;+stats) // if(err) throw new Error(&amp;#34;webpack&amp;#34;, err); // callback(); // }); // }); /** * 编译时有错误提示 */ gulp.task(&amp;#34;webpack&amp;#34;, function(){ return gulp.src(&amp;#34;./app.js&amp;#34;) .pipe(webpack(Object.create(webpackConfig))) .pipe(gulp.dest(&amp;#34;./dist/&amp;#34;)) }); gulp.watch(&amp;#39;./views/*&amp;#39;, [&amp;#39;webpack&amp;#39;]); webpack.config.js配置
var webpack = require(&amp;#34;webpack&amp;#34;); module.exports = { entry: //&amp;#34;./app.js&amp;#34;, { app:&amp;#34;./app.js&amp;#34; // vendor: [&amp;#34;.</description>
    </item>
    
    <item>
      <title>vue.js在chrome浏览器下输入汉字会带出拼音</title>
      <link>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</link>
      <pubDate>Fri, 01 Jan 2016 10:19:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</guid>
      <description>本想写篇vue.js的教程的，但牵扯的知识点比较多，最近又没时间，就记录下过程中遇到问题吧。开发过程中用的360极速浏览器，也没什么问题，但是其他人测试的时候用的是chrome浏览器，输入汉字的时候会连拼音也带进去，比如输入的是“你好”，结果却成了“nihao你好”。
按理说360极速浏览器也用的是chrome内核，不应该出现这两种不同的情况，这个问题先不追究了。还是说说为什么vue.js的输入框会出现拼音的问题。我本以为是浏览器的差异造成这种现象，但是也不是所有输入框都会出现，那一定是程序的问题。
这是一种双向数据绑定常见写法，但是由于我的理解不够透彻，写成了这样：
我的理解是更新的时候要先显示数据，所以就在input里加了value来初始化数据，也是因为加了这个value导致输入汉字出现拼音，也与浏览器有点关系，就是输入的时候chrome浏览器会把输入的汉字拼音拼写也放进输入框，那么数据模型就接收了输入，敲击空格键的时候又输进了汉字，所以就都带进来了。但其实只需要v-model就能实现数据的接收和输出。</description>
    </item>
    
    <item>
      <title>sequelizejs删除对象属性</title>
      <link>https://www.yuedun.wang/blogdetail/5656ba78c72f59d15379b4ba/</link>
      <pubDate>Thu, 26 Nov 2015 07:53:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5656ba78c72f59d15379b4ba/</guid>
      <description>js中有个delete操作符可以删除对象的属性，比如下面代码：
//objtest对象有个prop属性
var objtest = { prop: &amp;#39;delete me&amp;#39; }; //或者这么声明的对象 var objtest = new Array(); objtest[&amp;#39;prop&amp;#39;] = &amp;#39;delete me&amp;#39;; //删除属性&amp;#39;prop&amp;#39;： delete objtest.prop; //或者 delete objtest[&amp;#39;prop&amp;#39;]; //还可以删除任意变量 var numb = 17; delete numb; 但是在nodejs项目中使用了sequelizejs来读取数据，如果也有想删除的属性，直接使用delete是删不掉的，比如有这样的数据结构：
var user = { name: &amp;#39;鸣人&amp;#39;, age: 16, gender: &amp;#39;男&amp;#39;, friends: [{ name: &amp;#39;小樱&amp;#39;, age: 16, gender: &amp;#39;女&amp;#39;, friends: [{ name: &amp;#39;井野&amp;#39;, age: 16, gender: &amp;#39;女&amp;#39; }] }, { name: &amp;#39;佐助&amp;#39;, age: 16, gender: &amp;#39;男&amp;#39; }] } 鸣人有小樱和佐助两个朋友，小樱有井野一个朋友，小樱的朋友也可以当做鸣人的朋友，现在想把井野也提出来并列到鸣人的朋友列表里，这样做很容易，但是既然提出来了就不需要小樱的朋友列表了，应该删掉。但是用delete user.</description>
    </item>
    
    <item>
      <title>Go语言学习笔记</title>
      <link>https://www.yuedun.wang/blogdetail/56556da1c72f59d15379b4b9/</link>
      <pubDate>Wed, 25 Nov 2015 08:13:21 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56556da1c72f59d15379b4b9/</guid>
      <description>近些年出现不少新的开发语言，比如:
Rust是Mozilla开发的注重安全、性能和并发性的编程语言。
Go语言是谷歌2009发布的第二款开源编程语言。专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。
D语言最初由Digital Mars公司就职的Walter Bright于2001年发布，意图改进C++语言。目前最新D语言被简称为D2。最主要的D语言的实现是DMD。
Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行的数据密集型的实时应用。
等等……
对于这些新语言，总有不少槽点被开发者吐槽。很多人都会进行对比，褒贬。但是我还是首先选择了Nodejs，简单快速上手，目前完全用于生产环境，它的快速开发让我很满意。ES6标准的定稿更让我肯定nodejs将会有更好的发展。
最近又学习了go语言，在学一门语言前总会迟疑值不值得学习，然后看到网上各种讨论。但我觉得还是值得学习，且不说性能有没有C++好，光凭开发效率就值得我学了，现代计算机性能都有很大的提升，如果不是开发底层系统，而是开发软件服务端系统那么它的有点足够了。
原生http请求获取参数 获取URL参数
url:localhost:8081/?startDate=2017-11-22 var query = req.URL.Query() Println(query[&amp;quot;startDate&amp;quot;])
go返回json数据
type ResObj struct { Code int Data map[string]string } //或 //type ResObj struct { // Code int `json:&amp;#34;code&amp;#34;` // Data map[string]string `json:&amp;#34;data&amp;#34;` //} //首先要保证ResObj的属性首字母大写，否则访问不到，其次`json:&amp;#34;code&amp;#34;`不是必须，只不过加了什么样返回的json就是什么样 //{&amp;#34;Code&amp;#34;:0,&amp;#34;Data&amp;#34;:{&amp;#34;a&amp;#34;:&amp;#34;aaaaaa&amp;#34;}}和{&amp;#34;code&amp;#34;:0,&amp;#34;data&amp;#34;:{&amp;#34;a&amp;#34;:&amp;#34;aaaaaa&amp;#34;}}这样的区别 func helloHandler(res http.ResponseWriter, req *http.Request) { m := make(map[string]string) m[&amp;#34;a&amp;#34;] = &amp;#34;aaaaaa&amp;#34; ress := &amp;amp;ResObj{ Code: 0, Data: m} byt, _ := json.</description>
    </item>
    
    <item>
      <title>js prototype的理解【转】</title>
      <link>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</link>
      <pubDate>Wed, 25 Nov 2015 02:28:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</guid>
      <description>prototype属性可算是JavaScript与其他面向对象语言的一大不同之处。 prototype就是“一个给类的对象添加方法的方法”，使用prototype属性，可以给类动态地添加方法，以便在JavaScript中实现“ 继承”的效果。
具体来说，prototype 是在 IE 4 及其以后版本引入的一个针对于某一类的对象的方法，当你用prototype编写一个类后，如果new一个新的对象，浏览器会自动把prototype中 的内容替你附加在对象上。这样，通过利用prototype就可以在JavaScript中实现成员函数的定义，甚至是“继承”的效果。
对于javascript本身而言是基于对象的，任何元素都可以看成对象。然而类型和对象是不同的，而我们所讲的prototype属性即是基于类型的一 种属性。对于prototype的基本使用就如对象的创建及属性赋值一样的简单。直接通过赋值操作即可完成属性的创建。
/** * 关于prototype, 理解这个很有必要 可以在类型上使用proptotype来为类型添加行为。这些行为只能在类型的实例上体现。 JS中允许的类型有Array, Boolean, Date, Enumerator, Error, Function, Number, Object, RegExp, String 以后这样分，没有实例化的类称为类型，实例化的类称为对象实例简称实例 */ Object.prototype.name = &amp;#34;zhangsan&amp;#34;; Object.prototype.nihao = function () { alert(&amp;#34;i can method name is &amp;#34; + this.name); } var obj = new Object(); obj.nihao(); alert(obj.name); // 在实例上不能使用prototype，否则会发生编译错误 obj.prototype.sex = &amp;#34;男&amp;#34;; //error,无法给一个实例prototype var o = { name: &amp;#34;zhangsan&amp;#34; } o.prototype.age = 30; //error,无法给一个实例prototype //可以为类型定义“静态”的属性和方法，直接在类型上调用即可 alert(Object.</description>
    </item>
    
    <item>
      <title>代码是否应该重构</title>
      <link>https://www.yuedun.wang/blogdetail/564c33be91dccd315681abff/</link>
      <pubDate>Wed, 18 Nov 2015 08:15:58 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/564c33be91dccd315681abff/</guid>
      <description>关于代码重构是否必须，在网上也是找了很多资料。很多人持不同态度，至少给我的感觉是对半分的态度。有人说应该重构，可以是项目更加健壮，代码读起来更加顺畅，性能提升，大工程更易维护，可扩展性强等等好处。但有人持反对态度，认为代码千万不要重写，其中原因也可以理解，比如：重构代码需要耗费大量时间，在项目周期紧张的情况下更加不可能了，只要可运行就行。很多时候写代码容易，但是读代码难，这是很多人有的感觉，尤其是没有文档，注释的代码更是看了伤眼伤神。而且重构可能带来新的问题，遗留项目更是没人敢碰。
那到底该不该重构呢？或许我也不能说出绝对的理由，不过我有自己的理由，首先我对代码有洁癖，见不得乱糟糟的代码，不过我更多的情况是在写的时候会做代码审查，看看能不能够用更简单的方式实现，对于多次重复出现的代码会考虑封装一下以便共用。至于已经上线很久以后发现的烂代码还是谨慎重构，太复杂的就不要动了。
有一种比较频繁出现的情况是，有很多时候会写之前写过的代码，某个类似的功能，这个时候是坚决会对以前的代码重构简化，我讨厌写重复的东西。往往能将以前的代码缩减不少使之更精简明了。
对于重构的意义除了上面提到的，个人认为还有一个好处——虽然一次不能写出最好的代码，但是只要有重构的意识，至少是能写出比上次更好的代码，也算是经验总结，要不然怎么会出现那么多设计模式。</description>
    </item>
    
    <item>
      <title>js控制优酷视频播放暂停</title>
      <link>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</link>
      <pubDate>Tue, 17 Nov 2015 07:48:37 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</guid>
      <description>js控制优酷视频播放暂停
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;js控制优酷视频播放&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;http://player.youku.com/jsapi&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; player = new YKU.Player(&amp;#34;youkuplayer&amp;#34;,{ styleid: &amp;#34;0&amp;#34;, client_id: &amp;#34;d8781b239fdad45b&amp;#34;, vid: &amp;#34;XMjg1MTcyNDQ0&amp;#34;, autoplay: false, show_related: true, events:{ onPlayEnd: function(){ /*your code*/ }, onPlayStart: function(){ /*your code*/ }, onPlayerReady: function(){ /*your code*/ } } }); function playVideo(){ try{ player.playVideo(); } catch(err){ alert(&amp;#34;*&amp;#34;+err); } } function pauseVideo(){ player.pauseVideo(); } function seekTo(s){ player.seekTo(s); } function currentTime(){ return player.</description>
    </item>
    
    <item>
      <title>做菜技巧-很重要又很容易被忽视的做菜技巧</title>
      <link>https://www.yuedun.wang/blogdetail/56499caf536a927c57d10a9c/</link>
      <pubDate>Mon, 16 Nov 2015 09:06:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56499caf536a927c57d10a9c/</guid>
      <description>烹饪可以看一个人的性格，慢性的人喜欢慢炖，性急的人喜欢爆炒，心细的人爱做复杂精致的菜，但不管什么样的性格，烹饪都需要保持一个好心情才会做的好吃。
0、放盐的多少关系着一道菜的生死，最关键的放在最前边讲
1、鱼煎过后再煮才会变白汤，而且要双面煎（某电影有提）
2、炖骨头汤时冷水下锅小火炖6小时变白，重复加水时万不可加冷水，只要一直保持加热水汤可以一直是乳白色（当然骨头没有营养了记得换掉）加一滴醋会瞬间变清汤
3、任何肉类在遇热后在遇冷怎么煮都不会烂，所以做红烧肉一类的菜在烹饪过程中万不可加冷水（另补充补救的办法，利用高压锅的超高内温可以再次溶解肉类，有同学说有地方喜欢吃弹的可以用冷水处理）
4、99％的菜都在临近出锅前才可以加盐、醋这两种调味品，过早的投入不仅影响口感，还会使菜变得难看
5、灵活的运用酱油，分清酱油的种类，分别的作用，最简单的是生抽调味，老抽上色
6、炒鸡蛋记得用筷子炒，炒的时候慢慢的将鸡蛋滑散，你会发现因为受热均匀鸡蛋变得更蓬松更大了
7、学会焯菜，在菜变色的同时捞出，有些需要口感清脆的菜还要立刻过凉水
8、炒菜要遵循一个道理，最难熟的先下锅，可以生吃的最后放
9、永远不要忘记葱姜蒜，他们很重要
10、糖有时候是为了甜，有时候是为了更突出咸或者辣，同理盐有时候是为了咸，有时候是为了更突出甜（全靠这个多年来耻笑表哥的料理能力）
11、肉类遇到酸会变嫩，很多菜吃起来并没有酸味，可是却有一丝丝说不清的醋香，其实那是在出锅前加了一瓶盖起锅醋，起锅醋适用于绝大多数肉类炒菜
12、可以去腥的东西有很多，味精，鸡精，白糖，料酒，柠檬皮都可以用来去腥
13、记得酸是甜的老婆，辣是甜的二奶，酸是辣的姐姐，咸是辣的闺蜜，甜是苦的哥们。他们是黄金搭档（这是母上的经验之谈，适用于绝大多数料理）
14、炸肉类火不要大，否则面衣糊了肉没熟，快熟的时候火不能小，不然油都被吸到食物里，这也就是复炸的用意。（母上万岁）
15、学会油泼，最简单的练习水煮肉片
16、记住你吃过的每一道菜，有些蔬菜的经典搭配是全球通用的，比如茄子配蒜，洋葱配肉
17、蒸米饭加点油会让米颗粒分明，加百合会让米饭变甜，加啤酒会让米饭变香，用高压锅蒸米饭更香，隔水蒸米饭更筋道，淘米水是最好的天然餐洗 净，糊锅了插几根葱，有的时候可以挽救米饭（家父是料理界的格格巫，经他手的食材都会变成碳，没有碳化的部分还不熟，我就天然的领悟了这个能力了）
18、想要鸡蛋嫩，打鸡蛋的时候加水（小学看小当家学到的）
19、切肉要逆纹路纵向切，不然咬不动煮不熟（肉丝顺纹路切，不然会断，速成鸡肉一类较嫩的肉类需要顺纹切不然会散，速成猪肉的肉质较鸡肉更老比 牛肉更嫩要斜切，土猪肉则纵切，整块的猪肉又需要逆纹切，总之需要自己理解肉类的紧实度选择切的方向，谢提醒）切蘑菇要顺纹路不然吃起来太糯，切笋要避开 纹路斜切不然切不动也咬不动
20、整块的肉料理需要断筋，用刀背给予一定力道，不需要太大力，重复在肉面敲打3分钟
21、辣味不是只有辣椒，还有黑白胡椒，姜，蒜。同理甜味不只有糖，还有蜂蜜，果糖，各种饮料等。酸味不是只有醋，还有柠檬，山楂等
22、蜂蜜也可以用作嫩肉（食戟之灵）
23、一定要试菜，由于很多菜重要的调味都在最后步骤，试菜可以很大程度上解决味道不够的问题，所以最后的关键调味料宁缺毋滥！调味结束后不要忙着关火，试过之后没问题在出锅，俗话说饿死的厨子三百斤，就是说的试菜
24、热锅凉油是为了给高蛋白食物一个缓冲，不至于外面熟了里面不熟，还有个好处是蒸腾锅内多余水分，不至于遇油飞溅，多用于滑炒，上浆的肉片什么的。热锅热油，锁水，用于爆炒
调料：
1、鱼香味（sorry，各严格的原产地同学表示我这个鱼香太水了，我就删掉了，正经八百的鱼香据说非常稀有，几近失传，我此生可能无缘吃到，本着不会不写的心态我就不加了）
2、红烧就是老抽上色＋生抽调味＋糖
3、宫爆味就是生抽＋水淀粉（或豆瓣酱，也有凝固的作用）＋干辣椒＋糖＋醋＋葱白
4、勾芡就是淀粉＋各种液体预热凝固（糖醋里脊，糖醋鲤鱼也是）
5、韩国味就是韩国大酱＋韩国辣酱
6、照烧汁就是蜂蜜＋日本酱油
7、老干妈豆豉可以直接用做调料，比如回锅肉，蛋炒饭
8、关东煮汤料，日本酱油，苹果，海带，水果萝卜，炖4个小时（有先后顺序）
9、白灼就是蚝油＋糖＋盐＋葱蒜
10、火锅蘸料：①花生酱＋芝麻酱＋盐或者生抽＋巧克力＋水调成糊状菜肉蘸料（这就是店里的秘制酱料，某前男友教的）。②海鲜汁＋凉拌酱油＋蚝油＋醋＋糖＋香油＋香菜碎调成肉类蘸料（火锅店吃还是在家吃都很方便，另一个前男友教的）
11、蛋黄酱就是原味沙拉＋鸡蛋黄搅拌均匀
饺子馅：
**1、红肉类：**各种红肉馅＋各种配菜＋十三香或者五香面少许（去腥）＋白糖少许或者耗油（去腥，耗油本身有 甜味取其一）＋姜汁（去腥，超市有卖）＋料酒（去腥）＋香油（母上会在添加花生油用作调味）＋盐＋鸡精＋生鸡蛋＋花椒油（去腥，是有多腥！）（羊肉属于味 道较重的肉类可以用胡萝卜大葱来遮掩一点点味道，另有的地方肉馅会加酱油）
**2、白肉类：**鸡肉或者鱼肉＋猪肉或者牛肉＋各种去腥少量版＋鸡精＋韭菜或者胡萝卜（别的配菜没试验过，因为韭菜跟胡萝卜属于重口味蔬菜，可以中和不和谐的味道）
**3、素馅类：**各种蔬菜馅（各种含水量大的蔬菜都需要在剁好馅后撒盐静置一段时间过滤掉多余水分，此步骤为杀水）＋香油＋盐＋炒鸡蛋＋木耳碎（可以不加）＋鸡精
**常备的调料：**盐，糖，米醋，豆瓣酱，郫县豆瓣，老干妈豆豉，料酒，鸡精，白胡椒粉，黑胡椒粉，花椒，葱姜蒜，干辣椒，香油，蚝油
**可选调料：**番茄酱，白醋，各种混合酱油，黑白芝麻，干木耳，干香菇，干银耳，枸杞，沙拉酱，蛋黄酱，千岛酱，金枪鱼罐头，花生酱，芝麻酱，豆豉鲮鱼，午餐肉，方火腿，各种罐头，咖喱，姜汁，蒜汁，花椒油，米酒
**炖料类：**桂皮，八角，肉桂，香叶，山楂干，柠檬，十三香（柠檬籽与香叶有苦味，放的时候记得去籽，少量）
根据上文的理论进行的一些简单的料理实践，通过一点点更改原有做法，从而突出个人特色，但又不会变成黑暗料理的方法，要知道我那些年做过多少黑暗料理才总结出来！
番茄炒蛋：（由于番茄是酸的，可以跟刚才提到酸配甜或者酸配辣可以混搭一下，那么做法就变成）鸡蛋加水打 散，下油锅（油温要高一点）用筷子炒到凝固盛出待用，下番茄炒到出汁，喜欢汁多就多炖一会，加入白糖，加入炒好的鸡蛋翻炒均匀，出锅前加入盐，蒜片，待闻 到蒜香的时候即可关火盛盘，这样的番茄炒蛋酸甜适口，鸡蛋蓬松滑嫩，又有一丝微微的蒜辣混杂着蒜香，最适合下饭。
水煮肉片：（这道菜有个简单的逻辑，肉要碗里熟）
1、里脊肉或者牛肉切薄片（有朋友表示新手难切，加入方法，将肉在速冻层冻半小时再切肉会定型），加入鸡蛋，淀粉，盐，料酒腌制2小时
2、可以选用各种带叶菜，我喜欢油菜或者圆白菜，生菜撕成块状大小随意，加水，盐煮菜5分钟后连汤带菜一起盛出。
3、热油把肉炒到变色断生铺在菜上，撒上盐，辣椒粉，葱碎（新手请加入超市花椒粉，或者花椒在微波炉叮一分钟用蒜窝捣碎铺上）
4、重新热油放入花椒，干辣椒煸糊（有朋友表示蹦糊有苦味，糊不是真的让他变成碳，红色脆硬或者红黄相间即可，上一部加了花椒粉的就不需要花椒了），趁着油温最高的时候浇在肉跟料上即可。
高油温与菜的热度会将肉煮熟。由于用料随意这基本上算是入门级的肉类料理，对于刚学做菜的人来说，这算是拿的出手的大菜了。
洋葱炒肉：（会用到上面我们说到“起锅醋”这个东西）
1、随意猪或者牛肉切丝用生姜，料酒，盐腌，淀粉制十分钟；
2、锅中倒油，烧热，放入腌好的肉丝，迅速拨开，炒到肉丝变色；
3、加入洗好、切好的洋葱，放入适量的酱油，和盐；
4、加入味精，倒入一瓶盖米醋，翻炒5秒出锅装盘。
全靠那一瓶盖醋，从不吃洋葱的傲娇表弟把盘子都舔了。
回锅肉：（好开心，辣的哎）
1、将二刀肉（有的地方叫二条，就是肥瘦各一半的肉）整块放入热水煮熟
2、用筷子试插，如无血水渗出即已熟透，捞出，待冷却后切成薄片备用（上面提到过不可接触凉水）
3、青辣椒洗净，去蒂去籽，切成菱形</description>
    </item>
    
    <item>
      <title>TortoiseGit提交到远程仓库时git did not exit cleanly (exit code 128)</title>
      <link>https://www.yuedun.wang/blogdetail/564554fec888d8070f145c36/</link>
      <pubDate>Fri, 13 Nov 2015 03:11:58 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/564554fec888d8070f145c36/</guid>
      <description>虽然出现git did not exit cleanly (exit code 128)的情况各有不同，不过其中一种是提交时的读写权限有问题，如果本地代码连接的是SSH仓库，那么可能是服务端没有配置SSH Key。github有两个地方配置sshkey，有一个是全局的，另一个是针对单个仓库的，如果给某个仓库配置了Deploy keys（其实和SSHkey一样），提交另一个代码时就会出现git did not exit cleanly。对于我这种不熟练的人来说就想着再添加一个Deploy keys，但是又提示Key already in use，这时就要看看是不是其他仓库单独配置了ssh key。如果仓库太多具体哪个配置了也不太清楚，有个简单快读的办法是在命令行执行 ssh -T -ai .\id_rsa git@github.com，会告诉你哪个仓库在使用本地的id_rsa内容。删掉Deploy keys，配置为全局SSH Keys就行了</description>
    </item>
    
    <item>
      <title>Git SSH Key在windows下生成过程</title>
      <link>https://www.yuedun.wang/blogdetail/56400429c888d8070f145c35/</link>
      <pubDate>Mon, 09 Nov 2015 02:25:45 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56400429c888d8070f145c35/</guid>
      <description>切换到C:\Users\\.ssh
执行命令：ssh-keygen -t rsa -C &amp;ldquo;邮箱地址&amp;rdquo;
Generating public/private rsa key pair.
Enter file in which to save the key (//.ssh/id_rsa):
第一次生成由于没有id_rsa文件和id_rsa.pub文件，所以需要生成这两个文件，然后手动输入：./id_rsa
Enter file in which to save the key (//.ssh/id_rsa): ./id_rsa，虽然要求输入//.ssh/id_rsa，但这种方式不是在当前目录下
接下来两部是要求输入密码，不输入直接回车就完成了。
PS C:\Users\admin\.ssh&amp;gt; ssh-keygen -t rsa -C &amp;#34;myemail@163.com&amp;#34; Generating public/private rsa key pair. Enter file in which to save the key (//.ssh/id_rsa): ./id_rsa Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in .</description>
    </item>
    
    <item>
      <title>nokia诺基亚XL4g开不了机</title>
      <link>https://www.yuedun.wang/blogdetail/563ec26201908e12987ef72a/</link>
      <pubDate>Sun, 08 Nov 2015 03:32:50 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/563ec26201908e12987ef72a/</guid>
      <description>昨天用了一天的手机，晚上用着突然就黑屏了，死活开不了机，以为是没电了，充电时也开不了机。奇怪的是用了一天一直显示满电，怎么突然就坏掉了。抠电板试试，还是开不了机。扣电板充电，总算有点反应了，但是还是开不了机，不过这种情况遇见过，就是刚买回来试试有没有问题时没装电池充电一闪一闪的震动就是开不了机。后来才发现要装了电池才能开机，但是这次为什么装了电池也开不了机，反而是一点反应也没有。今天早上起来用数据线连接电脑打算刷机试试，刚连接电脑也是开不了机，就把电池扣掉，这时出现了充电的反应，原来是一点电量都没有了。充了一会总算是开机了。所以，如果突然开不了机可能是一点电都没有了，建议先充一会电再开机试试。</description>
    </item>
    
    <item>
      <title>无插件实现动态瀑布流加载数据</title>
      <link>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</link>
      <pubDate>Tue, 03 Nov 2015 03:02:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</guid>
      <description>以前在页面中动态加载帖子数据使用了waterfall.js插件，当初折腾了不少时间才搞定，这次又有一个页面需要动态加载数据，自然想到了waterfall插件，但是结果很不理想，waterfall的很多参数不管是什么用处，反正看着很头疼，最麻烦的是它会改变页面样式和布局，实在不想调整了，还是自己实现这个功能吧！
首先看下面代码：
var pageIndex = 2; (function loadmore() { //绑定滚动事件 $(window).bind(&amp;#34;scroll&amp;#34;, function() { if ($(this).scrollTop() + $(window).height() + 40 &amp;gt;= $(document).height() &amp;amp;amp;&amp;amp;amp; $(this).scrollTop() &amp;gt;= 40) { $(window).unbind(&amp;#34;scroll&amp;#34;); //到底后先移除滚动事件 $.get(&amp;#34;/portal/getTopic?pageIndex=&amp;#34; + pageIndex + &amp;#34;&amp;amp;amp;pageSize=3&amp;#34;, function(data) { $(&amp;#34;#container&amp;#34;).append(data); pageIndex++; loadmore(); //数据加载成功重新绑定滚动事件 }, &amp;#34;html&amp;#34;); }; }); })(); 没错，就这么点，这已经是实现功能的最简单版本了。代码的基本流程是给页面绑定滚动事件，判断是否滚动到最底部，然后加载数据。但实际上并不是这么简单就能行的，有很多意外情况需要解决。
先来说明如何判断页面是否滚动到最底部，$(this).scrollTop()用来计算滚动条顶端距离窗口顶部的距离，整个滚动条高度大约等于整个页面高度。当滚动条滚动到最底部的时候，滚动条顶端距离窗口顶部并不是整个页面的高度，还需要加上当前窗口所占高度才是整个页面正真的高度。所以就是$(this).scrollTop() + $(window).height()=$(document).height()，但是我们为什么还要加40呢？因为一般滚动到底部加载并不是完全要滚动到最低端才加载，而是差不多已经到底的时候就要开始加载，既然是差不多到底那么$(this).scrollTop() + $(window).height()就是还不完全等于整个页面高度，因为还有40没有滚动，所以加上了才是整个页面高度。此时滚动到距离最底部还有40像素的时候，再滚动一点就会大于页面高度，就该加载数据了。代码中还有&amp;amp;amp;&amp;amp;amp; $(this).scrollTop() &amp;gt;= 40是为了监听有滚动发生，总不能在没有滚动事件发生时就加载。
已经能够监听到是否滚动到底部了，但是滚动事件是稍微滚动一点就能触发好多次，就会请求好多次数据，就算数据没有返回稍微滚动就会继续发送同样请求，所以在数据没有返回之前要把监听滚动移除掉，$(window).unbind(&amp;quot;scroll&amp;quot;);等数据添加到页面以后再重新绑定滚动事件。</description>
    </item>
    
    <item>
      <title>检测网站中未使用的css样式</title>
      <link>https://www.yuedun.wang/blogdetail/563069efaa0d5223f187dfa4/</link>
      <pubDate>Wed, 28 Oct 2015 06:23:43 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/563069efaa0d5223f187dfa4/</guid>
      <description>网站的css样式文件在多次修改后会有很多样式废弃不再使用，使得维护起来困难，还可能出现重名样式，后面的覆盖掉前面的效果，所以有必要清除掉不再使用的样式。可以使用的工具很多，不过在使用了Dust-Me Selectors觉得足够了。
https://addons.mozilla.org/en-US/firefox/addon/dust-me-selectors/
打开上面网址安装
直接点击这个小扫把会检测当前页面没有使用的样式，不过这样的结果还不是我们想要的，因为当前页面没有使用不代表其他页面也没有使用。我们更需要的是找出整个网站中未使用的样式。
选择第一项“Spider Sitemap”，就像是百度蜘蛛爬取整个网站数据一样。
输入网址，本地网址和网络地址都可以检测，点击“Start”后很快就有结果了，如果页面较多会费时些。
可以看到有橘黄色部分就是没有使用的样式，但是这也不能完全代表就是没有使用过，上面三个未使用的样式是我对于博客内容的图片和引用块使用的样式，因为本地的测试内容中的确没有使用这三个样式，但是线上的网站却使用了，遇到这种情况就需要仔细甄别了。
再看一下扫描的页面日志
基本的页面都有扫描过了。此时可以手动删除掉没有使用的样式，这个插件对于简单的网站够用了，但是大型网站就不准确了，当然有些其他工具还可以导出检测后的结果。有必要的可以去下载。</description>
    </item>
    
    <item>
      <title>linux下添加svn用户名密码</title>
      <link>https://www.yuedun.wang/blogdetail/562d9ca9c6ed32d312337025/</link>
      <pubDate>Mon, 26 Oct 2015 03:23:21 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/562d9ca9c6ed32d312337025/</guid>
      <description>首先需要知道配置文件的位置，比如我们的服务器中我就找到很多关于svn的目录，甚至分不清哪个目录下才是真正的配置文件
root@handou:~# find / -name subversion
/home/handou/workspace/subversion-1.8.11/subversion
/home/handou/workspace/subversion-1.8.11/subversion/bindings/javahl/src/org/apache/subversion
/home/handou/workspace/subversion-1.8.11/subversion/bindings/javahl/src/org/tigris/subversion
/home/handou/workspace/subversion-1.8.11/subversion/bindings/javahl/tests/org/apache/subversion
/home/handou/workspace/subversion-1.8.11/subversion/bindings/javahl/tests/org/tigris/subversion
/etc/bash_completion.d/subversion
/etc/subversion
/usr/share/doc/subversion
查找所得结果可以确定应该是在 /etc/subversion下，切换到subversion下有多个文件：
config config.dpkg-dist dav_svn.authz dav_svn.passwd passwd servers
可能需要一一查看下都是什么内容，其实主要是dav_svn.authz dav_svn.passwd这两个文件，一个存放用户名，一个存放密码，dav_svn.authz内容包含账号和权限：
[groups]
apiadmin=yuedun
[handou:/]
@admin=rw
@apiadmin=rw
可以编辑这个文件添加账号，然后添加密码，但是不能直接编辑dav_svn.passwd，这里面是加密数据，需要使用Apache的htpasswd命令添加。
htpasswd /etc/subversion/dav_svn.passwd &amp;lt;用户名&amp;gt;
然后会提示输入密码，就此完成svn账号设置。</description>
    </item>
    
    <item>
      <title>一个下载电子书籍的好网站</title>
      <link>https://www.yuedun.wang/blogdetail/5628ab0882f22d389ded545a/</link>
      <pubDate>Thu, 22 Oct 2015 09:23:20 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5628ab0882f22d389ded545a/</guid>
      <description>http://www.chnxp.com.cn/
几乎可以下载到任何想要的书籍</description>
    </item>
    
    <item>
      <title>手机和PC联机调试Debugging Firefox for Android with WebIDE</title>
      <link>https://www.yuedun.wang/blogdetail/56286fd6ce46c19e89132969/</link>
      <pubDate>Thu, 22 Oct 2015 05:10:46 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56286fd6ce46c19e89132969/</guid>
      <description>Firefox提供了在PC端调试手机端页面的工具，详情查看： https://developer.mozilla.org/zh-CN/docs/Tools/Remote_Debugging/Debugging_Firefox_for_Android_with_WebIDE</description>
    </item>
    
    <item>
      <title>使用sublime开发node.js快速跳转到变量函数声明处</title>
      <link>https://www.yuedun.wang/blogdetail/56286643ce46c19e89132968/</link>
      <pubDate>Thu, 22 Oct 2015 04:29:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56286643ce46c19e89132968/</guid>
      <description>开发中最常用的操作之一就是快速跳转到变量，方法声明处，比如在eclipse中按住Ctrl键鼠标点击变量或方法就能跳转到对应的位置或文件中，开发nodejs程序当然也需要这样的功能，比较强大的开发工具有webstorm，也是支持这种操作的。不过webstorm太占内存，4G的内存下总是提示内存不足，需要关闭占用内存程序，而首当其冲的就是webstorm，所以最近试了试另一款被大家熟知和推荐的开发神器sublime。虽然sublime是个文本编辑器，还不能算的上IDE，不过它可以安装各种插件来丰富功能，最重要的是它占用内存少，速度快。
所以，我要介绍的是在ST下如何做到跳转到变量或方法声明处。
首先在uses.js文件中有一个函数
//我是一个测试方法 router.get(&amp;#34;/commeHere&amp;#34;, function(req, res) { }); 然后我要从其他文件中跳转到这个函数。先关掉这个文件，打开其他文件。
可以双击或鼠标选中commeHere这个关键词（才发现单词打错了），键盘按下Ctrl+shift+F就会出现类似搜索框，选中的关键字会填充到find框中，需要手动选择where框，选择Add Open Folders，文本框中填充的就是，然后回车就可以了，很快就会搜索出我们需要的关键字所在的文件。
双击就可以跳转到对应的文件和行上。
当然，不可能像eclipse中那么方便，但其实只有两步操作，第一ctrl+shift+F搜索关键字，第二双击搜索结果跳转到对应文件位置。如果你习惯使用ST的话肯定很满足这样的设计，根本不会觉得繁琐。</description>
    </item>
    
    <item>
      <title>windows下使用脚本快速启动nodejs服务</title>
      <link>https://www.yuedun.wang/blogdetail/5624482861248de07b01887a/</link>
      <pubDate>Mon, 19 Oct 2015 01:32:24 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5624482861248de07b01887a/</guid>
      <description>每次启动node服务都要先打开cmd命令行，或者在win8下先打开文件资源管理器&amp;gt;文件&amp;gt;打开命令提示符，然后执行node命令，这样的过程真的很烦人，当然需要一个简单粗暴的方式启动了，就像用bat文件双击启动。
首先，建一个空白文件，输入以下内容：
E: cd E:\\NodejsWorkSpace\\app-node nodemon ./bin/www 就像我们平时要依次输入这些内容一样，不过还有更简单的方式：
E: &amp;amp;&amp;amp; cd E:\NodejsWorkSpace\app-node &amp;amp;&amp;amp; nodemon ./bin/www
使用&amp;amp;符号连接各个命令也可以</description>
    </item>
    
    <item>
      <title>数据表索引如何建立？多列索引还是单列索引</title>
      <link>https://www.yuedun.wang/blogdetail/5620bcc461248de07b018879/</link>
      <pubDate>Fri, 16 Oct 2015 09:00:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5620bcc461248de07b018879/</guid>
      <description>数据库优化第一想到的应该是建立索引，而且是最快速有效的优化方式，一般是对where子句中的字段建立索引，但是并不是越多越好，对于基数(区分度)越大的效果越好，比如唯一索引。对于一些表示状态的，比如值为0,1这类区分状态的字段就算数据再多索引的基数也很小，这类字段并不是非要加索引，加的索引越多越占磁盘空间，每次写入数据都要更新大量索引，反而成为累赘。但是不要以为真的没必要加，初学者对索引的认识浅薄，要么不加索引，要么在建表时就妄自推断加了很多索引。那么如何加索引才是正确的做法呢？
数据库中有一种是单列索引，一种是多列索引，要怎么加需要搞清楚这两者的区别，当查询条件有多个字段时，单列索引和多列索引有很大的区别。
如果使用多列索引，where条件中字段的顺序非常重要，需要满足最左前缀列。
最左前缀：查询条件中的所有字段需要从左边起按顺序出现在多列索引中，查询条件的字段数要小于等于多列索引的字段数，中间字段不能存在范围查询的字段(&amp;lt;,like等)，这样的sql可以使用该多列索引。
mysql多列索引适合的场景
全字段匹配 匹配部分最左前缀 匹配第一列 匹配第一列范围查询(可用用like a%,但不能使用like %b) 精确匹配某一列和和范围匹配另外一列 order by操作中出现的字段同样适用于按值查找的规则，where+order by中出现的字段需可以建立满足如上五种规则多列索引。 使用多列需要按照最左索引列查找；不能跳过中间列；如果某一列是范围查询，那么其右边所有列无法使用索引。 IN什么情况下是范围查询，什么情况下是多个等值查询？如果有order by排序时，多个等于条件查询就是范围查询，没有order by排序就没有限制。 例如,建立多列索引(name, age, id), 只能使用索引的前两列。in是范围查询 &amp;hellip; where name=&amp;ldquo;nginx.cn&amp;rdquo; and age in(15,16,17) order by id 可以使用整个索引，in是按值查询 &amp;hellip; where name=&amp;ldquo;nginx.cn&amp;rdquo; and age in(15,16,17) and id =&amp;ldquo;3&amp;rdquo;</description>
    </item>
    
    <item>
      <title>一名赣州车主处理“碰瓷”过程，值得认真学习</title>
      <link>https://www.yuedun.wang/blogdetail/5617523fbfae4b590b7a4aab/</link>
      <pubDate>Fri, 09 Oct 2015 05:35:59 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5617523fbfae4b590b7a4aab/</guid>
      <description>一名赣州车主处理“碰瓷”过程，值得认真学习，文很长，但值得一读。
保险公司会吓唬你，交警也会嫌麻烦忽悠你，只要你捂紧你的钱包，除了时间，其实你不必付出任何费用来缴纳到这场事故中。
#m第一篇 事故过程和处理
第一章 事故发生 14日早8点左右，我从厚德路由东向西正常行驶，越过厚德路小学路口约10米后，前方一电动车突然左转横过机动车道然后逆行欲进入厚德路小学，由于她车速太快，电动车后座上反向乘坐的小女孩将左腿伸出车外，致小女孩左小腿撞在我车的右前大灯上。
事故发生后，小女孩拼命哭叫，我无法判断伤情（虽然我知道肯定没大事），对方也不提如何处理，对于这种手段老辣的人，为避免被敲诈，我决定报警、出险走正当程序。
警察、保险先后到场，警察也不主动提调解，我也就不提，因为我认为是对方全责，保险的希望我私了，还说不私了对我很不利，拖车、停车费是不赔的，当时有点心动想私了，但很不甘心，对方也不说私了的事，还强说我撞他，小孩又被120拉走，内心深处其实很想完整的走次事故程序（还没出过双方事故），也很不服拖车、停车费问题，想和交警较量下，再考虑到马上放假不太用车，最后还是决定走正常程序。
交警看双方不能现场调解，于是叫车来拖对方的电动车，扣下我的驾照，叫人开我的车去停车场，我也去直属大队事故科领回扣车单据。
回家马上查法规，等看到法律规定（《中华人民共和国行政强制法》第二十五条、第二十六条）停车、鉴定、检验费用由行政机关承担，心里踏实多了，也明白保险公司的险恶，他当然希望当事人私了，他就可以不费时、不费力、不出钱，还拿一般人很害怕的停车、拖车费来吓人，还好没吃他那套。继续查到事故责任认定书应当在10个工作日做出，事故责任认定书作出后就可以拿回车子，感觉更没什么了，也就半个月吧（当然各人情况不同，好车或没车不行的人另当别论），咱能等。
策略：事故发生后迅速判断各种因素，做出最有利选择
第二章 对扣车的行政强制行为提出行政复议 怎么讲车都是被扣了，心里总还是不舒服也不服气的，其实车主都明白，交警扣车无非就是希望机动车主能赔钱结案，警察省事又不容易发生信访事件。很反感交警动不动就扣车，于是继续查法规，发现法律只规定“因为收集证据的需要”（《中华人民共和国道路交通安全法》第七十二条）才能扣押事故车辆而且扣押车辆需要履行很多手续（《中华人民共和国行政强制法》第十八条、第十九条、第二十四条），当时想不通这么简单也没有车辆损失的事故还要收集什么证据，而且扣押财物是要履行必要的法定程序的，于是马上写好行政复议申请书，下午就去交警支队。
到了支队进门要登记，一开始说去法制科，门卫说没这个科，于是说去行政复议办公室，门卫居然不知道有行政复议办公室，瞎指挥让我去7楼，整个7楼没有挂牌的办公室还都锁着，还好碰上2个穿制服的警察，问了以后说在4楼，于是去4楼，其实4楼是对交通事故责任认定书提出复核的地方，那里一个领导模样的人开始也以为是复核，问清是对行政强制行为复议后，打了电话问别人才说要去6楼秩序科，于是明白，很少有人提起行政复议啊，大家业务都不熟啊，中国真是刁民太少，天天在网上费唾沫没用啊，不如实际做点什么，赣州每天多少事故多少车被扣啊，别说多，每天有一个人复议，交警支队门斗挤破了，如果每个人对发生在自己身上的不公都提出行政复议、行政诉讼，中国早就官不聊生，早就不是现在这个样子了。
终于到了6楼，马上发现有个办公室挂着行政复议办公室的牌子，心里骂门卫：文盲加法盲，怎么TMD都这素质啊。可门锁着，正好以前坐电梯上来的几个警察也走过来，一问是行政复议的，马上进了秩序科办公室。和每次行政复议一样，对方总是推脱说些理由，一番唇枪舌剑后，最后表示什么也别说了，按行政复议法规定的程序办理吧，对方终于没办法说受理了。
一等就10多天，什么消息也没有，其实早就知道这样的结果，因为每次复议哪个行政机关都这样，25号过完节也放暑假了，于是再去交警支队，直奔秩序科，进门一说要拿行政复议受理通知书，对方和以前一样搬出领导不在要审批所以还没办等等说辞，我也冷处理，只问什么时候能拿到，一个主管模样的说今天一定会联系你，可今天26号了，还没动静，准备明天再去联系。
咱也不急，先施加压力，看事故中队这边责任认定书怎么出，如果不认定对方全责（其实全不全责都是保险赔，我只是找理由和警察PK），我就两边一起动作，同时打2场行政诉讼；如果认定对方全责，还要看拿回车子的过程是不是没有障碍，不爽的话还是打官司（呵呵，我无责也要打官司，要交警好看）。
第三章 调解、检验等前处理程序 15日下午，到事故中队调解，我早考虑好了，直接说调解就是各走各路，看着对方拿着各种片子和单据想问我要钱的样子，我很想告诉他：首先钱应该保险公司出，如果是抢救（什么是抢救法律也是有明确定义的）费用交警会责令保险公司垫付，也是与我无关的，只有超出交强险限额的部分我才承担，其次，事故责任认定书出来后你也是与保险公司协商赔偿，我可以不介入的，如果对保险公司的赔偿不满只能向法院起诉，法院判保险赔多少让它赔，超出交强险限额的部分按责任法院判我赔多少我才赔，我的损失只是用车不方便，这么小的事故而且你全责，我很欢迎你去法院起诉，说不定我反诉你，我还可以拿点钱呢。当然没说，反正我没出1分钱，懒得和他怄气。
直接谈崩回家，其实真的是为了对方好也为了交警好，自我拔高下，呵呵：如果我赔了钱，对方下次还会违章，这次我是谨慎驾驶车速很慢，下次碰上个飙车的那结局很难想象，你就是赔了钱，人没了有什么意思？交警也就只图自己轻松，现在道路交通拥堵、事故多很多原因是行人、非机动车违章多又难管理、难处罚，好嘛，管不好行人、非机动车，交警就压迫机动车方，扣车迫你就范，让我这个机动车主免费帮你们教训下违章非机动车有什么不好啊。
21号去事故中队做笔录，本来也没啥说的，交警叫我复印下被扣的驾照，可气的是去4楼复印居然要1块1张，还是个律师事务所的，中国就这帮黑心的狗腿子搞坏了，懂法执法的人都不守法。浪费他2张纸，然后问他要FP，他不给FP，我也就转身去楼下找店家，靠，狗还真多，紧挨事故中队一家复印店先问复什么，一看是驾驶证也叫价1块，插，哪天我办完这件事，把这两家店一起投诉到工商局去。继续往前走，很快就找到家2角的，既锻炼了身体又省了钱，还战胜了黑心狗，还是蛮愉快的（咱是个闲人，时间多，其他人慎重），只是悲哀中国狗太多还有人闲着没事拯救狗的（赤那），更悲哀中国良民太多，那个律师事务所明显占用国家资源（办公室居然在行政机关内），与交警肯定有利益关联，而且非法超出范围经营（律所没有复印的营业执照的），也没一个人去投诉，难道我又要成为第一个吃螃蟹的人？
做笔录的时候，来了个处理事故的，可怜兮兮的样子，上来就发烟，还给我1支（我不抽烟，也没发烟给过交警），那警察也够坏，拿出好几份鉴定报告让那人去复印，还要那人去交鉴定费，那人很老实没有一句怨言地去了，我看着他的背影心底无限悲哀，***也只能现在这个样子了，人民就这水平啊，这样的水是不可能覆舟的，同时心底打定主意，以后决不去复印、更不可能交任何费用。
26号下午通知我去拿车辆性能检验报告，办案协警还是叫我去复印，我先拿过来看完检验结论合格，然后装傻，怎么叫我去复印啊，也许是昨天去支队要复议通知书的消息传到这边，起了效果，主办的正式民警知道我难对付，就叫协警别啰嗦自己去复印（我判断一定是去4楼那律所不要钱复印来的，黑啊），然后，告知我如果双方对检验结果都没有异议，就可以拿车了，还说不管你交不交费，都会放车。呵呵。
第四章 车辆技术性能鉴定报告 拿到鉴定报告第一眼看结论，合格，2月年检了，意料之中，但也算放心了；可看见日期很不爽，送检居然写15号，这么简单的鉴定居然要11天到26号才出结果，很显然是交警与司法鉴定所穿一条裤子，要么是更改送检时间包庇交警（因为法律规定要在事故发生3个工作日内送检），要么是故意拖延时间，配合交警长时间扣车，法律对鉴定的期限规定太宽松，《交通事故处理程序规定》是20天，《司法鉴定管理条例》是15天，鉴定时间还不算入办案时间。
我的策略是去司法局投诉，虽然没有证据，但就按我自己猜测的写，既不要钱，写错了也不犯法，呵呵，投诉立案了司法局就会去查，查出问题自然好，一般来说总会有点问题的，特别是鉴定程序上，这些官办鉴定机构也是老爷作风；司法局这边也可能出错，反正司法局要出书面处理结果，到时再找他们的漏洞，不过司法鉴定的行政官司很难赢，法律基本空白，但可以行政复议，反正不要钱，但也止于行政复议。
第五章 高潮：拿回自己的车 26号拿鉴定报告，27、28、29三天双方都没有对鉴定结论提出异议，7月2号鉴定结论确定，但当天因有事去南昌没能去拿车，7月3号，办完事10点来的交警办公室，等到10点半大仙终于回来了，向办案的正式民警提出拿车的要求，这个家伙估计是早准备好的，居然说要等鉴定结论确定5天后才能领车，因为这几天对方可能申请法院诉前财产保全（浑蛋法律术语还知道点啊，可法律不行）；本来倒也早就预料交警会找借口，没什么，但可气的是边上一个凯莱律师事务所来办事的律师居然为讨好交警帮着他说些违背法律的说辞（唉，TMD狗真多，完全如先生狂人日记的情形）；我随即反驳：第一，法条明文规定是鉴定结论确定5日内领车，没有5日后领车的法条，要继续扣车请提供法律依据；第二，法院与你们不是一个系统，如果法院委托你们扣车请提供委托书。丫的居然还嘴硬，于是向他们领导投诉，回来交警改口了，自己还找个台阶：领导这么说了怎么办呢？好无辜的样子，勒个去的，过会打印车辆放行呈报表的时候审批理由里就是我说的法条，他根本就是知法犯法，丫的天天都在这么办还来故意刁难我，好吧，看我的。
吃完饭直奔吉埠新村停车场，交了放行单，如我所料守门的要我交19天20元/天的停车费，和开车来停车场的开车费50元，共计430元，于是我迅速拿回放行单，“还要交钱啊，交警没说啊”，守门的当然不肯。于是不废话，转身出来拨打110，报警说有人在吉埠新村非法扣押我的车辆并向我敲诈勒索，接警的也想混，说你们这是纠纷啊，自己解决啊。我说我有车辆放行单，车辆就处于合法自由状态，任何人阻拦就属于非法扣押私人财物，接着问你受理不受理，会不会出警？她没办法，说你等会。很快沙石派出所打来电话（这一点还是要肯定的，110必须出警现在规定的很严），还是一番唇枪舌剑，派出所的总推是纠纷，我坚持即使有纠纷任何人也不能非法扣押私人财产，没办法派出所答应出警。因为是午间休息时间，停车场那边与交警领导暂时沟通不上，于是民警说那就等会他们与交警联系了再说吧，我于是坚持回派出所作报案笔录（这点要强烈提醒各位朋友，千万别在现场傻等，一定要去派出所做笔录，否则，很可能警察出警后会记录为调解处理，很可能就没结果了，你要再提也还是要去派出所作笔录，被对方看出你不精于法律，再打交道就锐气尽失了），因为一旦形成笔录，这个案子就不是纠纷而是治安甚至刑事案件，派出所要结案（不按非法扣押财物处理，你可以行政复议），材料很多涉及面很广，派出所不愿意，自然会给停车场施压（毕竟其行为涉嫌犯法），交警也知道自己这么承包出去不合法，万一媒体曝光就很麻烦。
做完笔录再去停车场，还在路上，派出所的警官就打来电话：你去找停车场，我已经沟通好了。到了停车场还顺利，车都摆好位置了（第一次来我的车是被堵在里面的），老板娘来了，很气也很无奈的诅咒：我们这了敞开大门欢迎你常来，我回复：谢谢您吉言，心里说，我常来你也收不到钱。开车回家，第一件事洗车，去晦气；第二件事，发帖，哈哈。
第六章 余味：总结 1、关于行政复议：个人认为行政投诉和行政复议是公民个人维权最有效的手段，当发生侵害您权利的事件时（如您楼下某餐馆排油烟），确定侵权人管辖的行政机关和违反的法律条文，然后向行政机关写投诉书或现场投诉（如上例向卫生局、环保局投诉），如果行政机关不处理就向其上级机关行政复议，以我个人的经历基本全部能解决，当然这需要一定的法律技巧。特别的，行政复议是法律规定的行政机关必须受理处理的程序，在这个程序中，行政机关必须提供做出行政行为或不作出行政行为的法律依据和证据，行政复议必须受理且必须制作复议决定书，那么你就可以审查复议决定书是否合法，以及其依据的事实和理由是否合法，这样你就不用自己去搜集证据。这整个过程没有任何费用，花的时间也是很有限的，而收益是巨大的，很有效。
2、关于车辆技术性能鉴定：依据法律规定，交警只有在需要收集证据的情况下才能扣押肇事车辆，而目前交警能提供的收集证据的最主要理由就是车辆技术性能鉴定，其实这是交警的借口，无非就是要扣车牟利，那么P民的策略也很简单，就是不出鉴定费，鉴定费这个东东可不像停车费，你不给就拿车很麻烦，交警一定会叫鉴定所先鉴定，因为这是法定的证据和程序，你不交鉴定费，交警也必须按法律规定的时限结案，所以在这点上，交警耗不起你，他是很怕你耍无赖的，像我的案例一样，交警看我难缠连要我交鉴定费的要求都不敢提。
如果每个车主都不交鉴定费（这其实真的很容易做到），那么交警就会内牛满面，你想想，如果车主不交钱，就只能按法律规定由交警承担，而交警会把招待、旅游、公车费压缩出来交给鉴定所去吗？不给的话，又有哪家鉴定所会与交警合作免费鉴定呢？而不鉴定，交警扣车的法定理由就消失了，所以，只要每个车主坚持不出鉴定费，很快，大家的车辆就不会被扣了，大家只要花很少的努力就可以有很大的收获，QS们要努力啊。
3、关于110：个人的实践总结，目前110是维权的一个强有力手段，如果你是合法权益一方，你应该不会惧怕110民警到场，而110的到场会为确定现场证据、控制事态恶化、威慑侵权一方等等起到决定性的作用，目前110接警必须出警的规定非常有利于合法权益方保护自己。当然110报警需要一些小技巧：1、适当严重化事件，这不是诬告陷害，只要事实存在，你对事实性质无论怎么理解和严重定义，都不是诬告陷害，是不负法律责任的；2、如果你确定希望民警到场，你就只需要坚持要求民警到场就行，不需要多说理由，就问你受不受理、出不出警、什么时间出警就行了，110是不敢不出警的。
对于没有明显暴力事件，110一般都会按纠纷调解，如果你对处理不满一定要坚持报案，去派出所做笔录，笔录的时候亦可以按你的理解以最严重的罪名报案，坚持按你说的记录（因为这是你的笔录，你说了算），不要轻信民警的引导和对你措辞的修改，否则不签名，民警是不敢不做笔录的，因为这是110处警的必要法律文件。不要怕做笔录会浪费时间，这与你今后维权自己收集证据相比是完全值得的。
4、关于停车费：法律有明确规定，只有你坚持，然后选择适合自己的策略和方式坚持自己的权益，交警是不敢向你开票收费的，而你真的没有义务向停车场缴费，因为你其实与停车场完全没有法律关系。特别重要的，如果没一个车主都不交停车费，那还有谁会免费为交警管理肇事违章车辆，你相信交警会从自己的经费里拿出钱来吗？如果没有停车费收入，每个停车场都要倒闭，那每个车主就都不会被扣车了，这实在是广大车主的最强福音啊。这会很难吗？
5、关于停车场：本案中停车场挂出的牌子是“赣州市肇事车辆违章车辆管理处”，这个牌子会吓倒很多P民，其实，单从名称上分析，我就可以下结论，这是一个三无的非法组织。1、名称中没有冠以“赣州市公安局交通警察支队”说明不是交警的下属单位，现场也没有一个穿正规警服配警号的人员，在派出所联系交警时，交警也明确承认停车场是完全社会化的；我们也不可能在行政事业机构编制中找到肇事车辆违章车辆管理处这个单位；那么它是社会团体或企业法人吗，单从名称上“管理处”这个名字就不可能登记为任何社会团体或企业法人；所以毫无疑问的“赣州市肇事车辆违章车辆管理处”只是一块吓唬人的野鸡牌子，没有这个单位也就不可能有营业执照，也就不可能有收费许可证，那么它收费就完全站不住脚。在整个过程中停车场根本没有悬挂、出示过营业执照和收费许可证，这就是本案中停车场会屈服的根本原因。
因为我没有交费所以不知道以前的朋友们缴费单是什么样的，上面盖的是什么单位的章，如果你现在还保留着单据，又想拿回这些钱的话，给您支个招：1、先看是什么单据，应该必须是行政事业性收费单，如果是FP（其实FP是不合法的，因为你与停车场不存在合同关系，停车场收钱属于不当得利，可以民事诉讼，当然那个更麻烦，就不多说了）必须加盖公章；如果是行政事业性收费单，可以去财政查询单据的真实性和时效性，如果是FP可以去税务查（没FP直接投诉）；个人直接下定论，这些票据如果不是假的也一定存在瑕疵（如过期、与收费项目不符、收付单位与登记单位不同，因为根本没有停车场这个单位等等），然后要求财政或税务查处；3、进一步的可以去派出所报案诈骗，这个可以成立的，因为对方捏造了一个不存在的单位（也就是伪造事实），在没有合法收费依据的情况下使用虚假的单据，骗取财物，这个涉案金额很大啊，很可怕啊。再吹下牛，如果是我，坚持报案和行政复议（如果派出所不立案的话），一定会成功。
你说如果这件事变刑事案件了，或者媒体把这些法律关系曝光了，别说停车场怕，交警也要尿裤子啊。
6、其他途径：至少，您可以向工商部门投诉非法经营。前面已经说了，以我的判断全国这类停车场90没有营业执照，100没有收费许可证或者收费项目不包含停车费，注意这里的停车费是指交警扣车发生的，不是自愿停车发生的。如果你耗不起车辆被扣时间，也可以在交费后，拿票据向工商投诉非法经营和强制交易（你与停车场没有合同关系），如果没有票据或票据有瑕疵还可以向税务投诉，很多投诉都只要打个电话不会很难。
第二篇 保险赔偿:事故责任认定复核 7月6日下午，交警通知我去拿事故责任认定书，交警以“对道路的交通动态注意不够，忽视安全”“违反《中华人民共和国道路交通安全法》第二十二条第一款”为由，认定我负次要责任，很是无语，中国法律中口袋罪很多，对执法者的限定很少，好在我有准备，写好复核申请，9号上午就交去支队事故科。事故科的人说会把受理通知和结果寄给我，正好要上山度假1个月，也就不去管它，期间木有任何关于交通事故的电话给我。
道路交通事故认定复核申请书
申请人：，男，19年月日生，住址：赣州市章贡区红旗大道**，身份证号：，电话：
被申请人：赣州市公安局交通警察支队直属大队，地址：赣州市东郊路，电话：8123138
第三人： 陈XX，女，19年月日生，住址：赣州市章贡区贸易广场西区* ，身份证号：，电话：
申请人因为不服赣州市公安局交通警察支队直属大队赣市公交直认字[2012]第272号《道路交通事故认定书》，申请复核。
复核请求
依法撤销赣州市公安局交通警察支队直属大队赣市公交直认字[2012]第272号《道路交通事故认定书》，对本起交通事故重新作出责任认定，认定申请人不承担本次事故的责任。
事实和理由
一、认定道路交通事故发生经过与事实不符 原认定书认定： “2012年6月14日7时55分左右，陈XX（对方）驾驶赣州A404XX号电动自行车（搭载叶X）沿厚德路由西向东行驶至厚德路小学门前路段时，在左转弯过程中，叶X左脚与相对方向直行由XXX（本人）驾驶的赣BHXXXX号轿车擦刮”。
申请人认为与事实不符：
1、从现场示意图可知，碰撞点位于厚德路小学路口西端以西10米外，距道路北侧边缘1.5米处，第三人左转横过机动车道后因送女儿叶X上学欲进入厚德路小学路口，故沿道路北侧向东逆行，并非如原认定书所述“在左转弯过程中”。碰撞点距道路边缘仅1.5米，而且是叶X反向骑乘，左脚伸出电动车尾部发生擦刮，而该电动车的长度已经超过1.5米，在这样的距离内，第三人不可能继续横过道路向道路边缘（道路北侧）运动，因而第三人必然已经改变运动方向，而从第三人送女儿上学的目的可以判定：第三人必然沿道路北侧向东逆行欲进入厚德路小学入口。
2、从“叶X左脚与相对方向直行由XXX驾驶的赣BHXXXX号轿车擦刮”的认定可知，叶X为反向骑乘，因为，如果叶X正向骑乘，双方车辆右侧碰撞只能伤及叶X右侧肢体，而叶X左脚受伤故为反向骑乘，由于叶X反向骑乘而第三人车辆后座有较大的靠背，致使叶X左脚不得不外伸，超出第三人车辆车把宽度与车尾，因而与申请人车辆擦刮。被申请人对如此重要的事实没有认定是严重失职。
二、认定交通事故成因错误 原认定书认定：“当事人XXX当日驾驶机动车行驶至学校门前路段时，对道路的交通动态注意不够，忽视安全”。
申请人认为是错误的：
1、被申请人没有任何证据证明申请人“对道路的交通动态注意不够，忽视安全”。</description>
    </item>
    
    <item>
      <title>数据库优化一点总结</title>
      <link>https://www.yuedun.wang/blogdetail/561677d7bfae4b590b7a4aaa/</link>
      <pubDate>Thu, 08 Oct 2015 14:04:07 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/561677d7bfae4b590b7a4aaa/</guid>
      <description>以前找工作的时候总被面试到数据库方面的知识，尤其是数据库优化。当然在去面试之前先补习一下，背一些网上的概念来应付。现在想想，要考察一个开发者数据库优化方面的知识只需要问一下有没有做过数据库设计和优化就行，如果做过相关工作那么多少会总结出来一些，如果没做过说出再多也是概念而已。
国庆节前韩豆咖派上线，然后这个节日就不会有好日子过了，上线三四天的时候很多用户反映帖子刷新不出来，登陆不了等问题，起初我以为是放假了大家回家网络不好导致的，后来测试了下接口花了一分多钟数据才返回，看来不是网络问题。查了下数据库帖子数量，居然达到6万了，想到以前背的概念，首先加索引试试，果然快了。但是节后数量达到12万的时候又出现了相同的问题，有点纳闷，索引页加了怎么还是慢呢？经过多次试验，分拆复杂查询后得出结论是由于查询语句中使用了left join自连接查询，通俗的说就是在12万数据中找出需要的数据，然后再在这12万中找出关联数据，光是这两个12万都够吓人了。最后还是把复杂的sql分解用程序控制查询子句，速度果然又提高了。
得出结论，一句复杂的sql不一定是最好的，分解成多句简单的sql可能有质的飞跃。这个方案在《高性能MYSQL》一书中也提到了，补充个图片：
但是对于sql查询到底该一次复杂查询还是多次简单查询没有明显界限，只有当一条复杂查询发现很慢的时候再分析慢的原因多次试验后就能知道哪个是最好的，而且复杂的sql也不利于优化，可能加了索引都没用，也不能使用查询缓存。当一条复杂的sql需要花3秒钟才能查出来的时候分拆的简单sql可能每秒可以查询5000次了.</description>
    </item>
    
    <item>
      <title>MySQL查询当天0点，昨天</title>
      <link>https://www.yuedun.wang/blogdetail/5608dbb10adc9cf12635ebbb/</link>
      <pubDate>Mon, 28 Sep 2015 06:18:25 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5608dbb10adc9cf12635ebbb/</guid>
      <description>今天是
SELECT NOW();-- 2015-09-28 13:48:12 查询当天，格式为YYYY-MM-DD
SELECT CURDATE();-- 2015-09-28
查询当天，格式为YYYY-MM-DD HH:mm:ss
SELECT NOW();-- 2015-09-28 13:42:00
查询当天0点，格式为YYYY-MM-DD HH:mm:ss
SELECT DATE_FORMAT(CURDATE(),&amp;quot;%Y-%m-%d %H:%i:%s&amp;quot;);-- 2015-09-28 00:00:00
查询当天早上9点，格式为YYYY-MM-DD HH:mm:ss
SELECT DATE_ADD(CURDATE(), INTERVAL 9 HOUR);-- 2015-09-28 09:00:00
查询昨天，格式为YYYY-MM-DD
SELECT DATE_SUB(CURDATE(),INTERVAL 1 DAY);-- 2015-09-27
查询昨天早上9点
SELECT DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 1 DAY),INTERVAL 9 HOUR);-- 2015-09-27 09:00:00
DATE_ADD(date,INTERVAL expr type) 参数是合法的日期表达式。expr 参数是您希望增加的时间。
type 参数可以是下列值：
Type 值
MICROSECOND
SECOND
MINUTE
HOUR
DAY
WEEK
MONTH
QUARTER
YEAR
SECOND_MICROSECOND
MINUTE_MICROSECOND
MINUTE_SECOND
HOUR_MICROSECOND
HOUR_SECOND
HOUR_MINUTE</description>
    </item>
    
    <item>
      <title>关于写博客的一些奇怪事情</title>
      <link>https://www.yuedun.wang/blogdetail/55fe24c7079f8670036cbeb6/</link>
      <pubDate>Sun, 20 Sep 2015 03:15:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55fe24c7079f8670036cbeb6/</guid>
      <description>我是做技术的，平时也有喜欢写写博客，但是由于自己作文水平有限，又比较懒，所以很少写大篇幅的内容，也很少为了写一篇文章而到处收集资料，毕竟不是专业写手，就是为了记录一下工作遇到的问题，虽然写的时候本着一颗能帮助他人的心，希望自己写的东西有助于其他人参考，但是通过平时查找资料的观察发现，有时在看别人文章的容总是很难读懂，或者写的不够详细，然后又找了很多资料后终于搞懂了。事后一想，还是自己写一篇更易懂的博客吧！
听说优秀的博客都要有配图
然后花了点时间把自己理解的整理出来，很有成就感的发表出去，可谁又能想到其实自己也可能重蹈覆辙，走了前人的路，在别人看来同样晦涩难懂。造成这种情况的原因其实与作者有关与读者也有关，作者不能全方位的表达出思想，读者又不能百分之百的理解作者的意图，然后就形成了后浪推前浪的补充风波，或许知识就是这样不断翻新传播的</description>
    </item>
    
    <item>
      <title>pm2在线监控</title>
      <link>https://www.yuedun.wang/blogdetail/55f2670ce893a5b0008e57fa/</link>
      <pubDate>Fri, 11 Sep 2015 05:30:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55f2670ce893a5b0008e57fa/</guid>
      <description>先来一张效果图：
](https://hopefully-img.yuedun.wang/172722906.png)
由图可以看出，监控内容有CPU，内存使用，系统bug，以及代码更新和重启服务，还有更多功能，比如bug邮件提醒功能。
使用方法很简单，几乎是一条命令搞定，首先打开https://app.keymetrics.io/#/ 注册登录以后应该可以看到下图命令提示，在服务器中执行第一条命令，需要带后面的machine name
可能会失败，多试几次就可以了。然后再web页面会自动出现服务器状况。</description>
    </item>
    
    <item>
      <title>总结一下最近数据库设计原则（待补充）</title>
      <link>https://www.yuedun.wang/blogdetail/55e91db7db5ac9c2be76b2fb/</link>
      <pubDate>Fri, 04 Sep 2015 04:27:35 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55e91db7db5ac9c2be76b2fb/</guid>
      <description>在没有做过数据库设计之前认为：数据库设计是表与表的关系设计，合理的表关系设计能使逻辑更易编写，不过这是以前肤浅的认知。后来逐渐开始参与公司数据库的设计才发现，单单是数据库表名，字段名也有一定学问，在最近的开发过程中感觉尤为突出。其中一些是历史遗留发现的，另外一些是新加表中发现的。
一、遗留问题主要体现在文档缺失上，基本所有表没有注释，字段更不用说，然后就对每个字段的作用搞不清楚，而且很多字段也不知道有没有用到，因为所有记录都没有值，但又不敢删。留着不管又影响性能，看着也不爽。
二、在新加表出现的问题是：新人喜欢模仿以前的表设计，也不管字段有没有用，有什么用，先都照搬过来，而且又喜欢添加一些新字段，说是为了预留以后新加功能的时候万一用到了，这就重蹈覆辙了，把字段加上了却又不喜欢写注释，然后导致后来连自己也不知道当初为什么加这个字段。
三、另外对于一些枚举字段，用了数字来表示不同类型，比如用1，2，3，4表示超级管理员，普通管理员，用户，小编，这种方式好处是占用字节少，但是坏处也不少，首先，从数值上看不出代表什么类型，需要看文档注释，要是连注释也没写那就坑了。
四、由于业务不断增加，表字段也不管添加，最后一张表中就会有好几十个字段，最后变得不好维护，而且有些字段是做的时候加上，最后又不用了，又没有及时删掉，然后就变成了垃圾字段。
以上几点问题是比较突出又影响开发的，我也总结出了对策：
1、表和字段一定要写注释
2、只添加需要用到的字段，千万不要加一些以后用到的字段，以后用到以后加
3、枚举字段在MySQL中建议使用enum枚举类型，在插入记录的时候使用单词来表明类型，在数据库保存的实际是数值索引
4、对于常用的字段放到一个表中，不常用的字段可以考虑分表存放，一对一关联，需要的时候查询即可
数据库引擎的使用：
就目前mysql的使用来说，大多数人在数据库引擎上会选择InnoDB，也总是有人建议这么做，主要目的是为了支持事务。但同样有人认为MyISAM读取性能比InnoDB强很多，会选择使用MyISAM。所以说具体选择哪种引擎类型依据业务实际情况决定。根据我们的项目实际使用情况，我最后选择了MyISAM作为数据库引擎。
前一个项目使用java开发，MySQL数据库InnoDB，确实也出现一些问题，在某次活动时200左右的并发量下不仅服务器宕机，连另一台数据库服务器在连接数暴增的情况下读取性能骤降，从而导致java服务器不能及时响应。这次开发语言选择了nodejs，经测试发现，可以支撑的并发量在2000多近3000的样子，所以就要求数据库能尽快读取数据，再加上目前业务中不要求事务，那么MyISAM就成了不二之选。</description>
    </item>
    
    <item>
      <title>使用nodemailer发送邮件</title>
      <link>https://www.yuedun.wang/blogdetail/55e518e0db5ac9c2be76b2fa/</link>
      <pubDate>Tue, 01 Sep 2015 03:17:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55e518e0db5ac9c2be76b2fa/</guid>
      <description>var nodemailer = require(&amp;#34;nodemailer&amp;#34;); var transporter = nodemailer.createTransport({ service: &amp;#34;gmail&amp;#34;, auth: { user: &amp;#34;youname@gmail.com&amp;#34;, pass: &amp;#34;password&amp;#34; } }); transporter.sendMail({ from: &amp;#34;youname@gmail.com&amp;#34;, to: &amp;#34;username@qq.com&amp;#34;, subject: &amp;#34;hello&amp;#34;, text: &amp;#34;hello world!&amp;#34; }); 这是一个最基本的邮件发送程序，邮件服务商有以下：
&amp;ldquo;1und1&amp;rdquo; &amp;ldquo;AOL&amp;rdquo; &amp;ldquo;DebugMail.io&amp;rdquo; &amp;ldquo;DynectEmail&amp;rdquo; &amp;ldquo;FastMail&amp;rdquo; &amp;ldquo;GandiMail&amp;rdquo; &amp;ldquo;Gmail&amp;rdquo; &amp;ldquo;Godaddy&amp;rdquo; &amp;ldquo;GodaddyAsia&amp;rdquo; &amp;ldquo;GodaddyEurope&amp;rdquo; &amp;ldquo;hot.ee&amp;rdquo; &amp;ldquo;Hotmail&amp;rdquo; &amp;ldquo;iCloud&amp;rdquo; &amp;ldquo;mail.ee&amp;rdquo; &amp;ldquo;Mail.ru&amp;rdquo; &amp;ldquo;Mailgun&amp;rdquo; &amp;ldquo;Mailjet&amp;rdquo; &amp;ldquo;Mandrill&amp;rdquo; &amp;ldquo;Naver&amp;rdquo; &amp;ldquo;Postmark&amp;rdquo; &amp;ldquo;QQ&amp;rdquo; &amp;ldquo;QQex&amp;rdquo; &amp;ldquo;SendCloud&amp;rdquo; &amp;ldquo;SendGrid&amp;rdquo; &amp;ldquo;SES&amp;rdquo; &amp;ldquo;Sparkpost&amp;rdquo; &amp;ldquo;Yahoo&amp;rdquo; &amp;ldquo;Yandex&amp;rdquo; &amp;ldquo;Zoho&amp;rdquo; </description>
    </item>
    
    <item>
      <title>一次简单的前端页面优化</title>
      <link>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</link>
      <pubDate>Mon, 31 Aug 2015 05:38:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</guid>
      <description>公司之前的产品管理对于小编们的使用情况及其糟糕，每次打开一个页面都要等待好久，这也是由于时间紧张，开始做的时候就只管进度没有时间优化。我大概看了下，光是登录页和一个空白首页就有78个请求，1.1M的数据。其他功能页面不少于这个数，这是因为所有页面共用了一个头文件，而这个头文件把所有有用没有的css文件和js文件都加载进来了，所以这次做的新后台管理系统绝不能这么做了。
首先，css按需加载，当然有一些css是每个页面必须的就放到一个公共页面中include进来，对于一些新增的插件就在需要的时候添加到对应的页面。
其次，js的加载方式也进行特别优化，一种方式是把js放在body结束标签之前，可以避免js的加载阻塞页面渲染，还有可以使用异步加载方式 defer是针对IE浏览器的，async是其他非IE内核浏览器异步加载属性。但是，我还是使用了requirejs来加载js，一方面是为了页面加载更快，另一方面是可以做到js模块化。
初步结果显示，所有页面加载速度平均在0.5秒，有些页面几乎看不出来重新加载过程，瞬间完成。优化也算是有一定的效果了。其中要说一下requirejs的一些优缺点，requirejs优点是可以实现js异步加载和模块化开发，不过让我有点不适应的是在HTML页面中不能使用onclick=func这种方式的事件处理，会提示找不到函数，只能在页面加载完成后用jquery进行事件监听，一些动态加载的页面数据也需要在加载以后重新绑定事件。
2015-11-08日更新
自从使用了requirejs后，凡是做页面需要js的时候首先想到的就是requirejs，感觉入坑跳不出来，反而弄巧成拙了。requirejs本意是异步加载多个js文件以防止页面阻塞，在一个网站或项目中也尽量合并多个文件里的内容以减少网络请求，一次加载一个大的文件比多次加载多个小文件来的划算的多，还有，requirejs虽然有好处但是并不是任何时候都有，比如页面很简单，js内容也很少的时候就完全不该用它。最后有一个不得不说的缺点，在上面已经提过，就是事件绑定，因为不能使用onclick=func()这种方式调用函数，只能用$(function(){})这种方式绑定事件，那么在网络不好的情况下，有些文件加载缓慢，导致不能绑定事件，如果一个按钮是这种方式绑定的事件，结果就是非要等到页面加载完才能点击，很让人着急。</description>
    </item>
    
    <item>
      <title>sequelizejs中where条件与order排序的使用</title>
      <link>https://www.yuedun.wang/blogdetail/55dfd3a4de3bc8b1ee4f7e45/</link>
      <pubDate>Fri, 28 Aug 2015 03:21:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55dfd3a4de3bc8b1ee4f7e45/</guid>
      <description>最基本的where条件：
Post.findAll({ where: { authorId: 2 } }); // SELECT \* FROM post WHERE authorId = 2 Post.findAll({ where: { authorId: 12, status: active } }); // SELECT \* FROM post WHERE authorId = 12 AND status = &amp;#39;active&amp;#39;; Post.destroy({ where: { status: &amp;#39;inactive&amp;#39; } }); // DELETE FROM post WHERE status = &amp;#39;inactive&amp;#39;; Post.update({ updatedAt: null, }, { where: { deletedAt: { $ne: null } } }); // UPDATE post SET updatedAt = null WHERE deletedAt NOT NULL; 如果涉及到or的使用，sequelize也提供了很好的解决方案</description>
    </item>
    
    <item>
      <title>微信开发通过公网访问本地服务器</title>
      <link>https://www.yuedun.wang/blogdetail/55ab0f6ed366f15412cbf596/</link>
      <pubDate>Sun, 19 Jul 2015 02:46:06 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55ab0f6ed366f15412cbf596/</guid>
      <description>做微信开发的时候，在开发者中心需要进行服务器配置，这里的配置是一个可以公网访问的地址，如果是产品上线的话肯定有公网地址，但是在开发过程中需要本地测试，总不能开发一点部署到服务器测试。这时候我们就需要从公网访问本地服务器。
这已经是设置好的，服务器端口是指公网地址的端口，就以80端口来好了，这样公网地址可以省略端口，内部服务器端口就是本地服务器端口，Java程序一般是8080这样的端口，IP地址就是本地服务器在局域网中的ip，协议选ALL，状态：生效。常用服务器端口可以不选。
然后启动本地服务器就可以通过路由器的公网IP访问本地服务了
但是我们不习惯使用IP地址访问，可以通过域名来访问，首先再到路由器中配置“动态DNS”： 当然，得先注册一个动态域名，登录成功之后就可以通过域名访问本地应用服务器了 </description>
    </item>
    
    <item>
      <title>前端工具gulp的用途和使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</link>
      <pubDate>Tue, 07 Jul 2015 13:38:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</guid>
      <description>在接触前端开始就听说过grunt和gulp是很叼的前端构建工具，但不知道到底有多叼，只是听说可以自动编译less，sass为css，目前还没有使用less和sass，所以也就没有尝试使用grunt和gulp。但是作为一个技术爱好者还是经不住诱惑，照着网上的教程简单使用了一下，总算是知道有什么用处了，因为都说gulp比grunt更简单好用，就以gulp的使用方法为例来说明一下。
文件合并：关于文件合并很多人存在这样的疑惑，在前端开发中到底该把所有js和css写在一个文件里还是各个页面分开写，我的建议是开发的时候分开写，上线的时候合并为一个，这样的好处是对于浏览器来说，不同页面中相同的文件默认会请求一次缓存下来，其他页面请求相同文件时就直接从缓存中读取，减少文件的网络请求可以提高网页速度，所以文件合并的是很有必要的。
2.文件压缩：既然都合并了，何不再压缩一下呢
3.语法检查：这个功能一般会和下面第4条功能配合使用，当文件修改的时候检查是否有语法错误，并在命令行中输出错误信息。
4.监听文件变化：监听某个目录下文件是否修改，修改的话就执行特定的操作，比如上面几个操作。 以上4点是比较常用的功能，更多功能根据自己需要添加
var gulp = require(&amp;#39;gulp&amp;#39;); var jshint = require(&amp;#39;gulp-jshint&amp;#39;);//语法检查 var concat = require(&amp;#39;gulp-concat&amp;#39;);//合并文件 var uglify = require(&amp;#39;gulp-uglify&amp;#39;);//压缩代码 var rename = require(&amp;#39;gulp-rename&amp;#39;);//重命名 // 语法检查 gulp.task(&amp;#39;jshint&amp;#39;, function () { return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(jshint()) .pipe(jshint.reporter(&amp;#39;default&amp;#39;)); }); // 合并文件之后压缩代码 gulp.task(&amp;#39;minify&amp;#39;, function (){ return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(concat(&amp;#39;all.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)) .pipe(uglify()) .pipe(rename(&amp;#39;all.min.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)); }); // 监视文件的变化 gulp.task(&amp;#39;watch&amp;#39;, function () { gulp.watch(&amp;#39;public/javascripts/*.js&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;]); }); // 注册缺省任务 gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;, &amp;#39;watch&amp;#39;]); // gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;]); 目录结构:</description>
    </item>
    
    <item>
      <title>年中总结</title>
      <link>https://www.yuedun.wang/blogdetail/559774527756526fccc59577/</link>
      <pubDate>Sat, 04 Jul 2015 05:51:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/559774527756526fccc59577/</guid>
      <description>三月的时候做了一个简单的计划，主要是在前端知识方面的学习，包括HTML5，CSS3，bootstrap,angularjs。到目前的四个月时间里工作内容基本包揽了所有前端任务开发，从不会到会，到熟练，对于我来说痛并快乐着，学习过程虽然艰难，但是如果让我每天重复一样的工作内容真的会很烦躁，而现在连做梦都会梦到遇到的技术难题，想到解决办法就迫不及待第二天上班去解决。这样一路下来，除了angularjs不太熟练其他都可以轻松胜任，这是不是离全栈更近一步了。
虽然angularjs这个坑挖的越来越深，下一个2.0版本也不向后兼容，让人纠结该不该继续学习，不过其实大家都对它的先进性认可的，暂时不会放弃。No这样的话前端技术暂时没有要学习的，接下来就是要学习服务器方面的东西，Linux操作系统，Nginx服务器使用，MySQL数据库优化，NoSQL公司暂时没有使用就先不深入学习了，不过好在公司的技术使用上有决策权，如有必要还是希望能用上，从上次活动服务器挂掉得出结论，MySQL不作特别优化处理是有点难以支撑高并发，有点与nodejs不搭调。
总体来说，这几个月成长不少，除了自己努力之外还要感谢公司提供了我能够充分发挥的环境和前辈同事的指导和老板的信任。——不论公司最后成败，付出的努力不会付之东流。</description>
    </item>
    
    <item>
      <title>旅行有什么意义？</title>
      <link>https://www.yuedun.wang/blogdetail/556a58ca4739f4caa5d24f88/</link>
      <pubDate>Sun, 31 May 2015 00:41:46 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/556a58ca4739f4caa5d24f88/</guid>
      <description>在网上到处都能看见诸如：“世界那么大，我想去看看”，“来一场说走就走的旅行”,“年轻人最值得去的N的地方”，“再不出发你就老了，年轻人”等等。不知道从什么时候开始出去旅游成了年轻人必干之事。给自己的理由是：“给心灵放个假”，“从不同角度去看看这个世界，在一个地方呆久了会被周围环境禁锢的”，“增加自己的眼界，开阔自己的胸襟”，“年轻时不去，老了就去不了了”，总能给自己找一个很充分的理由把自己都感动了。
但是我想站在一个反面的位置来说说旅行到对于很多人来说其实没什么意义： 首先是旅游是一件耗费时间和金钱的事，没有充裕的时间和金钱想要去旅行着实困难，也有人说可以穷游，是啊，当然可以，不过如果你没有做好风餐露宿，忍饥挨饿，跑断腿的心理准备就暂且打消这个念头，否则就准备好帐篷睡袋睡桥洞下吧，一个月后回来连亲妈都不认识你了。在时间上来说，除非你放下工作，不然只有周末的时间是没法去远处旅行的，如果只是在周围的小圈子里转还能算旅行吗？所以我说的旅行是指去有着不同文化的地域和国家。
其次是旅游是否具有放松心情的功能，说旅游是为了暂时抛开工作去放松一下，可是如果工作上还有很多事需要做，还能好好旅行吗？如果你的工作很轻松，那么还真该去旅游，因为你太闲了，你的工作太乏味太无聊了，只能用旅游去打发时间，我觉得就算是有钱的老板也不可能不关心工作而只想着去哪旅行的。不过事实确实是只有工作轻松无聊的人旅行的比较多吧！对于普通人来说旅游应该是有目的的，比如工作太累，心情不好，这时一次旅游可以分散注意力，改变心情。如果纯粹是为了旅游而旅游，那么这能得到什么？只不过是去别的地方消费而已。在国内出去旅行看到最多的还是人。
我开始怀疑那些年轻人该出去旅游的话是出自何人之口？是年轻人本身吗？你凭什么说年轻时候该出去旅行而不是踏实的工作学习，多读几本书！你确定旅行能长见识而不会影响工作学习？又不是什么作家诗人画家的需要出去找灵感，如果是靠旅行来增加工作激情，那么只能说你还不适合工作或者这份工作不适合你。是老一辈人说的？那他有没有说他自己因为旅行获得什么益处，可能是他后悔年轻时没有旅行，那么你的父母爷爷辈的有没有经常教导你说:年轻人不要光埋头工作，要经常出去玩玩，到处走走，增长点见识，免得老了和我一样后悔。那么话说回来，为什么是年轻的时候该出去旅行呢？有这么几种解释:年轻的时候有时间，没有家庭负担，增加阅历。说的好有道理，谁能不服，所以就有很多人都这么说这么做了。那么我想问，你旅行的次数和回家看父母的次数哪个多，一年全国各地，甚至满世界的跑，有没有回家看过？你说年轻时没有家庭负担，有没有想过还有父母呢，怎么不带他们也去玩，他们年轻时可能为了你而没时间去玩，现在你有时间金钱去玩怎么不带上他们！
我倒是为了写这篇文章搜索了下关于旅行的内容，鼓励出去玩的大多是旅行社，旅游网站发的，个人发的却又没说旅行能获得多少好处，他也不反对旅行，让你自己体会去，当你体会了以后别人问的时候是不是也用同样的话去回答？这样旅行的结果是多了谈资，晒照片去了哪哪哪，吃了什么美食，一大把各地门票，出国签证，还有账单。旅游真有那么多好处你倒是这个总结让大家也学习学习，不要只让我自己体会。
旅游有时候确实可以改变一些事，只不过很多人被网络上的话给洗脑了，盲目跟风。读万卷书，行万里路，没有读万卷书，只行万里路一样是无知。世界那么大，宇宙那么浩瀚，人生只不多短短的几十年怎么可能了解全部，想要自己人生有意义最好的办法应该是让今天比昨天更好。</description>
    </item>
    
    <item>
      <title>高级运营与初级运营【图】</title>
      <link>https://www.yuedun.wang/blogdetail/5567d4328b7f4aa8a0d1d3f4/</link>
      <pubDate>Fri, 29 May 2015 02:51:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5567d4328b7f4aa8a0d1d3f4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>腾旭内部价值千万的24张产品策略PPT【图】</title>
      <link>https://www.yuedun.wang/blogdetail/5567d3f08b7f4aa8a0d1d3f3/</link>
      <pubDate>Fri, 29 May 2015 02:50:24 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5567d3f08b7f4aa8a0d1d3f3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>马化腾：如何打造中国最牛逼的产品【图】</title>
      <link>https://www.yuedun.wang/blogdetail/5567d3ab8b7f4aa8a0d1d3f2/</link>
      <pubDate>Fri, 29 May 2015 02:49:15 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5567d3ab8b7f4aa8a0d1d3f2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>朋友圈微商语录【图】</title>
      <link>https://www.yuedun.wang/blogdetail/5567d3688b7f4aa8a0d1d3f1/</link>
      <pubDate>Fri, 29 May 2015 02:48:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5567d3688b7f4aa8a0d1d3f1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>你连故事都不会讲，谈什么营销【图】</title>
      <link>https://www.yuedun.wang/blogdetail/5567d2d68b7f4aa8a0d1d3f0/</link>
      <pubDate>Fri, 29 May 2015 02:45:42 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5567d2d68b7f4aa8a0d1d3f0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>互联网产品体验分析</title>
      <link>https://www.yuedun.wang/blogdetail/555feb54576fa2560c02302e/</link>
      <pubDate>Sat, 23 May 2015 02:52:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/555feb54576fa2560c02302e/</guid>
      <description>在寫產品體驗報告的時候，經常會陷入這樣的一個困境，即把體驗報告寫成了這個產品的說明書或者營銷文案，幾乎把這個產品的所有功能又複述了一遍，重點不突出。在網上看了不少的體驗報告，基本也都陷入了這樣的一個怪圈。很多人一上來就很宏大地開始架構諸如『產品定位』、『戰略發展』、『市場狀況』、『商業模式』、『產品結構』等字眼。
關於這樣的分析方法有不少問題。一方面是缺少足夠的信息來源。比如『商業模式』的決定是需要有不少的信息輸入作為參考的，而你又並非這個公司的人，憑著在網上搜刮的一點資料難道就可以做出決定嗎？另一方面時，研究一個產品的重心應該放在哪個方面？面面俱到的分析方法必然會失去重心。
對於這個問題，我自己的結論是：分析一個產品無需宏大整體的架構，只需要把自己當成用戶，問自己幾個問題即可。
這幾個問題是：
你會繼續使用這個產品嗎？（ 第一關，該產品是否能繼續在該用戶的手機上存在。） 你會使用它的什麼功能？（ 該產品給用戶提供了什麼價值。） 如果跟XX 擺在一起， 你會選擇哪一個？（ 該產品的差異化優勢） 為什麼選擇這樣幾個問題而非宏觀地進行分析呢？這個問題可以從我們最近流行起來的幾個App看出端倪。無論是足跡和臉萌，都有一個很重要的特點，即它們的某一個功能很明顯地比其它功能要突出很多，甚至其它功能都不被用戶意識到，但是就這麼一個功能，就能使它們成為一個好的產品。也就是說，用戶在感知一個產品的時候，並不會去感知這個產品的整體，而只會關注一個問題：這個產品能幫助我什麼？如果這個產品的這個功能能夠為我帶來價值，就算其它功能都是雞肋，那留著也就留著吧，我不關心。
大多數玩微信的人不玩遊戲，也不關心『我的錢包』裡面豐富的服務，但不妨礙他們成為微信的重度用戶。
由此我們得出一個什麼結論呢？結論是：一個好產品可能并不遵守木桶理論，只要最長的那根木板足夠長，這個產品就足夠好。因此，當我們去分析一個產品的時候，我們應該分析這個產品的關鍵驅動因素是什麼？它最亮的那個亮點是什麼？它亮到什麼程度以至於我決定把這個產品給收下來而不是長按刪除。不要再寫那些長長的貌似很系統的分析報告了吧，我相信微信里的很多頁面你從沒進去過。
内容摘自知乎：http://www.zhihu.com/question/19851117</description>
    </item>
    
    <item>
      <title>redis启动失败</title>
      <link>https://www.yuedun.wang/blogdetail/554aff409ddef487a8b23409/</link>
      <pubDate>Thu, 07 May 2015 05:59:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/554aff409ddef487a8b23409/</guid>
      <description>redis-server.exe redis.windows.conf 使用上面命令启动redis服务的时候报了以下错误信息： The Windows version of Redis allocates a memory mapped heap for sharing with the forked process used for persistence operations. In order to share this memory, Windows allocates from the system paging file a portion equal to the size of the Redis heap. At this time there is insufficient contiguous free space available in the system paging file for this operation (Windows error 0x5AF). To work around this you may either increase the size of the system paging file, or decrease the size of the Redis heap with the &amp;ndash;maxheap flag.</description>
    </item>
    
    <item>
      <title>sequelize定义实体对象</title>
      <link>https://www.yuedun.wang/blogdetail/554ae5b3a07843eb8002a388/</link>
      <pubDate>Thu, 07 May 2015 04:10:27 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/554ae5b3a07843eb8002a388/</guid>
      <description>sequelize定义实体对象
var sequelize = require(&amp;#34;../utils/sequelizeDB&amp;#34;);//连接数据库 var Sequelize = require(&amp;#34;sequelize&amp;#34;); var User = sequelize.define(&amp;#34;User&amp;#34;, { user_id:{ type: Sequelize.STRING, primaryKey: true}, name: Sequelize.STRING, phone: Sequelize.STRING, create_date: Sequelize.DATE, update_date: Sequelize.DATE }, { freezeTableName: true, // 默认false修改表名为复数，true不修改表名，与数据库表名同步 tableName: &amp;#34;user&amp;#34;, timestamps: false }); define函数的第一个参数’User’就是定义一个实体对象，名称不必与数据库表名一致，只是为了确定该对象没有重复 { type: Sequelize.STRING, primaryKey: true}将属性作为主键 freezeTableName禁用修改表名;默认情况下,sequelize会自动将模型名称(第一个参数定义‘User’)为复数。值为ture时不修改 tableName数据库表名 timestamps是否自动添加时间戳createAt，updateAt</description>
    </item>
    
    <item>
      <title> mysql一个字段为空时使用另一个字段排序</title>
      <link>https://www.yuedun.wang/blogdetail/5534d242cf68fa0beaf71cb9/</link>
      <pubDate>Mon, 20 Apr 2015 10:17:38 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5534d242cf68fa0beaf71cb9/</guid>
      <description>表中有两个日期字段createDate，updateDate。其中updateDate可以为空，要求使用updateDate排序，如果updateDate为空则使用createDate排序，结果要顺序排下来。
按照常规方法：
select * from table order by updateDate desc;
这样的结果是为空的数据排在了最下面，不符合要求。
这样试试：
select * from table order by updateDate desc, createDate desc;
这样排的结果是先按updateDate排序，updateDate为空的排在最下面，然后按createDate排序，这样也不符合要求。
正确方法：
select * from table order by IFNULL(updateDate, createDate) desc;
这种排序的结果是正确的，用ifnull函数判断updateDate如果为空的话就使用createDate排。</description>
    </item>
    
    <item>
      <title>2015年计划</title>
      <link>https://www.yuedun.wang/blogdetail/54fbdd9ed6135b272abc05b7/</link>
      <pubDate>Sun, 08 Mar 2015 05:26:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54fbdd9ed6135b272abc05b7/</guid>
      <description>去年底换了工作就没时间更新博客了，新公司中叶使用了新技术，不过自身也欠缺太多，html,css只知皮毛,需要加强学习。bootstrap也是一个快速开发的css框架，但还是要把基础的css学会了才能更快的掌握。公司打算把app从原生转型到html5开发，那么HTML5也是必学的，然后还有angularjs感觉也不错，怎么能不会！</description>
    </item>
    
    <item>
      <title>node.js作为微信接口服务器</title>
      <link>https://www.yuedun.wang/blogdetail/5479b18a93ae2eb85f26b2d3/</link>
      <pubDate>Sat, 29 Nov 2014 11:44:10 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5479b18a93ae2eb85f26b2d3/</guid>
      <description>前端时间用node改写了下去年用Java练习时写的微信接口，可能是因为微信接口看的多了更加熟悉了，也可能是node开发更快速，反正不到一小时就搞定了微信token的验证，放到博客项目中，新增了一个URL请求，在微信公众平台上测试了下，没想到调试两三次就通过了，想当初用Java测试时各种问题不断。想起来可惜的是去年Java版的微信接口做的自定义菜单，自动回复等功能，由于BAE收费的缘故就废掉了。
/** * Created by huopanpan on 2014/10/10. */ var crypto = require(&amp;#34;crypto&amp;#34;); /** * 验证token * @param req * @param res */ function validateToken(req, res) { var query = req.query; var signature = query.signature;//微信服务器加密字符串 var echostr = query.echostr;//随机字符串 var timestamp = query[&amp;#34;timestamp&amp;#34;];//时间戳 var nonce = query.nonce;//nonce var oriArray = new Array(); oriArray[0] = nonce; oriArray[1] = timestamp; oriArray[2] = &amp;#34;hale&amp;#34;;//token oriArray.sort(); var original = oriArray[0]+oriArray[1]+oriArray[2]; console.log(&amp;#34;Original Str:&amp;#34;+original); console.log(&amp;#34;signature:&amp;#34;+signature); var scyptoString = sha1(original);//将三个参数拼接加密字符串，并与服务器发送的字符串对比 if (signature == scyptoString) { res.</description>
    </item>
    
    <item>
      <title>mongodb启动服务失败的解决办法之一</title>
      <link>https://www.yuedun.wang/blogdetail/54681e1ee8183bcf964f88ec/</link>
      <pubDate>Sun, 16 Nov 2014 03:46:38 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54681e1ee8183bcf964f88ec/</guid>
      <description>在执行下面第一行启动mongodb服务的时候，命令行一闪而过，具体看了下输出内容看不出端倪来，不过解决办法却是有的，就是直接删除掉D:\Data\db下面的mongod.lock文件可以了
C:\Program Files\MongoDB 2.6 Standard\bin&amp;gt;mongod &amp;ndash;dbpath=D:\Data\db
2014-11-16T11:35:43.244+0800
2014-11-16T11:35:43.252+0800 warning: 32-bit servers don&amp;quot;t have journaling enabl
ed by default. Please use &amp;ndash;journal if you want durability.
2014-11-16T11:35:43.253+0800
2014-11-16T11:35:43.282+0800 [initandlisten] MongoDB starting : pid=8272 port=27
017 dbpath=D:\Data\db 32-bit host=hp
2014-11-16T11:35:43.283+0800 [initandlisten]
2014-11-16T11:35:43.284+0800 [initandlisten] ** NOTE: This is a 32 bit MongoDB b
inary.
2014-11-16T11:35:43.284+0800 [initandlisten] ** 32 bit builds are limited
to less than 2GB of data (or less with &amp;ndash;journal).
2014-11-16T11:35:43.284+0800 [initandlisten] ** Note that journaling defau</description>
    </item>
    
    <item>
      <title>搞懂了七牛文件存储</title>
      <link>https://www.yuedun.wang/blogdetail/54662bf3e8183bcf964f88eb/</link>
      <pubDate>Fri, 14 Nov 2014 16:21:07 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54662bf3e8183bcf964f88eb/</guid>
      <description>由于工作没时间，博客搭建起来以后一直没有添加文件上传功能，瞬间感觉不完美了。这两天外包项目结束，要出项目组，在交接工作之余，用中午休息时间写好了文件上传功能，具体是图片上传。在本地测试好发布到BAE上，居然没法上传了，初步推断应该是服务器没有写权限，原来一直想试试百度云存储来做图片存储，但是翻看了文档发现暂不支持node.js上传，只能先上传好再引用链接，感觉好麻烦。 由于一直在node中文社区混，发现用的是七牛存储，也想跟着大牛的步伐去试试，对开发文档进行两轮战斗，愣是没看懂，今天没事干，就从头到尾认认真真看了一遍，动手写了个测试程序，可以上传，激动万分，真想分享出来，但是测试程序还不完善，还没有把回调搞定，也没有完整的例子拿出来给大家看，等完全搞定了以后再写个教程卖弄一下。 </description>
    </item>
    
    <item>
      <title>oracle decode和nvl的用法</title>
      <link>https://www.yuedun.wang/blogdetail/5459dcd3bf93a1aa252561fe/</link>
      <pubDate>Wed, 05 Nov 2014 08:16:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5459dcd3bf93a1aa252561fe/</guid>
      <description>Oracle 中 decode 函数用法
含义解释： decode(条件,值1,返回值1,值2,返回值2,&amp;hellip;值n,返回值n,缺省值)
该函数的含义如下：
IF 条件=值1 THEN RETURN(翻译值1) ELSIF 条件=值2 THEN RETURN(翻译值2) ...... ELSIF 条件=值n THEN RETURN(翻译值n) ELSE RETURN(缺省值) END IF decode(字段或字段的运算，值1，值2，值3）
这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3 当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多
使用方法： 1、比较大小 select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值 sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1 例如： 变量1=10，变量2=20 则sign(变量1-变量2)返回-1，decode解码结果为“变量1”，达到了取较小值的目的。
2、此函数用在SQL语句中，功能介绍如下：
Decode函数与一系列嵌套的 IF-THEN-ELSE语句相似。base_exp与compare1,compare2等等依次进行比较。如果base_exp和 第i 个compare项匹配，就返回第i 个对应的value 。如果base_exp与任何的compare值都不匹配，则返回default。每个compare值顺次求值，如果发现一个匹配，则剩下的compare值（如果还有的话）就都不再求值。一个为NULL的base_exp被认为和NULL compare值等价。如果需要的话，每一个compare值都被转换成和第一个compare 值相同的数据类型，这个数据类型也是返回值的类型。
Decode函数在实际开发中非常的有用
结合Lpad函数，如何使主键的值自动加1并在前面补0 select LPAD(decode(count(记录编号),0,1,max(to_number(记录编号)+1)),14,&#39;0&#39;) 记录编号 from tetdmis
eg: select decode(dir,1,0,1) from a1_interval dir 的值是1变为0，是0则变为1
比如我要查询某班男生和女生的数量分别是多少?
通常我们这么写:
select count(*) from 表 where 性别 ＝ 男； select count(*) from 表 where 性别 ＝ 女； 要想显示到一起还要union一下，太麻烦了</description>
    </item>
    
    <item>
      <title>考虑学习前端开发</title>
      <link>https://www.yuedun.wang/blogdetail/54525a36d477ceeba7b15d6b/</link>
      <pubDate>Thu, 30 Oct 2014 15:33:10 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54525a36d477ceeba7b15d6b/</guid>
      <description>从开始学习nodejs就关注了前端方面的技术，主要就是HTML，css，现在还真有想法深入学习一下。以前一直从事着后端开发，到现在已有三年，但是感觉自己遇到了一下瓶颈，虽然在工作中没什么难倒的技术问题，但是做着重复的工作实在是没有提升。之前的公司没有值的学习的东西，现在的公司有东西可以学习，但是作为外包可能不会待太长时间，就现在来说，也没有做过核心的东西，所以感觉自己这样下去没有什么竞争力，于是决定从宽度上拓展，下决心学习了nodejs,当初为了学习不知不觉就建立了这个博客，由于没有前端功底，就照搬了一个模板，想要修改点样式却发现很吃力，再看看nodejs,就像是给前端开发的服务端语言，而我却不懂前端，就算学习了好像也派不上用场，好尴尬的存在啊，没办法，还是该学习一下前端知识，至少要能够轻松的修改一个已有的页面吧，要纯粹的搞设计估计还要重新来过，又要花个三五年时间，还是划不来，不过应该主攻后端，兼顾前端，前后通吃。那么我想就从HTML5，CSS3开始吧。
对于这些发点牢骚的内容就想在新浪博客上有个备份，复制一遍感觉好麻烦，新浪博客提供了对外接口，周末的时候看能不能对接一下</description>
    </item>
    
    <item>
      <title>Nodejs核心常用工具</title>
      <link>https://www.yuedun.wang/blogdetail/5451f72e0eb53ef723e47bfe/</link>
      <pubDate>Thu, 30 Oct 2014 08:30:38 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5451f72e0eb53ef723e47bfe/</guid>
      <description>内容摘自《nodejs开发指南》
util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能
过于精简的不足。
util.inherits
util.inherits(constructor, superConstructor)是一个实现对象间原型继承
的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有
提供对象继承的语言级别特性， 而是通过原型复制来实现的， 具体细节我们在附录A中讨论，
在这里我们只介绍 util.inherits 的用法，示例如下：
var util = require(&amp;#34;util&amp;#34;); function Base() { this.name = &amp;#34;base&amp;#34;; this.base = 1991; this.sayHello = function() { console.log(&amp;#34;Hello &amp;#34; + this.name); }; } Base.prototype.showName = function() { console.log(this.name); }; function Sub() { this.name = &amp;#34;sub&amp;#34;; } util.inherits(Sub, Base); var objBase = new Base(); objBase.showName(); objBase.sayHello(); console.log(objBase); var objSub = new Sub(); objSub.</description>
    </item>
    
    <item>
      <title>BAE上连接mongodb每隔十多小时就不能连接的问题(二)</title>
      <link>https://www.yuedun.wang/blogdetail/5449dac894f76294f5e60fe1/</link>
      <pubDate>Fri, 24 Oct 2014 04:51:20 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5449dac894f76294f5e60fe1/</guid>
      <description>前段时间写了《BAE上连接mongodb每隔十多小时就不能连接的问题(一)》之后暂时的解决了连不上的问题，每隔十小时重启一次，但是这个方法却没有彻底解决问题，偶尔还会出现三四小时就连不上，实在搞不懂问题到底出在哪，到底是bae的mongodb的问题还是mongoose中间件的问题，现象是有做open操作，但是却没有open事件发出，那么我想是不是mongoose存在bug，翻看了源码也没看出来个所以然，不过大概是觉得要重新打开需要保证连接已经关闭的，那么干脆在监听到error事件时就将状态直接改为disconnected，反正是要调用db.close()方法进行关闭连接的，可能close()方法不好使，没有完全关闭，如果我手动将状态设为disconnected，close方法中也会判断是否是这个状态，如果是就直接返回，省的多走其他步骤了。不过这样一来就不会有close事件发出了，根据我所写代码的逻辑，那就不会调用open()方法了，但实际情况确实程序可以正常运行，说明已经重连上了，原来在代码中添加了这个属性：
Js代码 :
var opts = { db: { native_parser: true }, server: { poolSize:4, auto_reconnect: true }, user: username, pass: password }; 上面的红色字体，只能说是可能这个参数起作用了。
不过由此看来，auto_reconect这个参数要起作用必须是在连接断开的情况下，说明close()方法有时候并没有完全断开连接。</description>
    </item>
    
    <item>
      <title>让你的Node.js应用跑得更快的10个技巧</title>
      <link>https://www.yuedun.wang/blogdetail/54488218aedc6cf109b96d32/</link>
      <pubDate>Thu, 23 Oct 2014 04:20:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54488218aedc6cf109b96d32/</guid>
      <description>Node.js 受益于它的事件驱动和异步的特征，所以已经很快了。但是，在现代网络中只是快是不行的。如果你打算用 Node.js 开发你的下一个Web应用的话，那么你就应该无所不用，让你的应用更快，异常的快。本文将介绍10条经过检验得知可大大提高Node速度的应用技巧。废话不多说，让我们逐条来看看。
**1.**并行
创建 Web 应用的时候，你可能要多次调用内部 API 来获取各种数据。比如说，假设在 Dashboard 页面上，你要执行下面这几个调用：
用户信息 -getUserProfile(). 当前活动 -getRecentActivity(). 订阅内容 -getSubscriptions(). 通知内容 -getNotifications(). 为了拿到这些信息，你应该会为每个方法创建独立的中间件，然后将它们链接到 Dashboard 路由上。不过问题是，这些方法的执行是线性的，上一个没结束之前下一个不会开始。可行解决案是并行调用它们。
如你所知由于异步性，Node.js 非常擅长并行调用多个方法。我们不能暴殄天物。我上面提到的那些方法没有依赖性，所以我们可以并行执行它们。这样我们可以削减中间件数量，大幅提高速度。
我们可以用 async.js 来处理并行，它是一个专门用来调教 JavaScript 异步的 Node 模块。下面代码演示怎样用 async.js 并行调用多个方法的：
如果你想更深入了解 async.js ，请移步它的 GitHub 页面。
2. 异步
根据设计 Node.js 是单线程的。基于这点，同步代码会堵塞整个应用。比如说，多数的文件系统 API 都有它们的同步版本。下面代码演示了文件读取的同步和异步两种操作:
不过要是你执行那种长时间的阻塞操作，主线程就会被阻塞到这些操作完成为止。这大大降低你应用的性能。所以，最好确保你的代码里用的都是异步版本 API，最起码你应该在性能节点异步。而且，你在选用第三方模块的时候也要很小心。因为当你想方设法把同步操作从你代码中剔除之后，一个外部库的同步调用会让你前功尽弃，降低你的应用性能。
3. 缓存
如果你用到一些不经常变化的数据，你应该把它们缓存起来，改善性能。比如说，下面的代码是获取最新帖子并显示的例子:
如果你不经常发贴的话，你可以把帖子列表缓存起来，然后一段时间之后再把它们清理掉。比如，我们可以用 Redis 模块来达到这个目的。当然，你必须在你的服务器上装 Redis。然后你可以用叫做 node_redis 的客户端来保存键/值对。下面的例子演示我们怎么缓存帖子：
看到了吧，我们首先检查 Redis 缓存，看看是否有帖子。如果有，我们从缓存中拿这些帖子列表。否则我们就检索数据库内容，然后把结果缓存。此外，一定时间之后，我们可以清理 Redis 缓存，这样就可以更新内容了。
4. gzip 压缩
开启 gzip 压缩对你的 Web 应用会产生巨大影响。当一个 gzip 压缩浏览器请求某些资源的时候，服务器会在响应返回给浏览器之前进行压缩。如果你不用 gzip 压缩你的静态资源，浏览器拿到它们可能会花费更长时间。</description>
    </item>
    
    <item>
      <title>git常用命令</title>
      <link>https://www.yuedun.wang/blogdetail/54486c117b1470fa64bb911a/</link>
      <pubDate>Thu, 23 Oct 2014 02:46:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/54486c117b1470fa64bb911a/</guid>
      <description>查看、添加、提交、删除、找回，重置修改文件
git help # 显示command的help
git show # 显示某次提交的内容 git show $id
git co &amp;ndash; # 抛弃工作区修改
git co . # 抛弃工作区修改
git add # 将工作文件修改提交到本地暂存区
git add . # 将所有修改过的工作文件提交暂存区
git rm # 从版本库中删除文件
git rm &amp;ndash;cached # 从版本库中删除文件，但不删除文件
git reset # 从暂存区恢复到工作文件
git reset &amp;ndash; . # 从暂存区恢复到工作文件
git reset &amp;ndash;hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　git ci -am &amp;ldquo;some comments&amp;rdquo;</description>
    </item>
    
    <item>
      <title>mongoose实现翻页</title>
      <link>https://www.yuedun.wang/blogdetail/5440a294fea3dae97beee4f9/</link>
      <pubDate>Fri, 17 Oct 2014 05:01:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5440a294fea3dae97beee4f9/</guid>
      <description>随着吐槽的内容越来越多，单页显示就显得不够文雅了，分页功能是一个完整系统必备的。所以就决定加上这个功能，不过分页实现起来并不容易，找了下前辈们的资料，感觉都很复杂，所以还是实现一个简单翻页好了，就是只有上一页，下一页这样简单的功能。
首先看下mongoose API，find方法源码：
Model.find = function find (conditions, fields, options, callback){ if(&amp;#34;function&amp;#34;==typeof conditions){ callback = conditions; conditions ={}; fields = null; options = null; }elseif(&amp;#34;function&amp;#34;==typeof fields){ callback = fields; fields = null; options = null; }elseif(&amp;#34;function&amp;#34;==typeof options){ callback = options; options = null; } // get the raw mongodb collection object var mq =newQuery({}, options,this,this.collection); mq.select(fields); if(this.schema.discriminatorMapping &amp;amp;amp;&amp;amp;amp; mq._selectedInclusively()){ mq.select(this.schema.options.discriminatorKey); } return mq.find(conditions, callback); }; 其中有4个参数，find(条件，需要查询的字段，选项，回调)，这样看着太抽象，来一段实际应用的代码：
router.get(&amp;#34;/admin/blogList&amp;#34;, function(req, res) { var user = req.</description>
    </item>
    
    <item>
      <title>NodeJs中的express框架获取http参数  </title>
      <link>https://www.yuedun.wang/blogdetail/543fdff0bba99b9e56a705d1/</link>
      <pubDate>Thu, 16 Oct 2014 15:10:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/543fdff0bba99b9e56a705d1/</guid>
      <description>express获取参数有三种方法：官网介绍如下
hecks route params (req.params), ex: /user/:id
Checks query string params (req.query), ex: ?id=12
Checks urlencoded body params (req.body), ex: id=12
1、例如：127.0.0.1:3000/index，这种情况下，我们为了得到index，我们可以通过使用req.params得到，通过这种方法我们就可以很好的处理Node中的路由处理问题，同时利用这点可以非常方便的实现MVC模式；
2、例如：127.0.0.1:3000/index?id=12，这种情况下，这种方式是获取客户端get方式传递过来的值，通过使用req.query.id就可以获得，类似于PHP的get方法；
3、例如：127.0.0.1：300/index，然后post了一个id=2的值，这种方式是获取客户端post过来的数据，可以通过req.body.id获取，类似于PHP的post方法；
下面举例介绍下这三个方法：
如下一个test.html代码
&amp;lt;form action=&amp;#34;/index&amp;#34; method=&amp;#34;get&amp;#34;&amp;gt; &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;login_name&amp;#34; /&amp;gt; &amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;Sign In&amp;#34; /&amp;gt; &amp;lt;/form&amp;gt; 在nodeJs中我们要自定义HTTP，因此创建index.js
app.post(&amp;#39;/:key&amp;#39;, function(req, res) { console.log(req.params.key); //输出index console.log(req.body.login_name); //输出表单post提交的login_name res.send(&amp;#39;great you are right for post method!&amp;#39;); //显示页面文字信息 }); app.listen(3000); 转自：http://handyxuefeng.blog.163.com/blog/static/454521722012921287791</description>
    </item>
    
    <item>
      <title>程序员如何留住健康？</title>
      <link>https://www.yuedun.wang/blogdetail/5437a390da1b84aa1c59d99c/</link>
      <pubDate>Fri, 10 Oct 2014 09:14:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5437a390da1b84aa1c59d99c/</guid>
      <description>相信大家已经注意到了，程序员的大部分时间都花在电脑桌前编程，这会损害程序员的健康。其实不需要多么复杂的养生，你只需每天做一些小小的改变，就可以摆脱病痛、保持健康。
变换姿势
虽然站立桌、昂贵的椅子和一些基于人体工程学的玩意的确很酷，哪怕 LINUS（linux 创始人）都在踏步机前工作，而事实上你并不需要这些。
关键是要变换姿势，如果你保持一个姿势数个小时不活动，你的脖子在数天后疼痛是必然的。每 15 分钟站起、坐下、跳、蹲下、活动一下手脚、放松一下眼睛；每小时变换一下姿势；每天走一走，爬一些楼梯，保证你的健康会得到很大的改善，关节的僵硬和肌肉 的疼痛都会得到缓解。
我个人拥有一个电动站立式办公桌， 每个小时我都变换一下姿势。而且我运行一个程序来提醒我每 15 分钟做一个小休息，每个小时做时间较长的休息。对于苹果X操作系统而言，有个“Time out”应用非常好，在 windows 上，我一般采用“Big Stretch Reminder”。
锻炼
锻炼是改善健康最好的方法之一，但是必须用正确的方法锻炼。首先要确保不要在无用的事情上浪费时间。
不要跑步
跑步被广泛当作一种锻炼方式，其实并不适用于所有人。在决定通过跑步来锻炼以前，你需要确认两件事情：1 你的身体状态足以满足跑步锻炼所需，一个严酷的事实是大部分程序员达不到跑步锻炼所需的身体条件。（译者注：对胖程序猿来说，跑步极有可能会损伤膝关 节）2 跑步锻炼需要掌握正确的跑步姿势和跑步方法。
我曾经常跟随在街道跑步的人们，紧跟他们的步伐和僵硬的背部（译者注：作者可能指一部分跑步的人姿势不对，背部僵硬），不正确的跑步姿势极有可 能损伤背部和膝部。如果你想跑步锻炼，请先确保体重不要过大，学习正确的姿势和方法，以慢速跑和短距离跑开始练习。所有超过 5 公里的跑步练习都是过度的，最好是不要以跑步来锻炼（译者注：对长期缺乏锻炼的程序员而言？）
不要骑自行车
你都在电脑前坐了一天了，锻炼的时候又坐在自行车上，哈哈。多么有才的选择啊，先生！如果你真的喜欢骑自行车，那么去骑吧，但不要期望能从中得到什么。
不要到健身房健身
高强度的健身方式适用于有意保持健美外形或有意取得某种特定目标的职业人士。通常，高强度训练不适合程序员们。
我们都有自己的职业目标和适合自己的使命，所以就不要玩健身了嘛。
没有效果，太多疼痛和受伤。健康的程序员不需要高强度健身。
应该步行健身
步行比跑步和其他的方式更好。步行简单、安全而且有效。我每天步行5-10 公里，这个习惯给我的健康带来很大的改善。请买双薄鞋底的好鞋子（仔细看好，不要买仿制经典篮球鞋）开始步行锻炼吧！
如果感到太单调，跑步时可听电子书或者播客。边学习边锻炼，多么充实！
更强壮更灵活
你开始步行锻炼了？很好。让我们进入下一级。首先学会正确的腹式呼吸。这可能需要花几天甚至几个星期的时间来养成这个锻炼时的呼吸习惯，这个技能非常必须，可有效缓解颈部和上背部的疼痛。
程序员们花了太多时间坐在电脑前，可能都忘记怎么运动了。建议从头开始，但不需要任何额外的器材，你只需要在视频网站上搜索运动操视频，然后跟着一起运动即可。
当你的移动变得自然平稳，当你走路柔软得像老虎，当你采用腹式呼吸，你的身材正在变得优雅，而大部分疼痛都将离你而去。我建议以下简单的辅助练习：
俯卧撑、下蹲、引体向上和桥式运动。使所有事情简化而不是复杂化。设定小的目标，百分之百关注在动作技巧上。如果你有兴趣，请阅读《The Naked Warrior by Pavel Tsatsouline （裸体战士》 这本书有很多智慧技巧能帮助你进步。
睡眠
最后，我必须指出的是优质睡眠。大家知道，但却实践的少。使你自己在一个结实的床垫上度过一整晚。不要在晚上还盯着电脑或者手机和平板，至少保证睡前一小时不使用这些电子产品。10 点上床，6 点半起床，你就是个快乐程序员！
结论：
你已经知道了，获得健康很容易。只需保持以下习惯：
变换姿势 经常休息 不做蠢事，比如高强度器材健身 更多的步行 正确呼吸 训练灵活性和力量 更多的睡眠 只要坚持几个月，你就会看到收获。</description>
    </item>
    
  </channel>
</rss>
