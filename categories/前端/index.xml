<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on 月盾的博客</title>
    <link>https://www.yuedun.wang/categories/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on 月盾的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 07 Apr 2021 06:29:00 +0000</lastBuildDate><atom:link href="https://www.yuedun.wang/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用sveltekit开发一个服务端渲染（SSR）项目</title>
      <link>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</link>
      <pubDate>Wed, 07 Apr 2021 06:29:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</guid>
      <description>上篇简单介绍了sapper和sveltekit的发展，目前sveltekit还只是Beta版本，有很多不确定因素存在，有可能会有大的变更，所以还不推荐在生产环境中使用，不过在个人项目和小项目中可以大胆尝试。
今天我们就正式使用sveltekit开发一个web项目。
第一步：创建项目 mkdir my-app  cd my-app  npm init svelte@next  npm install  npm run dev 这样就可以创建一个简单的项目了，不过和我们真实需求还有些差距，既然是使用sveltekit，那么最重要的原因是其支持服务端渲染了。这就需要从服务端获取数据，接下来就实现这样的需求。
第二步：路由 和sapper一样，sveltekit也是基于文件系统的的路由器，这就需要我们来合理的组织目录结构。路由的核心目录是src/routes，当然，这个也是可配置的，按照自己的需求修改svelte.config.cjs，参考文档：https://kit.svelte.dev/docs#configuration。
我们以一个博客系统为例，在scr/routes下创建blog目录，光有目录还不行，如果想要访问 /blog 路由，还需要创建index.svelte文件，内容如下：
&amp;lt;script context=&amp;#34;module&amp;#34;&amp;gt;  /** * @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Load} */ 	export async function load({ page, fetch, session, context }) { 	return fetch(`blog.json`)// index.json.js = blog.json或blog/blog.json 	.then((r) =&amp;gt; r.json()) 	.then((posts) =&amp;gt; { 	console.log(posts); 	return { 	props: { 	posts 	} 	}; 	}); 	} &amp;lt;/script&amp;gt;  &amp;lt;script&amp;gt; 	export let posts; &amp;lt;/script&amp;gt;  &amp;lt;svelte:head&amp;gt; 	&amp;lt;title&amp;gt;Blog&amp;lt;/title&amp;gt; &amp;lt;/svelte:head&amp;gt;  &amp;lt;h1&amp;gt;Recent posts&amp;lt;/h1&amp;gt;  &amp;lt;ul&amp;gt; 	{#each posts as post} 	&amp;lt;!</description>
    </item>
    
    <item>
      <title>关于svelte框架——sapper和sveltekit的发展</title>
      <link>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</link>
      <pubDate>Tue, 30 Mar 2021 02:33:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</guid>
      <description>虽然您可能现在还没有听说过svelte，但是其实svelte的发展速度超过了你的想象。
本文主要讲的是关于sapper和sveltekit这两款框架的发展。
svelte作者里奇·哈里斯（Rich Harris）在2020年10月的svelte峰会上表示：sapper永远不会发布1.0版本。
也就是说sapper不会发布正式版，一直处于非稳定版本。也可能放弃更新。
主要原因是sapper多年来代码库变得凌乱，但更主要的原因是最近网络发生了很大变化。
而作者放弃sapper后的另一种选择是开发SvelteKit。
Sapper和SvelteKit都是svelte的开发框架，类似于vue的nuxt框架。
sveltekit包含的功能有：
  服务端渲染（SSR）
  路由
  typescript支持
  less, scss支持
  serverless
  vite打包
  可以看到，sveltekit几乎包含了所有我们想要的功能，既能高效开发，又有高性能。
创建sveltekit的方法：  mkdir my-app  cd my-app  npm init svelte@next  npm install  npm run dev 需要注意，您的nodejs版本需要更新到v12以上，否则可能出现以下错误：
 $ npm run dev -- --open   &amp;gt; sveltekit-app@0.0.1 dev D:\workspace\sveltekit-app  &amp;gt; svelte-kit dev &amp;#34;--open&amp;#34;  D:\workspace\sveltekit-app\node_modules\@sveltejs\kit\svelte-kit.js:2  import &amp;#39;.</description>
    </item>
    
    <item>
      <title>svelte history路由刷新后404</title>
      <link>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</link>
      <pubDate>Fri, 08 Jan 2021 03:55:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</guid>
      <description>npms.io上搜索到svelte的route包其实也不算少，使用比较广泛的svelte-spa-router路由包却不支持history模式。有些支持history模式的使用上也不是很方便，试用过五六个支持history的路由后最终@spaceavocado/svelte-router算是满足了要求。
 使用简单 功能丰富 支持history和hash 我也是够难伺候的。  在试用了多个支持history的路由过程中，都遇到了一个问题：切换路由后刷新404。这也算是单页应用的通病了。不过像vue这种是在部署到服务器上刷新404，而svelte却在开发过程中也出现了，又想放弃了&amp;hellip; 好在我也是试用过五六七八个路由的人了，中间不知道尝试过多少种方法来实现history路由。最后使用@spaceavocado/svelte-router包实现了history路由的时候我还是满心欢喜。
使用方法：
//App.svelte &amp;lt;script&amp;gt; 	import RouterView from &amp;#39;@spaceavocado/svelte-router/component/view&amp;#39;; 	import { routes } from &amp;#39;./router.js&amp;#39; &amp;lt;/script&amp;gt;  &amp;lt;RouterView /&amp;gt; //router.js import createRouter from &amp;#39;@spaceavocado/svelte-router&amp;#39;; import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;;  export const routes = createRouter({  mode: &amp;#34;HISTORY&amp;#34;,  routes: [  {  path: &amp;#39;/&amp;#39;,  name: &amp;#39;HOME&amp;#39;,  component: index,  },  {  path: &amp;#39;/a&amp;#39;,  name: &amp;#39;a&amp;#39;,  component: a,  },  {  path: &amp;#39;/b&amp;#39;,  name: &amp;#39;b&amp;#39;,  component: b,  },  {  path: &amp;#39;*&amp;#39;,  component: index,  },  ], }); // index.</description>
    </item>
    
    <item>
      <title>基于sapper开发svelte项目配置本地代理</title>
      <link>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</link>
      <pubDate>Tue, 05 Jan 2021 11:09:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</guid>
      <description>sapper可能被放弃更新，如果您要继续使用svelte，可以考虑使用sveltekit
 最近使用svelte开发一个项目，说实在的，开发过程中遇到不少问题。 每次遇到问题的时候都有种想放弃的冲动，这生态也太差了，查个啥啥问题都查不到，找个啥啥插件也没有。 不过，到最后，遇到的问题又都解决了。 这不，今天又遇到了本地代理的设置问题。 在说遇到的问题之前先介绍一些项目架构。该项目是基于sapper框架开发，这是一个使用svelte开发的框架，具备以下特点：
 服务端渲染 路由 代码分割 默认支持渐进式web应用（PWA） 预取路由 单独的头标签（meta，link等） 作为静态站点弹出 Cypress测试（免费，简单，端到端的测试）  可以看到，sapper基本是集合了目前前端开发所有需求，双向数据绑定，渐进式开发，SSR，静态化，高性能。
遇到的新问题：对于前端项目，调用接口时容易遇到跨域问题，一般是使用本地代理解决。自然也想这样来做，可是sapper没有vue项目那样的生态，用的打包工具也不是webpack，而是rollup。 那么就使用sapper自带的服务端来做代理好了。sapper的服务端用的是polka，而不是express，不过没关系，其实可以相互替换。 最关键的是增加了http-proxy-middleware中间件，却对中间件位置很敏感，不是想随便在哪添加一下就行。需要添加在第一个中间件位置，否则就会优先使用静态服务中间件，导致接口找不到。 完整代码：
import sirv from &amp;#39;sirv&amp;#39;; import polka from &amp;#39;polka&amp;#39;; import compression from &amp;#39;compression&amp;#39;; import * as sapper from &amp;#39;@sapper/server&amp;#39;; import { createProxyMiddleware } from &amp;#39;http-proxy-middleware&amp;#39;;  const { PORT, NODE_ENV } = process.env; const dev = NODE_ENV === &amp;#39;development&amp;#39;;  polka() 	// 需要放在最前面，否则接口404，secure参数解决调用https问题 	.use(&amp;#39;/api&amp;#39;, createProxyMiddleware({ target: &amp;#39;https://example.</description>
    </item>
    
    <item>
      <title>svelte项目rollup配置px2rem</title>
      <link>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</link>
      <pubDate>Tue, 05 Jan 2021 03:20:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</guid>
      <description>使用svelte开发项目时遇到需要将px转换成rem的需求，有试过postcss-px2rem，postcss-pxtorem，等postcss插件，都没成成功，最后找到了postcss-units插件成功实现。 完整rollup配置文件如下： converts px to rem 该配置是sapper项目配置
import path from &amp;#39;path&amp;#39;; import resolve from &amp;#39;@rollup/plugin-node-resolve&amp;#39;; import replace from &amp;#39;@rollup/plugin-replace&amp;#39;; import commonjs from &amp;#39;@rollup/plugin-commonjs&amp;#39;; import url from &amp;#39;@rollup/plugin-url&amp;#39;; import svelte from &amp;#39;rollup-plugin-svelte&amp;#39;; import babel from &amp;#39;@rollup/plugin-babel&amp;#39;; import { terser } from &amp;#39;rollup-plugin-terser&amp;#39;; import config from &amp;#39;sapper/config/rollup.js&amp;#39;; import pkg from &amp;#39;./package.json&amp;#39;; import sveltePreprocess from &amp;#39;svelte-preprocess&amp;#39;; // import { less } from &amp;#39;svelte-preprocess&amp;#39;; const postcssUnits = require(&amp;#39;postcss-units&amp;#39;);  const mode = process.env.NODE_ENV; const dev = mode === &amp;#39;development&amp;#39;; const legacy = !</description>
    </item>
    
    <item>
      <title>svelte函数传参</title>
      <link>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</link>
      <pubDate>Tue, 29 Dec 2020 02:20:33 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</guid>
      <description>svelte给dom对象绑定事件和vue框架类似。 定义函数：
function handler(index){ 	alert(&amp;#34;hello&amp;#34;, index); } 绑定事件：
&amp;lt;button on:click={handler}&amp;gt;点击&amp;lt;/button&amp;gt;
但是带参函数的使用就略有不同了，函数handler的参数index需要传入的时候，不能直接这样使用&amp;lt;button on:click={handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt;,这样的写法会在页面打开时直接执行，而不是在点击按钮的时候执行。
这是初学svelte的时候比较郁闷的事，官方文档中也没有明显的文档说明如何传参。 正确的传参方式是这样的： &amp;lt;button on:click={() =&amp;gt; handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt; 将on:click的内容改写为匿名函数，在函数中调用。</description>
    </item>
    
    <item>
      <title>Svelte3路由</title>
      <link>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</link>
      <pubDate>Sat, 28 Nov 2020 07:16:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</guid>
      <description>svelte目前没有提供官网路由组件，不过可以在社区中找到。本文介绍的是svelte-spa-router的使用方法。
npm i svelte-spa-router 参考以下目录结构创建文件（不是必须）
router.js:
import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;;  export const routes = {  &amp;#39;/&amp;#39;: index,  &amp;#39;/a&amp;#39;: a,  &amp;#39;/b&amp;#39;: b } 动态导入组件和代码分割：
import { wrap } from &amp;#39;svelte-spa-router/wrap&amp;#39; import index from &amp;#39;./index/index.svelte&amp;#39;;  export const routes = {  &amp;#39;/&amp;#39;: index,  &amp;#39;/a&amp;#39;: wrap({  asyncComponent: () =&amp;gt; import(&amp;#39;./a/a.svelte&amp;#39;)  }),  // &amp;#39;/b&amp;#39;: b 	// 动态加载  &amp;#39;/b&amp;#39;: wrap({  asyncComponent: () =&amp;gt; import(&amp;#39;.</description>
    </item>
    
    <item>
      <title>vue nuxt组建注册</title>
      <link>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</link>
      <pubDate>Wed, 23 Sep 2020 05:50:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</guid>
      <description>Nuxt.js 2.13+可以扫描并自动导入您的组件，不再需要在该script部分中手动导入它们！
nuxt.config配置：
export default {  components: true } 设置为true或使用对象时，它将包含nuxt / components依赖项，并且~/components在模板中使用它们时会自动导入您的组件。
组件目录：
components/  ComponentFoo.vue  ComponentBar.vue 使用
&amp;lt;template&amp;gt;  &amp;lt;ComponentFoo /&amp;gt;  &amp;lt;component-bar /&amp;gt; &amp;lt;/template&amp;gt; 注意：如果使用nuxt 2.10&amp;hellip;2.13，则还必须手动安装并添加@nuxt/components到buildModulesinside nuxt.config。</description>
    </item>
    
    <item>
      <title>vue子组件修改父组件的数据</title>
      <link>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</link>
      <pubDate>Sat, 01 Aug 2020 03:32:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</guid>
      <description>vue在子组件中直接修改父组件传递下来的数据会报错： Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&#39;s value. Prop being mutated: &amp;quot;json&amp;quot;
原因是vue子组件不能直接修改父组件的数据，可以使用this.$emit发送通知，让父组件来修改。 示例代码：
子组件：
this.$emit(&amp;#34;changeData&amp;#34;, &amp;#34;要修改的数据&amp;#34;); 父组件：
&amp;lt;mycomponent :json=&amp;#34;JsonData&amp;#34; @changeData=&amp;#34;changeData&amp;#34;&amp;gt;&amp;lt;/mycomponent&amp;gt; data(){ return { JsonData:{} } } methods:{ changeData(newData){ this.JsonData = newData; } } 子组件发送changeData事件， 父组件绑定changeData事件并接受数据，赋值给父组件的JsonData属性，子组件的值也会改变。从而实现子组件修改父组件的属性值。</description>
    </item>
    
    <item>
      <title>原生js实现图片预览</title>
      <link>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</link>
      <pubDate>Wed, 29 Jul 2020 03:45:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</guid>
      <description>不依赖jquery也可以实现图片预览功能：
&amp;lt;!--图片放大后的div 开始 这块粘贴在你的html中最后body前 --&amp;gt; &amp;lt;div id=&amp;#34;outerdiv&amp;#34; style=&amp;#34;text-align: center;position: fixed;z-index: 9999;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(28,28,28,0.9);&amp;#34;&amp;gt; 	&amp;lt;img id=&amp;#34;bigimg&amp;#34; style=&amp;#34;max-height: 800px;max-width: 100%;border: 0;margin: auto;position: absolute;top: 0;bottom: 0;left: 0;right: 0;&amp;#34; src=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--图片放大后的div 结束 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;!--js开始 是放大点击的触发事件 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; 	//图片放大 	document.querySelector(&amp;#34;#outerdiv&amp;#34;).style.display = &amp;#34;none&amp;#34;; 	document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { 	item.style.cursor = &amp;#34;pointer&amp;#34;; 	});  	document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { 	item.addEventListener(&amp;#34;click&amp;#34;, function () { 	imgShow(&amp;#34;#outerdiv&amp;#34;, &amp;#34;#bigimg&amp;#34;, this); 	}) 	})  	function imgShow(outerdiv, bigimg, _this) { 	var src = _this.</description>
    </item>
    
    <item>
      <title>js转图片为base64上传</title>
      <link>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</link>
      <pubDate>Mon, 25 Jun 2018 07:10:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</guid>
      <description>//上传图片 	var imagesBase64 = []; 	$(&amp;#34;input[type=file]&amp;#34;).on(&amp;#34;change&amp;#34;, function (e) { 	var image = e.target.files[0]; 	var imgFile = new FileReader(); 	var imgShow = new Image(); 	imgFile.readAsDataURL(image); 	imgFile.onload = function () { 	var imgData = this.result; //base64数据 	imagesBase64.push({ 	teaId: teacherInfo.id, 	fileType: &amp;#34;award&amp;#34;,//图片 	fileName: image.name, 	file: imgData, 	}); 	imgShow.src = imgData; 	imgShow.style.width = &amp;#34;100px&amp;#34;; 	imgShow.style.height = &amp;#34;100px&amp;#34;; 	imgShow.</description>
    </item>
    
    <item>
      <title>webpack构建vue项目警告</title>
      <link>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</link>
      <pubDate>Fri, 16 Feb 2018 13:22:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</guid>
      <description>bundle.js:935 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.  (found in &amp;lt;Root&amp;gt;) 解决方案：与entry属性平级添加
resolve: {  alias: {  &amp;#39;vue$&amp;#39;: &amp;#39;vue/dist/vue.esm.js&amp;#39; 	//该路径为node_modules下的vue目录  }  } // 需要编译器 new Vue({  template: &amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39; })  // 不需要编译器 new Vue({  render (h) {  return h(&amp;#39;div&amp;#39;, this.</description>
    </item>
    
    <item>
      <title>js复制文本内容</title>
      <link>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</link>
      <pubDate>Thu, 02 Jun 2016 05:36:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</guid>
      <description>http://yuedun.github.io/copy.html
点击链接查看:js复制</description>
    </item>
    
    <item>
      <title>fullcalendar点击prve或者next按钮翻月触发事件调用</title>
      <link>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</link>
      <pubDate>Tue, 22 Mar 2016 13:32:59 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</guid>
      <description>$(&amp;#39;#calendar&amp;#39;).fullCalendar({  lang: &amp;#34;zh-cn&amp;#34;,  header: {  left: &amp;#39;prev, next, today&amp;#39;,  center: &amp;#39;title&amp;#39;,  right: &amp;#39;month&amp;#39;  },  height: 500,  dayClick: function(date, jsEvent, view) {  //点击空白日期调用  },  eventClick: function(calEvent, jsEvent, view) {  //点击已有数据的日期调用  },  defaultDate: moment(),//默认日期  events:function(start, end, callback){  //点击prev上一月, next下一月等事件时调用  } }); </description>
    </item>
    
    <item>
      <title>vue.js做的应用中点击搜索功能会改变URI</title>
      <link>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</link>
      <pubDate>Thu, 04 Feb 2016 07:59:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</guid>
      <description>用vue.js做的后台管理系统，有一个列表搜索功能，正常登陆进去，直接点击搜索功能，页面就会刷新一遍，原因是url地址变化了
原本地址是：
http://www.mydomain/#!/index
点击搜索以后就变成了
http://www.mydomain/?#!/index
在#!前面自动加了?，导致页面刷新一遍，这样第一次搜索就没意义了.
经过初步排查后发现点击其他按钮不会改变URL地址，对比后发现搜索按钮的type=&amp;ldquo;submit&amp;rdquo;，可能是提交表单导致跳转了，那么将type改为button或者直接去掉试试，结果还是不行，干脆也改为标签（加了bootstrap按钮样式），结果好了。为什么将button type改为button不行呢，原因是在标签内标签type会被默认当做submit，（IE浏览器默认type=button）</description>
    </item>
    
    <item>
      <title>vue.js click点击事件获取当前元素对象</title>
      <link>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</link>
      <pubDate>Wed, 27 Jan 2016 14:59:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</guid>
      <description>Vue.js可以传递$event对象
&amp;lt;body id=&amp;#34;app&amp;#34;&amp;gt;  &amp;lt;ul&amp;gt; 	&amp;lt;li v-on:click=&amp;#34;say(&amp;#39;hello!&amp;#39;, $event)&amp;#34;&amp;gt;点击当前行文本&amp;lt;/li&amp;gt; 	&amp;lt;li&amp;gt;li2&amp;lt;/li&amp;gt; 	&amp;lt;li&amp;gt;li3&amp;lt;/li&amp;gt;  &amp;lt;/ul&amp;gt;  &amp;lt;script&amp;gt;  new Vue({ 	el: &amp;#39;#app&amp;#39;, 	data: { 	message: &amp;#39;Hello Vue.js!&amp;#39; 	}, 	methods: { 	say: function(msg, event) { 	//获取点击对象 	var el = event.currentTarget; 	alert(&amp;#34;当前对象的内容：&amp;#34;+el.innerHTML); 	} 	}  })  &amp;lt;/script&amp;gt;  &amp;lt;/body&amp;gt; 函数调用处传递$event
v-on:click=&amp;quot;say(&#39;hello!&#39;, $event)&amp;quot;
函数中获取到的event.currentTarget对象就是当前元素
在线示例
请查看HTML页面示例源码</description>
    </item>
    
    <item>
      <title>vue.js对表单值初始化</title>
      <link>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</link>
      <pubDate>Thu, 14 Jan 2016 01:57:43 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</guid>
      <description>新建表单有些input输入框需要默认值，比如性别需要一个男或女默认值。再比如一个日期选择框需要默认今天。如果按照HTML的方式设置不会起作用
&amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;0&amp;#34; checked=&amp;#34;checked&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;男 &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;1&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;女 &amp;lt;input type=&amp;#34;date&amp;#34; value=&amp;#34;2016-01-06&amp;#34; v-model=&amp;#34;date&amp;#34;&amp;gt; 在vue.js页面中上面这种设置方式是不会起作用的,性别不会选中，日期也不会有值。解决办法是对v-model属性设值，在初始化时给gender=0，那么默认会选中性别男，给date=&amp;ldquo;2016-01-06&amp;quot;日期控件也有值。</description>
    </item>
    
    <item>
      <title>js省市级联动插件</title>
      <link>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</link>
      <pubDate>Tue, 12 Jan 2016 04:45:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</guid>
      <description>在线示例：http://www.yuedun.wang/views/address
具体代码看页面源码</description>
    </item>
    
    <item>
      <title>vue.js中使用focus，blur事件</title>
      <link>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</link>
      <pubDate>Sun, 10 Jan 2016 04:08:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</guid>
      <description>在线示例
使用focus，blur可对表单进行验证，除了这两个事件，还有一个watch属性可监听data属性值得变化，具体可打开浏览器控制台看属性值得变化情况，代码可直接在浏览器中查看源码</description>
    </item>
    
    <item>
      <title>vue.js开发gulp监听文件变化自动编译</title>
      <link>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</link>
      <pubDate>Mon, 04 Jan 2016 05:52:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</guid>
      <description>直接看代码：
var gulp = require(&amp;#39;gulp&amp;#39;) var webpack = require(&amp;#34;gulp-webpack&amp;#34;); var webpackConfig = require(&amp;#34;./webpack.config.js&amp;#34;); // gulp.task(&amp;#34;webpack&amp;#34;, function(callback) { // var myConfig = Object.create(webpackConfig); // webpack(myConfig, function(err, stats) { // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;err:&amp;#34;+JSON.stringify(err)) // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;stats:&amp;#34;+stats) // if(err) throw new Error(&amp;#34;webpack&amp;#34;, err); // callback(); // }); // });  /** * 编译时有错误提示 */ gulp.task(&amp;#34;webpack&amp;#34;, function(){  return gulp.src(&amp;#34;./app.js&amp;#34;)  .pipe(webpack(Object.create(webpackConfig)))  .pipe(gulp.dest(&amp;#34;./dist/&amp;#34;)) });  gulp.watch(&amp;#39;./views/*&amp;#39;, [&amp;#39;webpack&amp;#39;]); webpack.config.js配置
var webpack = require(&amp;#34;webpack&amp;#34;); module.exports = {  entry: //&amp;#34;.</description>
    </item>
    
    <item>
      <title>vue.js在chrome浏览器下输入汉字会带出拼音</title>
      <link>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</link>
      <pubDate>Fri, 01 Jan 2016 10:19:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</guid>
      <description>本想写篇vue.js的教程的，但牵扯的知识点比较多，最近又没时间，就记录下过程中遇到问题吧。开发过程中用的360极速浏览器，也没什么问题，但是其他人测试的时候用的是chrome浏览器，输入汉字的时候会连拼音也带进去，比如输入的是“你好”，结果却成了“nihao你好”。
按理说360极速浏览器也用的是chrome内核，不应该出现这两种不同的情况，这个问题先不追究了。还是说说为什么vue.js的输入框会出现拼音的问题。我本以为是浏览器的差异造成这种现象，但是也不是所有输入框都会出现，那一定是程序的问题。
这是一种双向数据绑定常见写法，但是由于我的理解不够透彻，写成了这样：
我的理解是更新的时候要先显示数据，所以就在input里加了value来初始化数据，也是因为加了这个value导致输入汉字出现拼音，也与浏览器有点关系，就是输入的时候chrome浏览器会把输入的汉字拼音拼写也放进输入框，那么数据模型就接收了输入，敲击空格键的时候又输进了汉字，所以就都带进来了。但其实只需要v-model就能实现数据的接收和输出。</description>
    </item>
    
    <item>
      <title>js prototype的理解【转】</title>
      <link>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</link>
      <pubDate>Wed, 25 Nov 2015 02:28:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</guid>
      <description>prototype属性可算是JavaScript与其他面向对象语言的一大不同之处。 prototype就是“一个给类的对象添加方法的方法”，使用prototype属性，可以给类动态地添加方法，以便在JavaScript中实现“ 继承”的效果。
具体来说，prototype 是在 IE 4 及其以后版本引入的一个针对于某一类的对象的方法，当你用prototype编写一个类后，如果new一个新的对象，浏览器会自动把prototype中 的内容替你附加在对象上。这样，通过利用prototype就可以在JavaScript中实现成员函数的定义，甚至是“继承”的效果。
对于javascript本身而言是基于对象的，任何元素都可以看成对象。然而类型和对象是不同的，而我们所讲的prototype属性即是基于类型的一 种属性。对于prototype的基本使用就如对象的创建及属性赋值一样的简单。直接通过赋值操作即可完成属性的创建。
 /** * 关于prototype, 理解这个很有必要 可以在类型上使用proptotype来为类型添加行为。这些行为只能在类型的实例上体现。 JS中允许的类型有Array, Boolean, Date, Enumerator, Error, Function, Number, Object, RegExp, String 以后这样分，没有实例化的类称为类型，实例化的类称为对象实例简称实例 */ Object.prototype.name = &amp;#34;zhangsan&amp;#34;;  Object.prototype.nihao = function () {   alert(&amp;#34;i can method name is &amp;#34; + this.name);  }  var obj = new Object();  obj.nihao();  alert(obj.name);    // 在实例上不能使用prototype，否则会发生编译错误  obj.prototype.sex = &amp;#34;男&amp;#34;; //error,无法给一个实例prototype var o = {   name: &amp;#34;zhangsan&amp;#34;  }  o.</description>
    </item>
    
    <item>
      <title>js控制优酷视频播放暂停</title>
      <link>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</link>
      <pubDate>Tue, 17 Nov 2015 07:48:37 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</guid>
      <description>js控制优酷视频播放暂停
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt;  &amp;lt;head&amp;gt;  &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt;  &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&amp;#34;&amp;gt;  &amp;lt;title&amp;gt;js控制优酷视频播放&amp;lt;/title&amp;gt;  &amp;lt;script src=&amp;#34;http://player.youku.com/jsapi&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;  &amp;lt;script&amp;gt;  player = new YKU.Player(&amp;#34;youkuplayer&amp;#34;,{  styleid: &amp;#34;0&amp;#34;,  client_id: &amp;#34;d8781b239fdad45b&amp;#34;,  vid: &amp;#34;XMjg1MTcyNDQ0&amp;#34;,  autoplay: false,  show_related: true,  events:{  onPlayEnd: function(){ /*your code*/ },  onPlayStart: function(){ /*your code*/ },  onPlayerReady: function(){ /*your code*/ }  }  });  function playVideo(){  try{  player.</description>
    </item>
    
    <item>
      <title>无插件实现动态瀑布流加载数据</title>
      <link>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</link>
      <pubDate>Tue, 03 Nov 2015 03:02:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</guid>
      <description>以前在页面中动态加载帖子数据使用了waterfall.js插件，当初折腾了不少时间才搞定，这次又有一个页面需要动态加载数据，自然想到了waterfall插件，但是结果很不理想，waterfall的很多参数不管是什么用处，反正看着很头疼，最麻烦的是它会改变页面样式和布局，实在不想调整了，还是自己实现这个功能吧！
首先看下面代码：
var pageIndex = 2;  (function loadmore() {   //绑定滚动事件  $(window).bind(&amp;#34;scroll&amp;#34;, function() {   if ($(this).scrollTop() + $(window).height() + 40 &amp;gt;= $(document).height() &amp;amp;amp;&amp;amp;amp; $(this).scrollTop() &amp;gt;= 40) {   $(window).unbind(&amp;#34;scroll&amp;#34;); //到底后先移除滚动事件  $.get(&amp;#34;/portal/getTopic?pageIndex=&amp;#34; + pageIndex + &amp;#34;&amp;amp;amp;pageSize=3&amp;#34;,  function(data) {   $(&amp;#34;#container&amp;#34;).append(data);   pageIndex++;   loadmore(); //数据加载成功重新绑定滚动事件  },  &amp;#34;html&amp;#34;);   };   });  })(); 没错，就这么点，这已经是实现功能的最简单版本了。代码的基本流程是给页面绑定滚动事件，判断是否滚动到最底部，然后加载数据。但实际上并不是这么简单就能行的，有很多意外情况需要解决。
先来说明如何判断页面是否滚动到最底部，$(this).scrollTop()用来计算滚动条顶端距离窗口顶部的距离，整个滚动条高度大约等于整个页面高度。当滚动条滚动到最底部的时候，滚动条顶端距离窗口顶部并不是整个页面的高度，还需要加上当前窗口所占高度才是整个页面正真的高度。所以就是$(this).scrollTop() + $(window).</description>
    </item>
    
    <item>
      <title>一次简单的前端页面优化</title>
      <link>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</link>
      <pubDate>Mon, 31 Aug 2015 05:38:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</guid>
      <description>公司之前的产品管理对于小编们的使用情况及其糟糕，每次打开一个页面都要等待好久，这也是由于时间紧张，开始做的时候就只管进度没有时间优化。我大概看了下，光是登录页和一个空白首页就有78个请求，1.1M的数据。其他功能页面不少于这个数，这是因为所有页面共用了一个头文件，而这个头文件把所有有用没有的css文件和js文件都加载进来了，所以这次做的新后台管理系统绝不能这么做了。
首先，css按需加载，当然有一些css是每个页面必须的就放到一个公共页面中include进来，对于一些新增的插件就在需要的时候添加到对应的页面。
其次，js的加载方式也进行特别优化，一种方式是把js放在body结束标签之前，可以避免js的加载阻塞页面渲染，还有可以使用异步加载方式defer是针对IE浏览器的，async是其他非IE内核浏览器异步加载属性。但是，我还是使用了requirejs来加载js，一方面是为了页面加载更快，另一方面是可以做到js模块化。
初步结果显示，所有页面加载速度平均在0.5秒，有些页面几乎看不出来重新加载过程，瞬间完成。优化也算是有一定的效果了。其中要说一下requirejs的一些优缺点，requirejs优点是可以实现js异步加载和模块化开发，不过让我有点不适应的是在HTML页面中不能使用onclick=func这种方式的事件处理，会提示找不到函数，只能在页面加载完成后用jquery进行事件监听，一些动态加载的页面数据也需要在加载以后重新绑定事件。
2015-11-08日更新
自从使用了requirejs后，凡是做页面需要js的时候首先想到的就是requirejs，感觉入坑跳不出来，反而弄巧成拙了。requirejs本意是异步加载多个js文件以防止页面阻塞，在一个网站或项目中也尽量合并多个文件里的内容以减少网络请求，一次加载一个大的文件比多次加载多个小文件来的划算的多，还有，requirejs虽然有好处但是并不是任何时候都有，比如页面很简单，js内容也很少的时候就完全不该用它。最后有一个不得不说的缺点，在上面已经提过，就是事件绑定，因为不能使用onclick=func()这种方式调用函数，只能用$(function(){})这种方式绑定事件，那么在网络不好的情况下，有些文件加载缓慢，导致不能绑定事件，如果一个按钮是这种方式绑定的事件，结果就是非要等到页面加载完才能点击，很让人着急。</description>
    </item>
    
    <item>
      <title>前端工具gulp的用途和使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</link>
      <pubDate>Tue, 07 Jul 2015 13:38:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</guid>
      <description>在接触前端开始就听说过grunt和gulp是很叼的前端构建工具，但不知道到底有多叼，只是听说可以自动编译less，sass为css，目前还没有使用less和sass，所以也就没有尝试使用grunt和gulp。但是作为一个技术爱好者还是经不住诱惑，照着网上的教程简单使用了一下，总算是知道有什么用处了，因为都说gulp比grunt更简单好用，就以gulp的使用方法为例来说明一下。
文件合并：关于文件合并很多人存在这样的疑惑，在前端开发中到底该把所有js和css写在一个文件里还是各个页面分开写，我的建议是开发的时候分开写，上线的时候合并为一个，这样的好处是对于浏览器来说，不同页面中相同的文件默认会请求一次缓存下来，其他页面请求相同文件时就直接从缓存中读取，减少文件的网络请求可以提高网页速度，所以文件合并的是很有必要的。
2.文件压缩：既然都合并了，何不再压缩一下呢
3.语法检查：这个功能一般会和下面第4条功能配合使用，当文件修改的时候检查是否有语法错误，并在命令行中输出错误信息。
4.监听文件变化：监听某个目录下文件是否修改，修改的话就执行特定的操作，比如上面几个操作。 以上4点是比较常用的功能，更多功能根据自己需要添加
var gulp = require(&amp;#39;gulp&amp;#39;); var jshint = require(&amp;#39;gulp-jshint&amp;#39;);//语法检查 var concat = require(&amp;#39;gulp-concat&amp;#39;);//合并文件 var uglify = require(&amp;#39;gulp-uglify&amp;#39;);//压缩代码 var rename = require(&amp;#39;gulp-rename&amp;#39;);//重命名  // 语法检查 gulp.task(&amp;#39;jshint&amp;#39;, function () { return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(jshint()) .pipe(jshint.reporter(&amp;#39;default&amp;#39;)); });  // 合并文件之后压缩代码 gulp.task(&amp;#39;minify&amp;#39;, function (){ return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(concat(&amp;#39;all.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)) .pipe(uglify()) .pipe(rename(&amp;#39;all.min.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)); });  // 监视文件的变化 gulp.task(&amp;#39;watch&amp;#39;, function () { gulp.watch(&amp;#39;public/javascripts/*.js&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;]); });  // 注册缺省任务 gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;, &amp;#39;watch&amp;#39;]); // gulp.</description>
    </item>
    
  </channel>
</rss>
