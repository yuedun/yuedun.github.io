<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on 月盾的博客</title>
    <link>https://www.yuedun.wang/categories/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on 月盾的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 28 May 2024 15:49:21 +0800</lastBuildDate><atom:link href="https://www.yuedun.wang/categories/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>微信小程序页面之间传递数据和通信</title>
      <link>https://www.yuedun.wang/2024/05/miniprogram-page-comunicate/</link>
      <pubDate>Tue, 28 May 2024 15:49:21 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2024/05/miniprogram-page-comunicate/</guid>
      <description>&lt;p&gt;微信小程序页面间通信有标准的方法。
有页面A，页面B，按照顺序，A -&amp;gt; B，再从B -&amp;gt; A。两种操作页面之间数据传递。&lt;/p&gt;
&lt;p&gt;A页面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Page&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;jump&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;wx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;navigateTo&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;./b-page?id=123&amp;#39;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;events&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;acceptDataFromOpenedPage&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;//接收B页面发送的数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;success&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;//页面打开后发送数据到B页面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;res&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;eventChannel&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;emit&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;acceptDataFromOpenerPage&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;send from opener page&amp;#39;&lt;/span&gt; })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;B页面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Page&lt;/span&gt;({
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;onLoad&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;option&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;option&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;;&lt;span style=&#34;color:#75715e&#34;&gt;// 通过URL参数获取A页面传递的数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eventChannel&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getOpenerEventChannel&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;eventChannel&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;on&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;acceptDataFromOpenerPage&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;//通过事件channel接收A页面传递的数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;setDataToA&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;eventChannel&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getOpenerEventChannel&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;eventChannel&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;emit&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;acceptDataFromOpenedPage&amp;#39;&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;send from opened page&amp;#39;&lt;/span&gt; })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>又一个比Nodejs快的运行时，它叫LLRT</title>
      <link>https://www.yuedun.wang/2024/02/node-deno-bun-llrt/</link>
      <pubDate>Wed, 28 Feb 2024 16:16:19 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2024/02/node-deno-bun-llrt/</guid>
      <description>前端圈的发展一向让人感觉学不动，前有Deno，后有Bun，这不，最近又出了个比Nodejs快的Runtime，它叫LLRT。
1. 什么是LLRT LLRT是Low Latency Runtime的缩写，是一种轻量级JavaScript运行时，旨在满足对快速高效的无服务器应用程序日益增长的需求。与在AWS Lambda上运行的其他JavaScript运行时相比，LLRT的启动速度提高了10倍以上，总体成本降低了2倍。
2. LLRT是如何做到比Nodejs快的 它内置在Rust中，利用QuickJS作为JavaScript引擎，确保高效的内存使用和快速启动。
3. LLRT的发展 它还处于实验阶段，并不稳定，还不推荐用于生产。</description>
    </item>
    
    <item>
      <title>next/image组件导致服务器504超时</title>
      <link>https://www.yuedun.wang/2023/05/next-image-timeout/</link>
      <pubDate>Wed, 17 May 2023 19:38:34 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/05/next-image-timeout/</guid>
      <description>谁能想到，一个前端组件也能把服务搞崩溃。这个组件正是next/image，原本是想利用next/image来优化图片，next.js官方也一直推荐这么做。
突然有一天用户反馈网站出现504超时报错，当时优先重启恢复服务。然后把日志打开观察，果不其然，几分钟后就又出现504超时，伴随出现的日志则是：
upstream image response failed for https://example.com/280d59d8-f3b0-11ed-a295-00163e253f9a_00002_VvBbv3zj.jpg?OSSAccessKeyId=LTAI5nodLHeacT1J5SmWh&amp;amp;Expires=317044217325&amp;amp;Signature=Wf5jYWf7vnXOyRoKLVtiTCrt8%3D 404 初步判断是图片404导致服务器超时，深入猜测是使用next.js服务端渲染请求了图片资源，而图片资源不存在导致服务器渲染出错。
但是很不合理，服务端只是把图片资源的地址渲染到html中，并不会在服务端请求图片资源才对，为什么服务器日志会出现上述错误信息呢？于是观察浏览器中图片的请求，发现格式是这样的： http://example.com/_next/image?url=https%3A%2F%2Fexample.com%2Ff6c912da-f0cc0000_0d7GBaLE.jpg%3FOSSAccessKeyId%3DmWh%26Expires%3D317043899846%26Signature%3DYUMro%253D&amp;amp;w=384&amp;amp;q=75
浏览器请求的图片资源并不是图片的真实地址，而是经过了next.js服务处理的，尤其是URL最后两个参数，是图片压缩参数。如果你发现图片变模糊了，也可能是这两个参数捣的鬼。直接拿着这个地址去浏览器请求发现响应很慢，这时再次得出结论：这个图片组件有问题。为了验证把所有使用了next/image组件全部使用原生img标签，发布到线上后就再没出现504超时。
总结：next/image组件包装后的图片资源需要经过node层压缩处理，会消耗CPU资源，对于大量的图片资源会有风险，酌情处理。 本次出现的时候伴随着图片资源404，可能是有bug存在，如果加载不到正确的图片就会触发bug。 另一种解决方案：根据官方文档说明，如果使用next/image,需要添加sharp包来提高性能，但是可能需要注意内存消耗问题。</description>
    </item>
    
    <item>
      <title>next.js项目使用pm2 reload出现502</title>
      <link>https://www.yuedun.wang/2023/05/pm2-reload-nextjs-502/</link>
      <pubDate>Mon, 15 May 2023 19:09:41 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2023/05/pm2-reload-nextjs-502/</guid>
      <description>为了使next.js项目能够不宕机，使用了pm2守护进程，既能保证node出现异常情况能够自动重启，也能保证服务器整机重启时自动恢复服务。多年使用下来的确能够良好运行，不过最近却出现了与原本期望不符的情况。
在已经启动next.js项目的情况下，如果需要重启，我使用了pm2 reload appname，实际上没有完美的零停机重启，反而是直接出现服务不可用，访问网站就502，并且一直无法恢复。在查阅pm2 issue后发现确实有这样的bug。
无奈，只能使用pm2 restart来重启应用。</description>
    </item>
    
    <item>
      <title>Sveltekit1.0后的使用感受</title>
      <link>https://www.yuedun.wang/2022/12/sveltekit/</link>
      <pubDate>Sat, 31 Dec 2022 11:02:40 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/2022/12/sveltekit/</guid>
      <description>之前提到过关于svelte框架——sapper和sveltekit的发展，已经是1年前的事了，其中提到过svelte的框架sapper和sveltekit，sapper已经明确不再更新了，官方推荐的是sveltekit。然后经过两年的迭代更新，于2022年12月终于推出了1.0版本。可以看看官方博客对1.0的介绍Announcing SvelteKit 1.0。
然后谈谈个人感受。
优点： sveltekit集成的还不错，开发体验可以，使用官方提供的脚手架创建的项目就可以直接使用，不需要做任何配置。热更新，响应速度快，支持typescript等等，该有的都有了。
缺点： 又是一个全新轮子，这也是整个前端的通病，除了js是通用的，其他的都能给你整出花来，sveltekit在1.0版本之内已经有破坏性的更新，一年前创建的新项目，一年后基本不能用了。
至于要不要使用，那就看个人情况了，如果你厌烦了其他框架，倒是可以尝尝鲜，如果你想以此来做长期项目的话，个人就不推荐了，毕竟太新，而且向下兼容又做的不好，隔三差五一个破坏性更新，这种折腾劲恐怕没几个人受得了。而且对自己的技术也不能积累，长此以往并没有好处。
sveltekit官方文档</description>
    </item>
    
    <item>
      <title>使用sveltekit开发一个服务端渲染（SSR）项目</title>
      <link>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</link>
      <pubDate>Wed, 07 Apr 2021 06:29:00 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/606d512c54277a10496a38ae/</guid>
      <description>上篇简单介绍了sapper和sveltekit的发展，目前sveltekit还只是Beta版本，有很多不确定因素存在，有可能会有大的变更，所以还不推荐在生产环境中使用，不过在个人项目和小项目中可以大胆尝试。
今天我们就正式使用sveltekit开发一个web项目。
第一步：创建项目 mkdir my-app cd my-app npm init svelte@next npm install npm run dev 这样就可以创建一个简单的项目了，不过和我们真实需求还有些差距，既然是使用sveltekit，那么最重要的原因是其支持服务端渲染了。这就需要从服务端获取数据，接下来就实现这样的需求。
第二步：路由 和sapper一样，sveltekit也是基于文件系统的的路由器，这就需要我们来合理的组织目录结构。路由的核心目录是src/routes，当然，这个也是可配置的，按照自己的需求修改svelte.config.cjs，参考文档：https://kit.svelte.dev/docs#configuration。
我们以一个博客系统为例，在scr/routes下创建blog目录，光有目录还不行，如果想要访问 /blog 路由，还需要创建index.svelte文件，内容如下：
&amp;lt;script context=&amp;#34;module&amp;#34;&amp;gt; /** * @type {import(&amp;#39;@sveltejs/kit&amp;#39;).Load} */ export async function load({ page, fetch, session, context }) { return fetch(`blog.json`)// index.json.js = blog.json或blog/blog.json .then((r) =&amp;gt; r.json()) .then((posts) =&amp;gt; { console.log(posts); return { props: { posts } }; }); } &amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; export let posts; &amp;lt;/script&amp;gt; &amp;lt;svelte:head&amp;gt; &amp;lt;title&amp;gt;Blog&amp;lt;/title&amp;gt; &amp;lt;/svelte:head&amp;gt; &amp;lt;h1&amp;gt;Recent posts&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; {#each posts as post} &amp;lt;!</description>
    </item>
    
    <item>
      <title>关于svelte框架——sapper和sveltekit的发展</title>
      <link>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</link>
      <pubDate>Tue, 30 Mar 2021 02:33:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</guid>
      <description>虽然您可能现在还没有听说过svelte，但是其实svelte的发展速度超过了你的想象。
本文主要讲的是关于sapper和sveltekit这两款框架的发展。
svelte作者里奇·哈里斯（Rich Harris）在2020年10月的svelte峰会上表示：sapper永远不会发布1.0版本。
也就是说sapper不会发布正式版，一直处于非稳定版本。也可能放弃更新。
主要原因是sapper多年来代码库变得凌乱，但更主要的原因是最近网络发生了很大变化。
而作者放弃sapper后的另一种选择是开发SvelteKit。
Sapper和SvelteKit都是svelte的开发框架，类似于vue的nuxt框架。
sveltekit包含的功能有：
服务端渲染（SSR）
路由
typescript支持
less, scss支持
serverless
vite打包
可以看到，sveltekit几乎包含了所有我们想要的功能，既能高效开发，又有高性能。
创建sveltekit的方法： mkdir my-app cd my-app npm init svelte@next npm install npm run dev 需要注意，您的nodejs版本需要更新到v12以上，否则可能出现以下错误：
$ npm run dev -- --open &amp;gt; sveltekit-app@0.0.1 dev D:\workspace\sveltekit-app &amp;gt; svelte-kit dev &amp;#34;--open&amp;#34; D:\workspace\sveltekit-app\node_modules\@sveltejs\kit\svelte-kit.js:2 import &amp;#39;./dist/cli.js&amp;#39;; SyntaxError: Unexpected string at Module._compile (internal/modules/cjs/loader.js:723:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Function.Module.runMain (internal/modules/cjs/loader.js:831:12) at startup (internal/bootstrap/node.</description>
    </item>
    
    <item>
      <title>svelte history路由刷新后404</title>
      <link>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</link>
      <pubDate>Fri, 08 Jan 2021 03:55:56 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff7d7cc3f518207e72349ed/</guid>
      <description>npms.io上搜索到svelte的route包其实也不算少，使用比较广泛的svelte-spa-router路由包却不支持history模式。有些支持history模式的使用上也不是很方便，试用过五六个支持history的路由后最终@spaceavocado/svelte-router算是满足了要求。
使用简单 功能丰富 支持history和hash 我也是够难伺候的。 在试用了多个支持history的路由过程中，都遇到了一个问题：切换路由后刷新404。这也算是单页应用的通病了。不过像vue这种是在部署到服务器上刷新404，而svelte却在开发过程中也出现了，又想放弃了&amp;hellip; 好在我也是试用过五六七八个路由的人了，中间不知道尝试过多少种方法来实现history路由。最后使用@spaceavocado/svelte-router包实现了history路由的时候我还是满心欢喜。
使用方法：
//App.svelte &amp;lt;script&amp;gt; import RouterView from &amp;#39;@spaceavocado/svelte-router/component/view&amp;#39;; import { routes } from &amp;#39;./router.js&amp;#39; &amp;lt;/script&amp;gt; &amp;lt;RouterView /&amp;gt; //router.js import createRouter from &amp;#39;@spaceavocado/svelte-router&amp;#39;; import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;; export const routes = createRouter({ mode: &amp;#34;HISTORY&amp;#34;, routes: [ { path: &amp;#39;/&amp;#39;, name: &amp;#39;HOME&amp;#39;, component: index, }, { path: &amp;#39;/a&amp;#39;, name: &amp;#39;a&amp;#39;, component: a, }, { path: &amp;#39;/b&amp;#39;, name: &amp;#39;b&amp;#39;, component: b, }, { path: &amp;#39;*&amp;#39;, component: index, }, ], }); // index.</description>
    </item>
    
    <item>
      <title>基于sapper开发svelte项目配置本地代理</title>
      <link>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</link>
      <pubDate>Tue, 05 Jan 2021 11:09:55 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff449035e80c6649222da2c/</guid>
      <description>sapper可能被放弃更新，如果您要继续使用svelte，可以考虑使用sveltekit
最近使用svelte开发一个项目，说实在的，开发过程中遇到不少问题。 每次遇到问题的时候都有种想放弃的冲动，这生态也太差了，查个啥啥问题都查不到，找个啥啥插件也没有。 不过，到最后，遇到的问题又都解决了。 这不，今天又遇到了本地代理的设置问题。 在说遇到的问题之前先介绍一些项目架构。该项目是基于sapper框架开发，这是一个使用svelte开发的框架，具备以下特点：
服务端渲染 路由 代码分割 默认支持渐进式web应用（PWA） 预取路由 单独的头标签（meta，link等） 作为静态站点弹出 Cypress测试（免费，简单，端到端的测试） 可以看到，sapper基本是集合了目前前端开发所有需求，双向数据绑定，渐进式开发，SSR，静态化，高性能。
遇到的新问题：对于前端项目，调用接口时容易遇到跨域问题，一般是使用本地代理解决。自然也想这样来做，可是sapper没有vue项目那样的生态，用的打包工具也不是webpack，而是rollup。 那么就使用sapper自带的服务端来做代理好了。sapper的服务端用的是polka，而不是express，不过没关系，其实可以相互替换。 最关键的是增加了http-proxy-middleware中间件，却对中间件位置很敏感，不是想随便在哪添加一下就行。需要添加在第一个中间件位置，否则就会优先使用静态服务中间件，导致接口找不到。 完整代码：
import sirv from &amp;#39;sirv&amp;#39;; import polka from &amp;#39;polka&amp;#39;; import compression from &amp;#39;compression&amp;#39;; import * as sapper from &amp;#39;@sapper/server&amp;#39;; import { createProxyMiddleware } from &amp;#39;http-proxy-middleware&amp;#39;; const { PORT, NODE_ENV } = process.env; const dev = NODE_ENV === &amp;#39;development&amp;#39;; polka() // 需要放在最前面，否则接口404，secure参数解决调用https问题 .use(&amp;#39;/api&amp;#39;, createProxyMiddleware({ target: &amp;#39;https://example.com&amp;#39;, pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39; }, secure: false, changeOrigin: true, })) .</description>
    </item>
    
    <item>
      <title>svelte项目rollup配置px2rem</title>
      <link>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</link>
      <pubDate>Tue, 05 Jan 2021 03:20:41 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5ff3db095e80c6649222d94e/</guid>
      <description>使用svelte开发项目时遇到需要将px转换成rem的需求，有试过postcss-px2rem，postcss-pxtorem，等postcss插件，都没成成功，最后找到了postcss-units插件成功实现。 完整rollup配置文件如下： converts px to rem 该配置是sapper项目配置
import path from &amp;#39;path&amp;#39;; import resolve from &amp;#39;@rollup/plugin-node-resolve&amp;#39;; import replace from &amp;#39;@rollup/plugin-replace&amp;#39;; import commonjs from &amp;#39;@rollup/plugin-commonjs&amp;#39;; import url from &amp;#39;@rollup/plugin-url&amp;#39;; import svelte from &amp;#39;rollup-plugin-svelte&amp;#39;; import babel from &amp;#39;@rollup/plugin-babel&amp;#39;; import { terser } from &amp;#39;rollup-plugin-terser&amp;#39;; import config from &amp;#39;sapper/config/rollup.js&amp;#39;; import pkg from &amp;#39;./package.json&amp;#39;; import sveltePreprocess from &amp;#39;svelte-preprocess&amp;#39;; // import { less } from &amp;#39;svelte-preprocess&amp;#39;; const postcssUnits = require(&amp;#39;postcss-units&amp;#39;); const mode = process.env.NODE_ENV; const dev = mode === &amp;#39;development&amp;#39;; const legacy = !</description>
    </item>
    
    <item>
      <title>svelte函数传参</title>
      <link>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</link>
      <pubDate>Tue, 29 Dec 2020 02:20:33 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fea9271de75f459aa011018/</guid>
      <description>svelte给dom对象绑定事件和vue框架类似。 定义函数：
function handler(index){ alert(&amp;#34;hello&amp;#34;, index); } 绑定事件：
&amp;lt;button on:click={handler}&amp;gt;点击&amp;lt;/button&amp;gt;
但是带参函数的使用就略有不同了，函数handler的参数index需要传入的时候，不能直接这样使用&amp;lt;button on:click={handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt;,这样的写法会在页面打开时直接执行，而不是在点击按钮的时候执行。
这是初学svelte的时候比较郁闷的事，官方文档中也没有明显的文档说明如何传参。 正确的传参方式是这样的： &amp;lt;button on:click={() =&amp;gt; handler(123)}&amp;gt;点击&amp;lt;/button&amp;gt; 将on:click的内容改写为匿名函数，在函数中调用。</description>
    </item>
    
    <item>
      <title>Svelte3路由</title>
      <link>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</link>
      <pubDate>Sat, 28 Nov 2020 07:16:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5fc1f965c0ec0c27f57ac7c9/</guid>
      <description>svelte目前没有提供官网路由组件，不过可以在社区中找到。本文介绍的是svelte-spa-router的使用方法。
npm i svelte-spa-router 参考以下目录结构创建文件（不是必须）
router.js:
import index from &amp;#39;./index/index.svelte&amp;#39;; import a from &amp;#39;./a/a.svelte&amp;#39;; import b from &amp;#39;./b/b.svelte&amp;#39;; export const routes = { &amp;#39;/&amp;#39;: index, &amp;#39;/a&amp;#39;: a, &amp;#39;/b&amp;#39;: b } 动态导入组件和代码分割：
import { wrap } from &amp;#39;svelte-spa-router/wrap&amp;#39; import index from &amp;#39;./index/index.svelte&amp;#39;; export const routes = { &amp;#39;/&amp;#39;: index, &amp;#39;/a&amp;#39;: wrap({ asyncComponent: () =&amp;gt; import(&amp;#39;./a/a.svelte&amp;#39;) }), // &amp;#39;/b&amp;#39;: b // 动态加载 &amp;#39;/b&amp;#39;: wrap({ asyncComponent: () =&amp;gt; import(&amp;#39;./b/b.svelte&amp;#39;) }), } 动态导入组件的优点是组件不会一起打包，而是单独的组件文件，在打开对应的页面时才会请求，可以有效减少包文件大小。 App.svelte:</description>
    </item>
    
    <item>
      <title>vue nuxt组建注册</title>
      <link>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</link>
      <pubDate>Wed, 23 Sep 2020 05:50:12 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f6ae2145edb9b37630b34c1/</guid>
      <description>Nuxt.js 2.13+可以扫描并自动导入您的组件，不再需要在该script部分中手动导入它们！
nuxt.config配置：
export default { components: true } 设置为true或使用对象时，它将包含nuxt / components依赖项，并且~/components在模板中使用它们时会自动导入您的组件。
组件目录：
components/ ComponentFoo.vue ComponentBar.vue 使用
&amp;lt;template&amp;gt; &amp;lt;ComponentFoo /&amp;gt; &amp;lt;component-bar /&amp;gt; &amp;lt;/template&amp;gt; 注意：如果使用nuxt 2.10&amp;hellip;2.13，则还必须手动安装并添加@nuxt/components到buildModulesinside nuxt.config。</description>
    </item>
    
    <item>
      <title>vue子组件修改父组件的数据</title>
      <link>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</link>
      <pubDate>Sat, 01 Aug 2020 03:32:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f24e2665edb9b37630af3bb/</guid>
      <description>vue在子组件中直接修改父组件传递下来的数据会报错： Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop&#39;s value. Prop being mutated: &amp;quot;json&amp;quot;
原因是vue子组件不能直接修改父组件的数据，可以使用this.$emit发送通知，让父组件来修改。 示例代码：
子组件：
this.$emit(&amp;#34;changeData&amp;#34;, &amp;#34;要修改的数据&amp;#34;); 父组件：
&amp;lt;mycomponent :json=&amp;#34;JsonData&amp;#34; @changeData=&amp;#34;changeData&amp;#34;&amp;gt;&amp;lt;/mycomponent&amp;gt; data(){ return { JsonData:{} } } methods:{ changeData(newData){ this.JsonData = newData; } } 子组件发送changeData事件， 父组件绑定changeData事件并接受数据，赋值给父组件的JsonData属性，子组件的值也会改变。从而实现子组件修改父组件的属性值。</description>
    </item>
    
    <item>
      <title>原生js实现图片预览</title>
      <link>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</link>
      <pubDate>Wed, 29 Jul 2020 03:45:04 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5f20f0c05981482973150396/</guid>
      <description>不依赖jquery也可以实现图片预览功能：
&amp;lt;!--图片放大后的div 开始 这块粘贴在你的html中最后body前 --&amp;gt; &amp;lt;div id=&amp;#34;outerdiv&amp;#34; style=&amp;#34;text-align: center;position: fixed;z-index: 9999;top: 0;left: 0;width: 100%;height: 100%;background-color: rgba(28,28,28,0.9);&amp;#34;&amp;gt; &amp;lt;img id=&amp;#34;bigimg&amp;#34; style=&amp;#34;max-height: 800px;max-width: 100%;border: 0;margin: auto;position: absolute;top: 0;bottom: 0;left: 0;right: 0;&amp;#34; src=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--图片放大后的div 结束 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;!--js开始 是放大点击的触发事件 这块粘贴在你的html中最后body前--&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; //图片放大 document.querySelector(&amp;#34;#outerdiv&amp;#34;).style.display = &amp;#34;none&amp;#34;; document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { item.style.cursor = &amp;#34;pointer&amp;#34;; }); document.querySelectorAll(&amp;#34;img&amp;#34;).forEach(function (item) { item.addEventListener(&amp;#34;click&amp;#34;, function () { imgShow(&amp;#34;#outerdiv&amp;#34;, &amp;#34;#bigimg&amp;#34;, this); }) }) function imgShow(outerdiv, bigimg, _this) { var src = _this.</description>
    </item>
    
    <item>
      <title>js转图片为base64上传</title>
      <link>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</link>
      <pubDate>Mon, 25 Jun 2018 07:10:28 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b309564cca06924b14119ea/</guid>
      <description>//上传图片 var imagesBase64 = []; $(&amp;#34;input[type=file]&amp;#34;).on(&amp;#34;change&amp;#34;, function (e) { var image = e.target.files[0]; var imgFile = new FileReader(); var imgShow = new Image(); imgFile.readAsDataURL(image); imgFile.onload = function () { var imgData = this.result; //base64数据 imagesBase64.push({ teaId: teacherInfo.id, fileType: &amp;#34;award&amp;#34;,//图片 fileName: image.name, file: imgData, }); imgShow.src = imgData; imgShow.style.width = &amp;#34;100px&amp;#34;; imgShow.style.height = &amp;#34;100px&amp;#34;; imgShow.title = &amp;#34;双击删除&amp;#34;; $(&amp;#34;#imageShow&amp;#34;).append(imgShow); } }); $(&amp;#34;#imageShow&amp;#34;).on(&amp;#34;dblclick &amp;#34;, &amp;#34;img&amp;#34;, function () { var index = $(&amp;#34;#imageShow &amp;gt; img&amp;#34;).</description>
    </item>
    
    <item>
      <title>webpack构建vue项目警告</title>
      <link>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</link>
      <pubDate>Fri, 16 Feb 2018 13:22:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5a86db29c3700db1c9ae7c55/</guid>
      <description>bundle.js:935 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. (found in &amp;lt;Root&amp;gt;) 解决方案：与entry属性平级添加
resolve: { alias: { &amp;#39;vue$&amp;#39;: &amp;#39;vue/dist/vue.esm.js&amp;#39; //该路径为node_modules下的vue目录 } } // 需要编译器 new Vue({ template: &amp;#39;&amp;lt;div&amp;gt;{{ hi }}&amp;lt;/div&amp;gt;&amp;#39; }) // 不需要编译器 new Vue({ render (h) { return h(&amp;#39;div&amp;#39;, this.hi) } }) 出现警告的原因是使用了template属性。 文文点到为止，详情请直接访问中文官方文档https://cn.vuejs.org/v2/guide/installation.html#对不同构建版本的解释</description>
    </item>
    
    <item>
      <title>js复制文本内容</title>
      <link>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</link>
      <pubDate>Thu, 02 Jun 2016 05:36:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/574fc5f582887be008614fc4/</guid>
      <description>http://yuedun.github.io/copy.html
点击链接查看:js复制</description>
    </item>
    
    <item>
      <title>fullcalendar点击prve或者next按钮翻月触发事件调用</title>
      <link>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</link>
      <pubDate>Tue, 22 Mar 2016 13:32:59 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56f1498b3823e4e62593d4e1/</guid>
      <description>$(&amp;#39;#calendar&amp;#39;).fullCalendar({ lang: &amp;#34;zh-cn&amp;#34;, header: { left: &amp;#39;prev, next, today&amp;#39;, center: &amp;#39;title&amp;#39;, right: &amp;#39;month&amp;#39; }, height: 500, dayClick: function(date, jsEvent, view) { //点击空白日期调用 }, eventClick: function(calEvent, jsEvent, view) { //点击已有数据的日期调用 }, defaultDate: moment(),//默认日期 events:function(start, end, callback){ //点击prev上一月, next下一月等事件时调用 } }); </description>
    </item>
    
    <item>
      <title>vue.js做的应用中点击搜索功能会改变URI</title>
      <link>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</link>
      <pubDate>Thu, 04 Feb 2016 07:59:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56b304d2bf2e89202c146371/</guid>
      <description>用vue.js做的后台管理系统，有一个列表搜索功能，正常登陆进去，直接点击搜索功能，页面就会刷新一遍，原因是url地址变化了
原本地址是：
http://www.mydomain/#!/index
点击搜索以后就变成了
http://www.mydomain/?#!/index
在#!前面自动加了?，导致页面刷新一遍，这样第一次搜索就没意义了.
经过初步排查后发现点击其他按钮不会改变URL地址，对比后发现搜索按钮的type=&amp;ldquo;submit&amp;rdquo;，可能是提交表单导致跳转了，那么将type改为button或者直接去掉试试，结果还是不行，干脆也改为标签（加了bootstrap按钮样式），结果好了。为什么将button type改为button不行呢，原因是在标签内标签type会被默认当做submit，（IE浏览器默认type=button）</description>
    </item>
    
    <item>
      <title>vue.js click点击事件获取当前元素对象</title>
      <link>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</link>
      <pubDate>Wed, 27 Jan 2016 14:59:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56a8db6abf2e89202c146370/</guid>
      <description>Vue.js可以传递$event对象
&amp;lt;body id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-on:click=&amp;#34;say(&amp;#39;hello!&amp;#39;, $event)&amp;#34;&amp;gt;点击当前行文本&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;li2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;li3&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;Hello Vue.js!&amp;#39; }, methods: { say: function(msg, event) { //获取点击对象 var el = event.currentTarget; alert(&amp;#34;当前对象的内容：&amp;#34;+el.innerHTML); } } }) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 函数调用处传递$event
v-on:click=&amp;quot;say(&#39;hello!&#39;, $event)&amp;quot;
函数中获取到的event.currentTarget对象就是当前元素
在线示例
请查看HTML页面示例源码</description>
    </item>
    
    <item>
      <title>vue.js对表单值初始化</title>
      <link>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</link>
      <pubDate>Thu, 14 Jan 2016 01:57:43 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56970097d8e9ee3c03297d3b/</guid>
      <description>新建表单有些input输入框需要默认值，比如性别需要一个男或女默认值。再比如一个日期选择框需要默认今天。如果按照HTML的方式设置不会起作用
&amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;0&amp;#34; checked=&amp;#34;checked&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;男 &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;gender&amp;#34; value=&amp;#34;1&amp;#34; v-model=&amp;#34;gender&amp;#34;&amp;gt;女 &amp;lt;input type=&amp;#34;date&amp;#34; value=&amp;#34;2016-01-06&amp;#34; v-model=&amp;#34;date&amp;#34;&amp;gt; 在vue.js页面中上面这种设置方式是不会起作用的,性别不会选中，日期也不会有值。解决办法是对v-model属性设值，在初始化时给gender=0，那么默认会选中性别男，给date=&amp;ldquo;2016-01-06&amp;quot;日期控件也有值。</description>
    </item>
    
    <item>
      <title>js省市级联动插件</title>
      <link>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</link>
      <pubDate>Tue, 12 Jan 2016 04:45:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/569484ded8e9ee3c03297d3a/</guid>
      <description>在线示例：http://www.yuedun.wang/views/address
具体代码看页面源码</description>
    </item>
    
    <item>
      <title>vue.js中使用focus，blur事件</title>
      <link>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</link>
      <pubDate>Sun, 10 Jan 2016 04:08:19 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5691d933d8e9ee3c03297d39/</guid>
      <description>在线示例
使用focus，blur可对表单进行验证，除了这两个事件，还有一个watch属性可监听data属性值得变化，具体可打开浏览器控制台看属性值得变化情况，代码可直接在浏览器中查看源码</description>
    </item>
    
    <item>
      <title>vue.js开发gulp监听文件变化自动编译</title>
      <link>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</link>
      <pubDate>Mon, 04 Jan 2016 05:52:14 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568a088edb1fef9e0cda949e/</guid>
      <description>直接看代码：
var gulp = require(&amp;#39;gulp&amp;#39;) var webpack = require(&amp;#34;gulp-webpack&amp;#34;); var webpackConfig = require(&amp;#34;./webpack.config.js&amp;#34;); // gulp.task(&amp;#34;webpack&amp;#34;, function(callback) { // var myConfig = Object.create(webpackConfig); // webpack(myConfig, function(err, stats) { // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;err:&amp;#34;+JSON.stringify(err)) // console.log(&amp;#34;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;stats:&amp;#34;+stats) // if(err) throw new Error(&amp;#34;webpack&amp;#34;, err); // callback(); // }); // }); /** * 编译时有错误提示 */ gulp.task(&amp;#34;webpack&amp;#34;, function(){ return gulp.src(&amp;#34;./app.js&amp;#34;) .pipe(webpack(Object.create(webpackConfig))) .pipe(gulp.dest(&amp;#34;./dist/&amp;#34;)) }); gulp.watch(&amp;#39;./views/*&amp;#39;, [&amp;#39;webpack&amp;#39;]); webpack.config.js配置
var webpack = require(&amp;#34;webpack&amp;#34;); module.exports = { entry: //&amp;#34;./app.js&amp;#34;, { app:&amp;#34;./app.js&amp;#34; // vendor: [&amp;#34;.</description>
    </item>
    
    <item>
      <title>vue.js在chrome浏览器下输入汉字会带出拼音</title>
      <link>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</link>
      <pubDate>Fri, 01 Jan 2016 10:19:53 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/568652c9db1fef9e0cda949d/</guid>
      <description>本想写篇vue.js的教程的，但牵扯的知识点比较多，最近又没时间，就记录下过程中遇到问题吧。开发过程中用的360极速浏览器，也没什么问题，但是其他人测试的时候用的是chrome浏览器，输入汉字的时候会连拼音也带进去，比如输入的是“你好”，结果却成了“nihao你好”。
按理说360极速浏览器也用的是chrome内核，不应该出现这两种不同的情况，这个问题先不追究了。还是说说为什么vue.js的输入框会出现拼音的问题。我本以为是浏览器的差异造成这种现象，但是也不是所有输入框都会出现，那一定是程序的问题。
这是一种双向数据绑定常见写法，但是由于我的理解不够透彻，写成了这样：
我的理解是更新的时候要先显示数据，所以就在input里加了value来初始化数据，也是因为加了这个value导致输入汉字出现拼音，也与浏览器有点关系，就是输入的时候chrome浏览器会把输入的汉字拼音拼写也放进输入框，那么数据模型就接收了输入，敲击空格键的时候又输进了汉字，所以就都带进来了。但其实只需要v-model就能实现数据的接收和输出。</description>
    </item>
    
    <item>
      <title>js prototype的理解【转】</title>
      <link>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</link>
      <pubDate>Wed, 25 Nov 2015 02:28:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/56551ce4c72f59d15379b4b8/</guid>
      <description>prototype属性可算是JavaScript与其他面向对象语言的一大不同之处。 prototype就是“一个给类的对象添加方法的方法”，使用prototype属性，可以给类动态地添加方法，以便在JavaScript中实现“ 继承”的效果。
具体来说，prototype 是在 IE 4 及其以后版本引入的一个针对于某一类的对象的方法，当你用prototype编写一个类后，如果new一个新的对象，浏览器会自动把prototype中 的内容替你附加在对象上。这样，通过利用prototype就可以在JavaScript中实现成员函数的定义，甚至是“继承”的效果。
对于javascript本身而言是基于对象的，任何元素都可以看成对象。然而类型和对象是不同的，而我们所讲的prototype属性即是基于类型的一 种属性。对于prototype的基本使用就如对象的创建及属性赋值一样的简单。直接通过赋值操作即可完成属性的创建。
/** * 关于prototype, 理解这个很有必要 可以在类型上使用proptotype来为类型添加行为。这些行为只能在类型的实例上体现。 JS中允许的类型有Array, Boolean, Date, Enumerator, Error, Function, Number, Object, RegExp, String 以后这样分，没有实例化的类称为类型，实例化的类称为对象实例简称实例 */ Object.prototype.name = &amp;#34;zhangsan&amp;#34;; Object.prototype.nihao = function () { alert(&amp;#34;i can method name is &amp;#34; + this.name); } var obj = new Object(); obj.nihao(); alert(obj.name); // 在实例上不能使用prototype，否则会发生编译错误 obj.prototype.sex = &amp;#34;男&amp;#34;; //error,无法给一个实例prototype var o = { name: &amp;#34;zhangsan&amp;#34; } o.prototype.age = 30; //error,无法给一个实例prototype //可以为类型定义“静态”的属性和方法，直接在类型上调用即可 alert(Object.</description>
    </item>
    
    <item>
      <title>js控制优酷视频播放暂停</title>
      <link>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</link>
      <pubDate>Tue, 17 Nov 2015 07:48:37 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/564adbd591dccd315681abfe/</guid>
      <description>js控制优酷视频播放暂停
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0&amp;#34;&amp;gt; &amp;lt;title&amp;gt;js控制优酷视频播放&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;http://player.youku.com/jsapi&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; player = new YKU.Player(&amp;#34;youkuplayer&amp;#34;,{ styleid: &amp;#34;0&amp;#34;, client_id: &amp;#34;d8781b239fdad45b&amp;#34;, vid: &amp;#34;XMjg1MTcyNDQ0&amp;#34;, autoplay: false, show_related: true, events:{ onPlayEnd: function(){ /*your code*/ }, onPlayStart: function(){ /*your code*/ }, onPlayerReady: function(){ /*your code*/ } } }); function playVideo(){ try{ player.playVideo(); } catch(err){ alert(&amp;#34;*&amp;#34;+err); } } function pauseVideo(){ player.pauseVideo(); } function seekTo(s){ player.seekTo(s); } function currentTime(){ return player.</description>
    </item>
    
    <item>
      <title>无插件实现动态瀑布流加载数据</title>
      <link>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</link>
      <pubDate>Tue, 03 Nov 2015 03:02:54 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/563823deaa0d5223f187dfa5/</guid>
      <description>以前在页面中动态加载帖子数据使用了waterfall.js插件，当初折腾了不少时间才搞定，这次又有一个页面需要动态加载数据，自然想到了waterfall插件，但是结果很不理想，waterfall的很多参数不管是什么用处，反正看着很头疼，最麻烦的是它会改变页面样式和布局，实在不想调整了，还是自己实现这个功能吧！
首先看下面代码：
var pageIndex = 2; (function loadmore() { //绑定滚动事件 $(window).bind(&amp;#34;scroll&amp;#34;, function() { if ($(this).scrollTop() + $(window).height() + 40 &amp;gt;= $(document).height() &amp;amp;amp;&amp;amp;amp; $(this).scrollTop() &amp;gt;= 40) { $(window).unbind(&amp;#34;scroll&amp;#34;); //到底后先移除滚动事件 $.get(&amp;#34;/portal/getTopic?pageIndex=&amp;#34; + pageIndex + &amp;#34;&amp;amp;amp;pageSize=3&amp;#34;, function(data) { $(&amp;#34;#container&amp;#34;).append(data); pageIndex++; loadmore(); //数据加载成功重新绑定滚动事件 }, &amp;#34;html&amp;#34;); }; }); })(); 没错，就这么点，这已经是实现功能的最简单版本了。代码的基本流程是给页面绑定滚动事件，判断是否滚动到最底部，然后加载数据。但实际上并不是这么简单就能行的，有很多意外情况需要解决。
先来说明如何判断页面是否滚动到最底部，$(this).scrollTop()用来计算滚动条顶端距离窗口顶部的距离，整个滚动条高度大约等于整个页面高度。当滚动条滚动到最底部的时候，滚动条顶端距离窗口顶部并不是整个页面的高度，还需要加上当前窗口所占高度才是整个页面正真的高度。所以就是$(this).scrollTop() + $(window).height()=$(document).height()，但是我们为什么还要加40呢？因为一般滚动到底部加载并不是完全要滚动到最低端才加载，而是差不多已经到底的时候就要开始加载，既然是差不多到底那么$(this).scrollTop() + $(window).height()就是还不完全等于整个页面高度，因为还有40没有滚动，所以加上了才是整个页面高度。此时滚动到距离最底部还有40像素的时候，再滚动一点就会大于页面高度，就该加载数据了。代码中还有&amp;amp;amp;&amp;amp;amp; $(this).scrollTop() &amp;gt;= 40是为了监听有滚动发生，总不能在没有滚动事件发生时就加载。
已经能够监听到是否滚动到底部了，但是滚动事件是稍微滚动一点就能触发好多次，就会请求好多次数据，就算数据没有返回稍微滚动就会继续发送同样请求，所以在数据没有返回之前要把监听滚动移除掉，$(window).unbind(&amp;quot;scroll&amp;quot;);等数据添加到页面以后再重新绑定滚动事件。</description>
    </item>
    
    <item>
      <title>一次简单的前端页面优化</title>
      <link>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</link>
      <pubDate>Mon, 31 Aug 2015 05:38:08 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/55e3e840db5ac9c2be76b2f9/</guid>
      <description>公司之前的产品管理对于小编们的使用情况及其糟糕，每次打开一个页面都要等待好久，这也是由于时间紧张，开始做的时候就只管进度没有时间优化。我大概看了下，光是登录页和一个空白首页就有78个请求，1.1M的数据。其他功能页面不少于这个数，这是因为所有页面共用了一个头文件，而这个头文件把所有有用没有的css文件和js文件都加载进来了，所以这次做的新后台管理系统绝不能这么做了。
首先，css按需加载，当然有一些css是每个页面必须的就放到一个公共页面中include进来，对于一些新增的插件就在需要的时候添加到对应的页面。
其次，js的加载方式也进行特别优化，一种方式是把js放在body结束标签之前，可以避免js的加载阻塞页面渲染，还有可以使用异步加载方式 defer是针对IE浏览器的，async是其他非IE内核浏览器异步加载属性。但是，我还是使用了requirejs来加载js，一方面是为了页面加载更快，另一方面是可以做到js模块化。
初步结果显示，所有页面加载速度平均在0.5秒，有些页面几乎看不出来重新加载过程，瞬间完成。优化也算是有一定的效果了。其中要说一下requirejs的一些优缺点，requirejs优点是可以实现js异步加载和模块化开发，不过让我有点不适应的是在HTML页面中不能使用onclick=func这种方式的事件处理，会提示找不到函数，只能在页面加载完成后用jquery进行事件监听，一些动态加载的页面数据也需要在加载以后重新绑定事件。
2015-11-08日更新
自从使用了requirejs后，凡是做页面需要js的时候首先想到的就是requirejs，感觉入坑跳不出来，反而弄巧成拙了。requirejs本意是异步加载多个js文件以防止页面阻塞，在一个网站或项目中也尽量合并多个文件里的内容以减少网络请求，一次加载一个大的文件比多次加载多个小文件来的划算的多，还有，requirejs虽然有好处但是并不是任何时候都有，比如页面很简单，js内容也很少的时候就完全不该用它。最后有一个不得不说的缺点，在上面已经提过，就是事件绑定，因为不能使用onclick=func()这种方式调用函数，只能用$(function(){})这种方式绑定事件，那么在网络不好的情况下，有些文件加载缓慢，导致不能绑定事件，如果一个按钮是这种方式绑定的事件，结果就是非要等到页面加载完才能点击，很让人着急。</description>
    </item>
    
    <item>
      <title>前端工具gulp的用途和使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</link>
      <pubDate>Tue, 07 Jul 2015 13:38:18 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/559bd64ad366f15412cbf594/</guid>
      <description>在接触前端开始就听说过grunt和gulp是很叼的前端构建工具，但不知道到底有多叼，只是听说可以自动编译less，sass为css，目前还没有使用less和sass，所以也就没有尝试使用grunt和gulp。但是作为一个技术爱好者还是经不住诱惑，照着网上的教程简单使用了一下，总算是知道有什么用处了，因为都说gulp比grunt更简单好用，就以gulp的使用方法为例来说明一下。
文件合并：关于文件合并很多人存在这样的疑惑，在前端开发中到底该把所有js和css写在一个文件里还是各个页面分开写，我的建议是开发的时候分开写，上线的时候合并为一个，这样的好处是对于浏览器来说，不同页面中相同的文件默认会请求一次缓存下来，其他页面请求相同文件时就直接从缓存中读取，减少文件的网络请求可以提高网页速度，所以文件合并的是很有必要的。
2.文件压缩：既然都合并了，何不再压缩一下呢
3.语法检查：这个功能一般会和下面第4条功能配合使用，当文件修改的时候检查是否有语法错误，并在命令行中输出错误信息。
4.监听文件变化：监听某个目录下文件是否修改，修改的话就执行特定的操作，比如上面几个操作。 以上4点是比较常用的功能，更多功能根据自己需要添加
var gulp = require(&amp;#39;gulp&amp;#39;); var jshint = require(&amp;#39;gulp-jshint&amp;#39;);//语法检查 var concat = require(&amp;#39;gulp-concat&amp;#39;);//合并文件 var uglify = require(&amp;#39;gulp-uglify&amp;#39;);//压缩代码 var rename = require(&amp;#39;gulp-rename&amp;#39;);//重命名 // 语法检查 gulp.task(&amp;#39;jshint&amp;#39;, function () { return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(jshint()) .pipe(jshint.reporter(&amp;#39;default&amp;#39;)); }); // 合并文件之后压缩代码 gulp.task(&amp;#39;minify&amp;#39;, function (){ return gulp.src(&amp;#39;public/javascripts/*.js&amp;#39;) .pipe(concat(&amp;#39;all.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)) .pipe(uglify()) .pipe(rename(&amp;#39;all.min.js&amp;#39;)) .pipe(gulp.dest(&amp;#39;public/javascripts/dist&amp;#39;)); }); // 监视文件的变化 gulp.task(&amp;#39;watch&amp;#39;, function () { gulp.watch(&amp;#39;public/javascripts/*.js&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;]); }); // 注册缺省任务 gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;, &amp;#39;watch&amp;#39;]); // gulp.task(&amp;#39;default&amp;#39;, [&amp;#39;jshint&amp;#39;, &amp;#39;minify&amp;#39;]); 目录结构:</description>
    </item>
    
  </channel>
</rss>
