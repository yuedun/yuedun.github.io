<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>typescript on 月盾的博客</title>
    <link>https://www.yuedun.wang/tags/typescript/</link>
    <description>Recent content in typescript on 月盾的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 11 Jun 2021 14:16:17 +0800</lastBuildDate><atom:link href="https://www.yuedun.wang/tags/typescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>typescript不检查node_moduls</title>
      <link>https://www.yuedun.wang/blogdetail/60b48e405caa4b4dc69e3abf/</link>
      <pubDate>Fri, 11 Jun 2021 14:16:17 +0800</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60b48e405caa4b4dc69e3abf/</guid>
      <description>tsconfig.json 中 exclude node_modules，但 tsc 还是报错。
node_modules/connect-mongo/src/types.d.ts:113:66 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 113 get: (sid: string, callback: (err: any, session: Express.SessionData | null) =&amp;gt; void) =&amp;gt; void; ~~~~~~~~~~~ node_modules/connect-mongo/src/types.d.ts:114:45 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 114 set: (sid: string, session: Express.SessionData, callback?: (err: any) =&amp;gt; void) =&amp;gt; void; ~~~~~~~~~~~ node_modules/connect-mongo/src/types.d.ts:118:47 - error TS2694: Namespace &amp;#39;global.Express&amp;#39; has no exported member &amp;#39;SessionData&amp;#39;. 118 touch: (sid: string, session: Express.</description>
    </item>
    
    <item>
      <title>关于svelte框架——sapper和sveltekit的发展</title>
      <link>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</link>
      <pubDate>Tue, 30 Mar 2021 02:33:30 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/60628dfa8f0b5a0240684581/</guid>
      <description>虽然您可能现在还没有听说过svelte，但是其实svelte的发展速度超过了你的想象。
本文主要讲的是关于sapper和sveltekit这两款框架的发展。
svelte作者里奇·哈里斯（Rich Harris）在2020年10月的svelte峰会上表示：sapper永远不会发布1.0版本。
也就是说sapper不会发布正式版，一直处于非稳定版本。也可能放弃更新。
主要原因是sapper多年来代码库变得凌乱，但更主要的原因是最近网络发生了很大变化。
而作者放弃sapper后的另一种选择是开发SvelteKit。
Sapper和SvelteKit都是svelte的开发框架，类似于vue的nuxt框架。
sveltekit包含的功能有：
服务端渲染（SSR）
路由
typescript支持
less, scss支持
serverless
vite打包
可以看到，sveltekit几乎包含了所有我们想要的功能，既能高效开发，又有高性能。
创建sveltekit的方法： mkdir my-app cd my-app npm init svelte@next npm install npm run dev 需要注意，您的nodejs版本需要更新到v12以上，否则可能出现以下错误：
$ npm run dev -- --open &amp;gt; sveltekit-app@0.0.1 dev D:\workspace\sveltekit-app &amp;gt; svelte-kit dev &amp;#34;--open&amp;#34; D:\workspace\sveltekit-app\node_modules\@sveltejs\kit\svelte-kit.js:2 import &amp;#39;./dist/cli.js&amp;#39;; SyntaxError: Unexpected string at Module._compile (internal/modules/cjs/loader.js:723:23) at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10) at Module.load (internal/modules/cjs/loader.js:653:32) at tryModuleLoad (internal/modules/cjs/loader.js:593:12) at Function.Module._load (internal/modules/cjs/loader.js:585:3) at Function.Module.runMain (internal/modules/cjs/loader.js:831:12) at startup (internal/bootstrap/node.</description>
    </item>
    
    <item>
      <title>typescript中导入koa-error后报错</title>
      <link>https://www.yuedun.wang/blogdetail/5b8e2ce2b1f3aa6dab143109/</link>
      <pubDate>Tue, 04 Sep 2018 06:57:38 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/5b8e2ce2b1f3aa6dab143109/</guid>
      <description>无法重新声明块范围变量“onerror”
解决办法：打开tsconfig.json中的&amp;quot;lib&amp;quot;: [&amp;quot;es2015&amp;quot;, &amp;quot;es2016&amp;quot;, &amp;quot;es2017&amp;quot;]</description>
    </item>
    
    <item>
      <title>typescript开发sequelize返回ModelInstance或null值无法获取属性值</title>
      <link>https://www.yuedun.wang/blogdetail/59f4a228f99acfed859c831e/</link>
      <pubDate>Sat, 28 Oct 2017 15:28:40 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/59f4a228f99acfed859c831e/</guid>
      <description>从图片中的代码可以看出 let userRecord = await item.getUser();获取到的是Bluebird&amp;lt;UserInstance | null&amp;gt;类型，然后在下面获取对象属性的时候报错，错误信息是：
[ts] Object is possibly &amp;#39;null&amp;#39;. let userRecord: UserInstance | null 说对象可能是null，所以无法获取其中的属性。遇到这种情况请设置typescript的编译选项，tsconfig.json文件中的 &amp;quot;strictNullChecks&amp;quot;: true, /* Enable strict null checks. */ 默认是true，即严格null检查，设置为falsse即可。</description>
    </item>
    
    <item>
      <title>typescript泛型的使用方法</title>
      <link>https://www.yuedun.wang/blogdetail/590c93d3266e3f1c8fd4aa83/</link>
      <pubDate>Fri, 05 May 2017 15:01:39 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/590c93d3266e3f1c8fd4aa83/</guid>
      <description>typescript（以下简称ts）中泛型如何使用？（以下代码为ts书写） 个人认为开发语言中一些高级特性如果在不太理解的情况下不使用也无妨，无非是代码写的多一点，烂一点。但是我想作为程序猿大家还是会有所追求的。就以泛型来说，不使用也能正常开发，只不过在个别情况下需要写几份看起来相同的代码。比如在不使用泛型的情况下要求函数参数为number类型，并且返回number。
function a(args: number ): number { return args; } console.log(a(123)); 又有另外一个要求，参数为string类型，并且返回string
function b(args: string ): string { return args; } console.log(b(&amp;#34;sdg&amp;#34;)); 如果还有其他类似的要求，就要不停的写类似格式的代码，那么改进一下：
function c(args: any ): any { return args; } console.log(c(&amp;#34;sdg&amp;#34;)); 这样是可以接受任何类型参数并且返回，但缺点是可以知道能传入任何类型而不知道返回的具体类型是什么，只知道是any类型。将上面的c函数稍作修改：
function c(args: any ): any { let n = args + &amp;#34;变成了字符串&amp;#34;; //甚至更多的处理 return n; } console.log(c(1)); c函数参数是数字，返回的可能是其他类型。 知道前面几种写法的不足再对比一下泛型的写法：
function d&amp;lt;A&amp;gt;(args: A ): A { let n = args + &amp;#34;变成了字符串&amp;#34;; //甚至更多的处理 return n; } console.</description>
    </item>
    
    <item>
      <title>使用typescript开发nodejs的环境搭建（二）</title>
      <link>https://www.yuedun.wang/blogdetail/58243e338fa26c04fd124ee6/</link>
      <pubDate>Thu, 10 Nov 2016 09:30:27 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/58243e338fa26c04fd124ee6/</guid>
      <description>完成了最基本的项目框架以后就是配置编辑器和编译选项，在没有特别配置的情况下，根目录下执行tsc会在ts后缀文件同级目录下生成js后缀的文件， 这样也没什么不可以，但是在编辑器列表中看着有点混乱，生成的js文件是不建议直接修改的，就算修改了下次修改ts文件编译后也会重置文件内容。 所以还是单独有个文件夹存放生成的js文件，这时就要配置tsconfig.json文件了。tsconfig.json文件可以通过tsc --init命令生成，自动生成内容比较简单，是可以直接使用的。 以下的配置是经过一些特别需求配置的，可以直接复制一下内容到tsconfig.json文件中，然后根据自己的需求加减内容。 其余参数可以参考:http://www.tslang.cn/docs/handbook/compiler-options.html
typescript编译配置
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;module&amp;#34;: &amp;#34;commonjs&amp;#34;,//模块化规范 &amp;#34;target&amp;#34;: &amp;#34;es5&amp;#34;,//生成js &amp;#34;noImplicitAny&amp;#34;: true,//在表达式和声明上有隐含的&amp;#39;any&amp;#39;类型时报错 &amp;#34;noImplicitReturns&amp;#34;: true,//函数没有返回值提示 &amp;#34;noFallthroughCasesInSwitch&amp;#34;: true,//switch没有break提示 &amp;#34;removeComments&amp;#34;: true,//输出文件移除注释 &amp;#34;noEmitOnError&amp;#34;: true,//ts文件错误时不生成js &amp;#34;rootDir&amp;#34;: &amp;#34;./&amp;#34;,//需要编译的根目录 &amp;#34;outDir&amp;#34;: &amp;#34;./build&amp;#34;,//编译文件输出目录 &amp;#34;sourceMap&amp;#34;: ture//是否生成.map文件，用于ts debug调试 }, &amp;#34;include&amp;#34;: [ &amp;#34;*/**/*.ts&amp;#34; ], &amp;#34;exclude&amp;#34;: [ //默认排除了node_modules ] } 为了能抛开在命令行中执行tsc命令，能直接通过vscode编辑器来编译，可以使用ctrl+shift+B快捷方式来编译ts文件。第一次使用会有提示
选择TypeScript - Watch-Mode，会在项目根目录下创建.vscode文件夹和tasks.json文件，内容如下：
vscode编译typescript配置
{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, &amp;#34;command&amp;#34;: &amp;#34;tsc&amp;#34;, &amp;#34;isShellCommand&amp;#34;: true, &amp;#34;args&amp;#34;: [&amp;#34;-w&amp;#34;, &amp;#34;-p&amp;#34;, &amp;#34;.&amp;#34;], &amp;#34;showOutput&amp;#34;: &amp;#34;silent&amp;#34;, &amp;#34;isWatching&amp;#34;: true, &amp;#34;problemMatcher&amp;#34;: &amp;#34;$tsc-watch&amp;#34; } 这样就不用每次编译了，只要文件有修改就会自动编译</description>
    </item>
    
    <item>
      <title>TypeScript中的装饰器Decorato什么时候执行？</title>
      <link>https://www.yuedun.wang/blogdetail/58037ab767a381257039c926/</link>
      <pubDate>Sun, 16 Oct 2016 13:03:51 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/58037ab767a381257039c926/</guid>
      <description>ES6引入了类的概念，同时也引入了类似于java的注解概念，我们称之为装饰器，用于在某些场景下修改类和类成员。typescript要支持装饰器需要手动开启experimentalDecorators。
命令行编译
tsc --target ES5 --experimentalDecorators /test.ts 或者配置文件设置：
tsconfig.json:
{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;experimentalDecorators&amp;#34;: true } } 那么这个装饰器到底什么原理呢？它是什么时候执行的？用下面代码为例：
//test.ts class Route { greeting: string; constructor(greet: string){ this.greeting = greet; } @route(&amp;#34;hello&amp;#34;) default(): any { console.log(this.greeting); } } function route(name: string) { return function (target: Object, value: string, desc: PropertyDescriptor) { console.log(&amp;#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;#39;, name); } } 生成的js代码：
//test.js var __decorate = (this &amp;amp;&amp;amp; this.__decorate) || function (decorators, target, key, desc) { var c = arguments.</description>
    </item>
    
    <item>
      <title>使用typescript开发nodejs的环境搭建（一）</title>
      <link>https://www.yuedun.wang/blogdetail/57fcf50869c8bf6e323dff48/</link>
      <pubDate>Tue, 11 Oct 2016 14:19:52 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57fcf50869c8bf6e323dff48/</guid>
      <description>在一切开始之前先具备的开发环境：
nodejs4.0+
推荐的开发工具vscode
我希望通过本文介绍能直接做出一个最简单的项目框架，以便日后参考，这也是我想把之前纯nodejs写的博用typescript客重写一遍。
还是以expressjs为框架来搭建
使用express-generator来生成项目基本框架，需要全局安装
npm install -g express-generator
express -e mpro
参数-e是以ejs为模板引擎，mpor为项目目录名，最后生成这样的目录结构：
. ├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.ejs └── index.ejs 然后是全局安装typescript，便于在任何目录下编译，也可以安装在项目目录下。
npm install -g typescript
安装完以后初始化typescript:
tsc &amp;ndash;init
会在根目录下生成tsconfig.json文件，用于配置ts的编译选项。 有了基本目录以后就可以着手编写代码了，为了使用ts开发，可以手动将routes目录下的js文件 和app.js后缀名改成.ts. 做完以上步骤以后可以试着在项目根目录下执行&amp;gt; tsc命令，可能什么都没发生， 这个命令会默认编译当前目录下的ts文件，但是我们项目中并没有这样的文件， 你可以自己新建一个后缀为.ts的文件再执行&amp;gt; tsc还是什么都没有发生一样，但是如果我们把app.ts (已经改过后缀的app.js文件)中的
var bodyParser = require(&#39;body-parser&#39;); 改成</description>
    </item>
    
    <item>
      <title>使用半年TypeScript后的感受</title>
      <link>https://www.yuedun.wang/blogdetail/57fb9d3169c8bf6e323dff46/</link>
      <pubDate>Mon, 10 Oct 2016 13:52:49 +0000</pubDate>
      
      <guid>https://www.yuedun.wang/blogdetail/57fb9d3169c8bf6e323dff46/</guid>
      <description>初识TypeScript 从入职新公司开始算，使用typescript已经有半年多了，这是一个创业公司使用nodejs开发的后台业务管理系统，已经做的很大了，支撑着公司每月千万人民币的业务处理。很多怀疑nodejs是否可以开发后台管理，作为一个过来人告诉你可以放心使用，现在的javascript早已不是10年前用来写前端特效的js了。美中不足的是nodejs对报表这类数据处理量较大的功能有点力不从心，经常拖垮系统，当然也不是完全不能用nodejs来处理报表，可以合理的使用子进程单独处理数据而不影响主进程。但还是不推荐。
使用感受 其实起初对于typescript开发nodejs我是拒绝的，原因是建立起这个项目的人都走了，而这个项目结构实在是复杂，在windows下环境搭建费了好大精力，尤其是为了使用一个bcrypt加密包，需要安装Python,C++来编译，还不能使用nodejs0.12以上版本，最烦人的是每次修改文件后编译速度非常慢，这让我重新体验了开发JAVA时期的痛苦。而且服务启动方法也是前人自己编写shell脚本来同时编译前端文件和后端文件。并没有使用nodemon,supervisor这种监控工具。后来折腾发现可以直接使用vscode单独编译ts文件，一般12秒就编译完成，这与我之前的项目1秒修改重启相比还是慢了很多，不过也免强只能接受，此时只觉得如此麻烦和JAVA开发有什么区别！所以基于这些不好的体验我很不喜欢typescript。
重新认识 最近又折腾了下我用纯nodejs开发的博客，突然发现，写起来确实不如typescript爽，主要是纯nodejs在webstorm和vscode上语法提示和错误提示较弱，而typescript则可以很好的提示并且在开发过程中就能发现一些很低级错误，不用等到运行时才发现。尤其是对ES6的支持比较完整，甚至可以使用async,await这些ES7提案中的特性。虽然现在高版本的nodejs已经支持一些新特性，但是并不是所有项目都可以使用高版本。如果说为什么要使用typescript，那就是typescript集合了js的快速和强类型语言的安全稳定，用于开发一些较大的项目绝对利大于弊。 尤其是对于一些多人合作的项目来说，typescript的强类型能够很好约束对象属性，参数传递，对后续的重构也起到至关重要的作用。 有人可能会担心降低开发效率，这一点大可不必担心，你定义类型消耗的时间会从强类型提示上补回来的。 接下来会写一篇完整的环境搭建教程：使用typescript开发nodejs的环境搭建（一）</description>
    </item>
    
  </channel>
</rss>
